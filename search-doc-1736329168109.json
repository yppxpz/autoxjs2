{"searchDocs":[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. 提示 Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"axios","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/axios","content":"axios Axios 是一个基于 promise 网络请求库， 作用于node.js和浏览器中。 它提供了http请求的方便封装。 官方中文文档","keywords":"","version":"Next"},{"title":"clip_manager","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/clip_manager","content":"","keywords":"","version":"Next"},{"title":"Variables​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#variables","content":" ","version":"Next","tagName":"h2"},{"title":"clipboardManager​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#clipboardmanager","content":" const clipboardManager: EventEmitter&lt;DefaultEventMap&gt;;   此对象是一个EventEmitter，用于监听剪贴板变化  Template​  clipboardManager.on('clip_changed',()=&gt;{ getClip() })   Defined in​  src/clip_manager/index.ts:17  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#functions","content":" ","version":"Next","tagName":"h2"},{"title":"clearClip()​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#clearclip","content":" function clearClip(): void   清空剪贴板  Returns​  void  Defined in​  src/clip_manager/index.ts:36    ","version":"Next","tagName":"h3"},{"title":"getClip()​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#getclip","content":" function getClip(): string   获取剪贴板内容，需要应用在前台才有效  Returns​  string  Defined in​  src/clip_manager/index.ts:28    ","version":"Next","tagName":"h3"},{"title":"hasClip()​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#hasclip","content":" function hasClip(): boolean   判断剪贴板是否有内容  Returns​  boolean  Defined in​  src/clip_manager/index.ts:32    ","version":"Next","tagName":"h3"},{"title":"setClip()​","type":1,"pageTitle":"clip_manager","url":"/docs/nodejs/docs/clip_manager#setclip","content":" function setClip(text): void   设置剪贴板内容  Parameters​  Parameter\tTypetext\tstring  Returns​  void  Defined in​  src/clip_manager/index.ts:24 ","version":"Next","tagName":"h3"},{"title":"Autox V7 第二代 api 模块","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/","content":"","keywords":"","version":"Next"},{"title":"如何构建？​","type":1,"pageTitle":"Autox V7 第二代 api 模块","url":"/docs/nodejs/docs/#如何构建","content":" 首先运行npm install安装所有依赖项  构建模块  npm run build   构建文档  npm run docs   ","version":"Next","tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"Autox V7 第二代 api 模块","url":"/docs/nodejs/docs/#modules","content":" axiosclip_managerdialogsenginesjavamediatoastvue-ui ","version":"Next","tagName":"h2"},{"title":"java","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/java","content":"","keywords":"","version":"Next"},{"title":"Variables​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#variables","content":" ","version":"Next","tagName":"h2"},{"title":"Packages​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#packages","content":" const Packages: any;   用于向rhino一样访问java类，如Packages.java或Packages.javax此外该模块直接导出了常用的包  import { java, android, com } from 'java' new java.io.File(...)   Defined in​  src/java/index.ts:84    ","version":"Next","tagName":"h3"},{"title":"android​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#android","content":" const android: any = Packages.android;   Defined in​  src/java/index.ts:87    ","version":"Next","tagName":"h3"},{"title":"androidx​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#androidx","content":" const androidx: any = Packages.androidx;   Defined in​  src/java/index.ts:91    ","version":"Next","tagName":"h3"},{"title":"com​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#com","content":" const com: any = Packages.com;   Defined in​  src/java/index.ts:89    ","version":"Next","tagName":"h3"},{"title":"java​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#java-1","content":" const java: any = Packages.java;   Defined in​  src/java/index.ts:86    ","version":"Next","tagName":"h3"},{"title":"javax​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#javax","content":" const javax: any = Packages.javax;   Defined in​  src/java/index.ts:88    ","version":"Next","tagName":"h3"},{"title":"net​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#net","content":" const net: any = Packages.net;   Defined in​  src/java/index.ts:90  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#functions","content":" ","version":"Next","tagName":"h2"},{"title":"invokeDefault()​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#invokedefault","content":" function invokeDefault&lt;T&gt;( javaobj, methodName, args?): Promise&lt;T&gt;   Alpha  采用默认的计算线程池异步调用java方法，返回Promise接受结果  Type Parameters​  Type ParameterT  Parameters​  Parameter\tType\tDescriptionjavaobj\tany\tjava对象，不能是js对象 methodName\tstring\t要调用的方法名 args?\tany[]\t传递的参数  Returns​  Promise&lt;T&gt;  调用结果  Defined in​  src/java/index.ts:33    ","version":"Next","tagName":"h3"},{"title":"invokeIo()​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#invokeio","content":" function invokeIo&lt;T&gt;( javaobj, methodName, args?): Promise&lt;T&gt;   Alpha  和invokeDefault类似，采用io线程池  Type Parameters​  Type ParameterT  Parameters​  Parameter\tType\tDescriptionjavaobj\tany methodName\tstring args?\tany[]\t  Returns​  Promise&lt;T&gt;  Defined in​  src/java/index.ts:55    ","version":"Next","tagName":"h3"},{"title":"invokeUi()​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#invokeui","content":" function invokeUi&lt;T&gt;( javaobj, methodName, args?): Promise&lt;T&gt;   Alpha  和invokeDefault类似，采用ui线程  Type Parameters​  Type ParameterT  Parameters​  Parameter\tType\tDescriptionjavaobj\tany methodName\tstring args?\tany[]\t  Returns​  Promise&lt;T&gt;  Defined in​  src/java/index.ts:69    ","version":"Next","tagName":"h3"},{"title":"loadClass()​","type":1,"pageTitle":"java","url":"/docs/nodejs/docs/java#loadclass","content":" function loadClass(className): JavaClass   Alpha  加载并返回一个java类  Parameters​  Parameter\tType\tDescriptionclassName\tstring\tjava全类名  Returns​  JavaClass  Defined in​  src/java/index.ts:44 ","version":"Next","tagName":"h3"},{"title":"engines","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/engines","content":"","keywords":"","version":"Next"},{"title":"Classes​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#classes","content":" ","version":"Next","tagName":"h2"},{"title":"ScriptEngineProxy​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#scriptengineproxy","content":" Extends​  EventEmitter  Constructors​  new ScriptEngineProxy()​  new ScriptEngineProxy(engine): ScriptEngineProxy   Parameters​  Parameter\tTypeengine\tScriptEngine  Returns​  ScriptEngineProxy  Overrides​  EventEmitter.constructor  Defined in​  src/engines/index.ts:13  Accessors​  id​  get id(): number   Returns​  number  Defined in​  src/engines/index.ts:6  isDestroyed​  get isDestroyed(): boolean   Returns​  boolean  Defined in​  src/engines/index.ts:9  Methods​  cwd()​  cwd(): string   Returns​  string  Defined in​  src/engines/index.ts:31  emit()​  emit&lt;K&gt;(eventName, ...args): boolean   Synchronously calls each of the listeners registered for the event named eventName, in the order they were registered, passing the supplied arguments to each.  Returns true if the event had listeners, false otherwise.  import { EventEmitter } from 'node:events'; const myEmitter = new EventEmitter(); // First listener myEmitter.on('event', function firstListener() { console.log('Helloooo! first listener'); }); // Second listener myEmitter.on('event', function secondListener(arg1, arg2) { console.log(`event with parameters ${arg1}, ${arg2} in second listener`); }); // Third listener myEmitter.on('event', function thirdListener(...args) { const parameters = args.join(', '); console.log(`event with parameters ${parameters} in third listener`); }); console.log(myEmitter.listeners('event')); myEmitter.emit('event', 1, 2, 3, 4, 5); // Prints: // [ // [Function: firstListener], // [Function: secondListener], // [Function: thirdListener] // ] // Helloooo! first listener // event with parameters 1, 2 in second listener // event with parameters 1, 2, 3, 4, 5 in third listener   Type Parameters​  Type ParameterK  Parameters​  Parameter\tTypeeventName\tstring | symbol ...args\tany[]  Returns​  boolean  Since​  v0.1.26  Overrides​  EventEmitter.emit  Defined in​  src/engines/index.ts:17  forceStop()​  forceStop(): void   Returns​  void  Defined in​  src/engines/index.ts:24  ","version":"Next","tagName":"h3"},{"title":"Interfaces​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"ExecutionConfigOptions​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#executionconfigoptions","content":" Properties​  arguments?​  optional arguments: Map&lt;string, any&gt;;   Defined in​  src/engines/index.ts:47  onException()?​  optional onException: (execution, err) =&gt; void;   Parameters​  Parameter\tTypeexecution\tScriptExecution err\tany  Returns​  void  Defined in​  src/engines/index.ts:50  onStart()?​  optional onStart: (execution) =&gt; void;   Parameters​  Parameter\tTypeexecution\tScriptExecution  Returns​  void  Defined in​  src/engines/index.ts:48  onSuccess()?​  optional onSuccess: (execution, result) =&gt; void;   Parameters​  Parameter\tTypeexecution\tScriptExecution result\tany  Returns​  void  Defined in​  src/engines/index.ts:49  workingDirectory?​  optional workingDirectory: string;   Defined in​  src/engines/index.ts:46  ","version":"Next","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#variables","content":" ","version":"Next","tagName":"h2"},{"title":"selfEngine​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#selfengine","content":" const selfEngine: ScriptEngineProxy;   当前运行的引擎  Defined in​  src/engines/index.ts:39  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#functions","content":" ","version":"Next","tagName":"h2"},{"title":"broadcast()​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#broadcast","content":" function broadcast(event, ...args): void   向所有运行中的脚本发送事件，相当于  getRunningEngines().forEach((engine) =&gt; { engine.emit(event, ...args) })   Parameters​  Parameter\tType\tDescriptionevent\tstring ...args\tany\t  Returns​  void  Defined in​  src/engines/index.ts:116    ","version":"Next","tagName":"h3"},{"title":"execScriptFile()​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#execscriptfile","content":" function execScriptFile(path, ops): ScriptExecution   运行一个脚本文件  Parameters​  Parameter\tType\tDescriptionpath\tstring\t只能是绝对路径，不支持相对路径 ops\tExecutionConfigOptions\t  Returns​  ScriptExecution  Defined in​  src/engines/index.ts:65    ","version":"Next","tagName":"h3"},{"title":"getRunningEngines()​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#getrunningengines","content":" function getRunningEngines(): ScriptEngineProxy[]   获取所有运行中的脚本  Returns​  ScriptEngineProxy[]  Defined in​  src/engines/index.ts:99    ","version":"Next","tagName":"h3"},{"title":"myEngine()​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#myengine","content":" function myEngine(): ScriptEngineProxy   获取当前运行的引擎  Returns​  ScriptEngineProxy  Defined in​  src/engines/index.ts:56    ","version":"Next","tagName":"h3"},{"title":"stopAll()​","type":1,"pageTitle":"engines","url":"/docs/nodejs/docs/engines#stopall","content":" function stopAll(): void   停止所有运行中的脚本，包括自身  Returns​  void  Defined in​  src/engines/index.ts:92 ","version":"Next","tagName":"h3"},{"title":"toast","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/toast","content":"","keywords":"","version":"Next"},{"title":"Functions​","type":1,"pageTitle":"toast","url":"/docs/nodejs/docs/toast#functions","content":" ","version":"Next","tagName":"h2"},{"title":"showToast()​","type":1,"pageTitle":"toast","url":"/docs/nodejs/docs/toast#showtoast","content":" function showToast(message, option?): void   弹出一条toast  Parameters​  Parameter\tType\tDescriptionmessage\tany\t要显示的消息 option?\tstring | ToastOptions\t可以是`&quot;short&quot;  Returns​  void  Example​  import { showToast } from 'toast' showToast('hello world')   Defined in​  src/toast/index.ts:14 ","version":"Next","tagName":"h3"},{"title":"media","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/media","content":"","keywords":"","version":"Next"},{"title":"Classes​","type":1,"pageTitle":"media","url":"/docs/nodejs/docs/media#classes","content":" ","version":"Next","tagName":"h2"},{"title":"MediaPlayer​","type":1,"pageTitle":"media","url":"/docs/nodejs/docs/media#mediaplayer","content":" Constructors​  new MediaPlayer()​  new MediaPlayer(): MediaPlayer   Returns​  MediaPlayer  Accessors​  androidMediaPlayer​  get androidMediaPlayer(): any   Returns​  any  Defined in​  src/media/index.ts:5  currentPosition​  get currentPosition(): number   Returns​  number  当前播放位置。单位毫秒。  Defined in​  src/media/index.ts:11  duration​  get duration(): number   Returns​  number  音乐时长。单位毫秒。  Defined in​  src/media/index.ts:17  isPlaying​  get isPlaying(): boolean   Returns​  boolean  Defined in​  src/media/index.ts:20  Methods​  pause()​  pause(): void   Returns​  void  Defined in​  src/media/index.ts:30  play()​  play( uri, volume?, looping?): Promise&lt;void&gt;   Parameters​  Parameter\tTypeuri\tstring volume?\tnumber looping?\tboolean  Returns​  Promise&lt;void&gt;  Defined in​  src/media/index.ts:23  prepare()​  prepare(): Promise&lt;void&gt;   Returns​  Promise&lt;void&gt;  Defined in​  src/media/index.ts:33  prepareSync()​  prepareSync(): void   Returns​  void  Defined in​  src/media/index.ts:36  release()​  release(): void   Returns​  void  Defined in​  src/media/index.ts:39  reset()​  reset(): void   Returns​  void  Defined in​  src/media/index.ts:42  seekTo()​  seekTo(msec): Promise&lt;void&gt;   Parameters​  Parameter\tTypemsec\tnumber  Returns​  Promise&lt;void&gt;  Defined in​  src/media/index.ts:45  setDataSource()​  setDataSource(path): void   Parameters​  Parameter\tTypepath\tstring  Returns​  void  Defined in​  src/media/index.ts:48  setLooping()​  setLooping(looping): void   Parameters​  Parameter\tTypelooping\tboolean  Returns​  void  Defined in​  src/media/index.ts:51  setScreenOnWhilePlaying()​  setScreenOnWhilePlaying(keep): void   Parameters​  Parameter\tTypekeep\tboolean  Returns​  void  Defined in​  src/media/index.ts:54  setVolume()​  setVolume(leftVolume, rightVolume?): void   Parameters​  Parameter\tTypeleftVolume\tnumber rightVolume?\tnumber  Returns​  void  Defined in​  src/media/index.ts:57  start()​  start(): void   Returns​  void  Defined in​  src/media/index.ts:61  stop()​  stop(): void   Returns​  void  Defined in​  src/media/index.ts:64  ","version":"Next","tagName":"h3"},{"title":"README","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/vue-ui/documents/","content":"","keywords":"","version":"Next"},{"title":"入门​","type":1,"pageTitle":"README","url":"/docs/nodejs/docs/vue-ui/documents/#入门","content":" 想要创建一个界面首先你需要从vue-ui模块导入各种函数，如  import { createApp, xml, startActivity, ModifierExtension } from &quot;vue-ui&quot;;   使用createApp创建一个 app 实例，与 vue 的方法相同，不过其中必须包含render函数， 用于创建 Vnode。  const app = createApp({ render() { return xml` &lt;column&gt; UI内容 &lt;/column&gt; `; }, });   render渲染函数会在数据变化时调用许多次，你不能在这个函数中做任何与创建 Vnode 无关的事。 创建好后使用startActivity函数将打开一个界面并显示。  startActivity(app);   startActivity会返回一个Promise,你可以通过await等待 Activity 启动完成并得到 Activity 实例。 与第 1 代 api 不同，你无需在脚本最前面加上'ui';，因为脚本线程始终与 ui 线程分离， 这样你还可以通过多次调用startActivity启动多个 Activity，但必须是不同的 app 实例。  ","version":"Next","tagName":"h2"},{"title":"组件​","type":1,"pageTitle":"README","url":"/docs/nodejs/docs/vue-ui/documents/#组件","content":"","version":"Next","tagName":"h2"},{"title":"Functions​","type":1,"pageTitle":"media","url":"/docs/nodejs/docs/media#functions","content":" ","version":"Next","tagName":"h2"},{"title":"playMusic()​","type":1,"pageTitle":"media","url":"/docs/nodejs/docs/media#playmusic","content":" function playMusic( uri, volume?, looping?): Promise&lt;MediaPlayer&gt;   Parameters​  Parameter\tTypeuri\tstring volume?\tnumber looping?\tboolean  Returns​  Promise&lt;MediaPlayer&gt;  Defined in​  src/media/index.ts:69    ","version":"Next","tagName":"h3"},{"title":"scanFile()​","type":1,"pageTitle":"media","url":"/docs/nodejs/docs/media#scanfile","content":" function scanFile(file): void   Parameters​  Parameter\tTypefile\tstring  Returns​  void  Defined in​  src/media/index.ts:75 ","version":"Next","tagName":"h3"},{"title":"Icons","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Icons","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons#interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"Icons​","type":1,"pageTitle":"Icons","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons#icons-1","content":" Properties​  AccountBox​  AccountBox: ImageVector;   Defined in​  src/vue-ui/icons.ts:18  Add​  Add: ImageVector;   Defined in​  src/vue-ui/icons.ts:4  ArrowBack​  ArrowBack: ImageVector;   Defined in​  src/vue-ui/icons.ts:5  ArrowDropDown​  ArrowDropDown: ImageVector;   Defined in​  src/vue-ui/icons.ts:19  Call​  Call: ImageVector;   Defined in​  src/vue-ui/icons.ts:3  Clear​  Clear: ImageVector;   Defined in​  src/vue-ui/icons.ts:6  Close​  Close: ImageVector;   Defined in​  src/vue-ui/icons.ts:10  Done​  Done: ImageVector;   Defined in​  src/vue-ui/icons.ts:20  Edit​  Edit: ImageVector;   Defined in​  src/vue-ui/icons.ts:7  Home​  Home: ImageVector;   Defined in​  src/vue-ui/icons.ts:12  MailOutline​  MailOutline: ImageVector;   Defined in​  src/vue-ui/icons.ts:16  Menu​  Menu: ImageVector;   Defined in​  src/vue-ui/icons.ts:8  MoreVert​  MoreVert: ImageVector;   Defined in​  src/vue-ui/icons.ts:15  Notifications​  Notifications: ImageVector;   Defined in​  src/vue-ui/icons.ts:13  Person​  Person: ImageVector;   Defined in​  src/vue-ui/icons.ts:21  Refresh​  Refresh: ImageVector;   Defined in​  src/vue-ui/icons.ts:17  Search​  Search: ImageVector;   Defined in​  src/vue-ui/icons.ts:9  Settings​  Settings: ImageVector;   Defined in​  src/vue-ui/icons.ts:14  Star​  Star: ImageVector;   Defined in​  src/vue-ui/icons.ts:11  ","version":"Next","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Icons","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons#variables","content":" ","version":"Next","tagName":"h2"},{"title":"Default​","type":1,"pageTitle":"Icons","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons#default","content":" const Default: Icons;   Defined in​  src/vue-ui/icons.ts:44    ","version":"Next","tagName":"h3"},{"title":"Filled​","type":1,"pageTitle":"Icons","url":"/docs/nodejs/docs/vue-ui/namespaces/Icons#filled","content":" const Filled: Icons;   Defined in​  src/vue-ui/icons.ts:42 ","version":"Next","tagName":"h3"},{"title":"dialogs","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/dialogs","content":"","keywords":"","version":"Next"},{"title":"Enumerations​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#enumerations","content":" ","version":"Next","tagName":"h2"},{"title":"DialogEvent​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#dialogevent","content":" Events​  ON_DISMISS​  ON_DISMISS: &quot;dismiss&quot;;   Defined in​  src/dialogs/index.ts:36  ON_INPUT_CHANGE​  ON_INPUT_CHANGE: &quot;input_change&quot;;   Defined in​  src/dialogs/index.ts:44  ON_NEGATIVE​  ON_NEGATIVE: &quot;negative&quot;;   Defined in​  src/dialogs/index.ts:40  ON_NEUTRAL​  ON_NEUTRAL: &quot;neutral&quot;;   Defined in​  src/dialogs/index.ts:42  ON_POSITIVE​  ON_POSITIVE: &quot;positive&quot;;   Defined in​  src/dialogs/index.ts:38  ","version":"Next","tagName":"h3"},{"title":"Classes​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#classes","content":" ","version":"Next","tagName":"h2"},{"title":"DialogFactory​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#dialogfactory","content":" Implements​  IDialogs  Constructors​  new DialogFactory()​  new DialogFactory(): DialogFactory   Returns​  DialogFactory  Properties​  showin​  showin: ShallowReactive&lt;Set&lt;[Component, DialogStatus]&gt;&gt;;   Defined in​  src/dialogs/DialogFactory.ts:24  Accessors​  Dialog​  get Dialog(): Component   Returns​  Component  Defined in​  src/dialogs/DialogFactory.ts:26  Methods​  _mountUi()​  _mountUi(comp, ops): DialogInterface   Parameters​  Parameter\tTypecomp\tComponent ops\tDialogOps  Returns​  DialogInterface  Defined in​  src/dialogs/DialogFactory.ts:53  showAlertDialog()​  showAlertDialog(title, options): Promise&lt;void&gt;   Parameters​  Parameter\tTypetitle\tstring options\tDialogBuilderOptions  Returns​  Promise&lt;void&gt;  Implementation of​  IDialogs.showAlertDialog  Defined in​  src/dialogs/DialogFactory.ts:74  showConfirmDialog()​  showConfirmDialog(title, options): Promise&lt;boolean&gt;   Parameters​  Parameter\tTypetitle\tstring options\tDialogBuilderOptions  Returns​  Promise&lt;boolean&gt;  Implementation of​  IDialogs.showConfirmDialog  Defined in​  src/dialogs/DialogFactory.ts:80  showDialog()​  showDialog(options): DialogInterface   Parameters​  Parameter\tTypeoptions\tDialogBuilderOptions  Returns​  DialogInterface  Implementation of​  IDialogs.showDialog  Defined in​  src/dialogs/DialogFactory.ts:67  showInputDialog()​  showInputDialog( title, prefill?, options?): Promise&lt;null | string&gt;   Parameters​  Parameter\tTypetitle\tstring prefill?\tstring options?\tInputDialogOptions  Returns​  Promise&lt;null | string&gt;  Implementation of​  IDialogs.showInputDialog  Defined in​  src/dialogs/DialogFactory.ts:86  showMultiChoiceDialog()​  showMultiChoiceDialog( title, items, initialSelectedIndices?, options?): Promise&lt;null | number[]&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] initialSelectedIndices?\tnumber[] options?\tDialogBuilderOptions  Returns​  Promise&lt;null | number[]&gt;  Implementation of​  IDialogs.showMultiChoiceDialog  Defined in​  src/dialogs/DialogFactory.ts:98  showSelectDialog()​  showSelectDialog( title, items, options?): Promise&lt;number&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] options?\tDialogBuilderOptions  Returns​  Promise&lt;number&gt;  Implementation of​  IDialogs.showSelectDialog  Defined in​  src/dialogs/DialogFactory.ts:92  showSingleChoiceDialog()​  showSingleChoiceDialog( title, items, initialSelectedIndex?, options?): Promise&lt;number&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] initialSelectedIndex?\tnumber options?\tDialogBuilderOptions  Returns​  Promise&lt;number&gt;  Implementation of​  IDialogs.showSingleChoiceDialog  Defined in​  src/dialogs/DialogFactory.ts:104  ","version":"Next","tagName":"h3"},{"title":"Interfaces​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"DialogInterface​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#dialoginterface","content":" Extends​  EventEmitter&lt;Record&lt;DialogEvent, any[]&gt;&gt;  Methods​  dismiss()​  dismiss(): void   Returns​  void  Defined in​  src/dialogs/index.ts:47    ","version":"Next","tagName":"h3"},{"title":"IDialogs​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#idialogs","content":" Methods​  showAlertDialog()​  showAlertDialog(title, options?): Promise&lt;void&gt;   Parameters​  Parameter\tTypetitle\tstring options?\tDialogBuilderOptions  Returns​  Promise&lt;void&gt;  Defined in​  src/dialogs/options.ts:103  showConfirmDialog()​  showConfirmDialog(title, options?): Promise&lt;boolean&gt;   Parameters​  Parameter\tTypetitle\tstring options?\tDialogBuilderOptions  Returns​  Promise&lt;boolean&gt;  Defined in​  src/dialogs/options.ts:104  showDialog()​  showDialog(options): DialogInterface   Parameters​  Parameter\tTypeoptions\tDialogBuilderOptions  Returns​  DialogInterface  Defined in​  src/dialogs/options.ts:102  showInputDialog()​  showInputDialog( title, prefill?, options?): Promise&lt;null | string&gt;   Parameters​  Parameter\tTypetitle\tstring prefill?\tstring options?\tInputDialogOptions  Returns​  Promise&lt;null | string&gt;  Defined in​  src/dialogs/options.ts:105  showMultiChoiceDialog()​  showMultiChoiceDialog( title, items, initialSelectedIndices?, options?): Promise&lt;null | number[]&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] initialSelectedIndices?\tnumber[] options?\tDialogBuilderOptions  Returns​  Promise&lt;null | number[]&gt;  Defined in​  src/dialogs/options.ts:107  showSelectDialog()​  showSelectDialog( title, items, options?): Promise&lt;number&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] options?\tDialogBuilderOptions  Returns​  Promise&lt;number&gt;  Defined in​  src/dialogs/options.ts:106  showSingleChoiceDialog()​  showSingleChoiceDialog( title, items, initialSelectedIndex?, options?): Promise&lt;number&gt;   Parameters​  Parameter\tTypetitle\tstring items\tstring[] initialSelectedIndex?\tnumber options?\tDialogBuilderOptions  Returns​  Promise&lt;number&gt;  Defined in​  src/dialogs/options.ts:111  ","version":"Next","tagName":"h3"},{"title":"Type Aliases​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#type-aliases","content":" ","version":"Next","tagName":"h2"},{"title":"DialogType​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#dialogtype","content":" type DialogType: &quot;app&quot; | &quot;overlay&quot; | DialogFactory;   Defined in​  src/dialogs/index.ts:14  ","version":"Next","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#variables","content":" ","version":"Next","tagName":"h2"},{"title":"defaultDialogType​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#defaultdialogtype","content":" const defaultDialogType: DialogType = 'app';   Defined in​  src/dialogs/index.ts:15  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#functions","content":" ","version":"Next","tagName":"h2"},{"title":"showAlertDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showalertdialog-2","content":" function showAlertDialog(title, options?): Promise&lt;void&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring options?\tDialogBuilderOptions\t  Returns​  Promise&lt;void&gt;  Promise将在对话框消失时完成  Defined in​  src/dialogs/index.ts:106    ","version":"Next","tagName":"h3"},{"title":"showAppDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showappdialog","content":" function showAppDialog(comp, ops?): AppDialogBuilder   Parameters​  Parameter\tTypecomp\tComponent ops?\tDialogOps  Returns​  AppDialogBuilder  Defined in​  src/dialogs/index.ts:18    ","version":"Next","tagName":"h3"},{"title":"showConfirmDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showconfirmdialog-2","content":" function showConfirmDialog(title, options?): Promise&lt;boolean&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring options?\tDialogBuilderOptions\t  Returns​  Promise&lt;boolean&gt;  只在点击positive按钮时返回true,其他情况返回false  Defined in​  src/dialogs/index.ts:125    ","version":"Next","tagName":"h3"},{"title":"showDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showdialog-2","content":" function showDialog(options): DialogInterface   Parameters​  Parameter\tTypeoptions\tDialogBuilderOptions  Returns​  DialogInterface  Defined in​  src/dialogs/index.ts:61    ","version":"Next","tagName":"h3"},{"title":"showInputDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showinputdialog-2","content":" function showInputDialog( title, prefill?, options?): Promise&lt;null | string&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring prefill?\tstring\t输入框的默认内容 options?\tInputDialogOptions\t  Returns​  Promise&lt;null | string&gt;  点击positive时返回字符串，即使输入为空，被取消时返回null  Defined in​  src/dialogs/index.ts:149    ","version":"Next","tagName":"h3"},{"title":"showMultiChoiceDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showmultichoicedialog-2","content":" function showMultiChoiceDialog( title, items, initialSelectedIndices?, options?): Promise&lt;null | number[]&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring items\tstring[]\t可多选的项目 initialSelectedIndices?\tnumber[]\t初始选中的项目索引数组 options?\tDialogBuilderOptions\t  Returns​  Promise&lt;null | number[]&gt;  返回选中的项目索引数组，被取消则返回null  Defined in​  src/dialogs/index.ts:229    ","version":"Next","tagName":"h3"},{"title":"showSelectDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showselectdialog-2","content":" function showSelectDialog( title, items, options?): Promise&lt;number&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring items\tstring[]\t选项数组 options?\tDialogBuilderOptions\t  Returns​  Promise&lt;number&gt;  返回选中的项目索引，被取消则返回-1  Defined in​  src/dialogs/index.ts:190    ","version":"Next","tagName":"h3"},{"title":"showSingleChoiceDialog()​","type":1,"pageTitle":"dialogs","url":"/docs/nodejs/docs/dialogs#showsinglechoicedialog-2","content":" function showSingleChoiceDialog( title, items, initialSelectedIndex?, options?): Promise&lt;number&gt;   Parameters​  Parameter\tType\tDescriptiontitle\tstring items\tstring[] initialSelectedIndex?\tnumber options?\tDialogBuilderOptions\t  Returns​  Promise&lt;number&gt;  返回选中的项目索引，被取消则返回-1  Defined in​  src/dialogs/index.ts:290 ","version":"Next","tagName":"h3"},{"title":"vue-ui","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/vue-ui/","content":"","keywords":"","version":"Next"},{"title":"Documents​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#documents","content":" README  ","version":"Next","tagName":"h2"},{"title":"Namespaces​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#namespaces","content":" IconsModifierExtensionTheme  ","version":"Next","tagName":"h2"},{"title":"Interfaces​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"ActivityEventListener​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#activityeventlistener","content":" Methods​  onActivityResult()​  onActivityResult(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:10  onBackPressed()​  onBackPressed(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:11  onConfigurationChanged()​  onConfigurationChanged(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:15  onCreate()​  onCreate(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:4  onDestroy()​  onDestroy(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:9  onNewIntent()​  onNewIntent(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:12  onPause()​  onPause(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:7  onRecreate()​  onRecreate(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:13  onResume()​  onResume(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:6  onSaveInstanceState()​  onSaveInstanceState(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:14  onStart()​  onStart(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:5  onStop()​  onStop(...args): any   Parameters​  Parameter\tType...args\tany[]  Returns​  any  Defined in​  src/vue-ui/types.ts:8  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#functions","content":" ","version":"Next","tagName":"h2"},{"title":"createApp()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#createapp","content":" function createApp(rootComponent, rootProps?): App&lt;PxElement&gt;   Parameters​  Parameter\tTyperootComponent\tComponent&lt;any, any, any, ComputedOptions, MethodOptions, object, any&gt; rootProps?\tnull | Data  Returns​  App&lt;PxElement&gt;  Defined in​  src/vue-ui/index.ts:28    ","version":"Next","tagName":"h3"},{"title":"render()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#render","content":" function render( vnode, container, namespace?): void   Parameters​  Parameter\tTypevnode\tnull | VNode&lt;RendererNode, RendererElement, object&gt; container\tPxElement namespace?\tElementNamespace  Returns​  void  Defined in​  src/vue-ui/index.ts:27    ","version":"Next","tagName":"h3"},{"title":"renderActivity()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#renderactivity","content":" function renderActivity(vnode, listener?): void   Parameters​  Parameter\tTypevnode\tVNode&lt;RendererNode, RendererElement, object&gt; listener?\tActivityEventListener  Returns​  void  Defined in​  src/vue-ui/index.ts:48    ","version":"Next","tagName":"h3"},{"title":"setDebug()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#setdebug","content":" function setDebug(d): void   Parameters​  Parameter\tTyped\tboolean  Returns​  void  Defined in​  src/vue-ui/nodeOps.ts:86    ","version":"Next","tagName":"h3"},{"title":"startActivity()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#startactivity","content":" function startActivity(app, listener?): Promise&lt;Activity&gt;   启动Activity并挂载app实例作为内容  Parameters​  Parameter\tType\tDescriptionapp\tApp&lt;PxElement&gt;\tVue的app实例 listener?\tActivityEventListener\t用于监听该Activity各种事件的监听器  Returns​  Promise&lt;Activity&gt;  当Activity创建完成后返回该Activity实例  Defined in​  src/vue-ui/index.ts:69    ","version":"Next","tagName":"h3"},{"title":"xml()​","type":1,"pageTitle":"vue-ui","url":"/docs/nodejs/docs/vue-ui/#xml","content":" function xml(strings, ...values): VNode&lt;RendererNode, RendererElement, object&gt; | VNode&lt;RendererNode, RendererElement, object&gt;[]   该函数用于创建VNode节点，详细参考htm  Parameters​  Parameter\tTypestrings\tTemplateStringsArray ...values\tany[]  Returns​  VNode&lt;RendererNode, RendererElement, object&gt; | VNode&lt;RendererNode, RendererElement, object&gt;[]  Defined in​  src/vue-ui/index.ts:82 ","version":"Next","tagName":"h3"},{"title":"ModifierExtension","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension","content":"","keywords":"","version":"Next"},{"title":"Functions​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#functions","content":" ","version":"Next","tagName":"h2"},{"title":"background()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#background","content":" function background(color): ModifierExt   设置背景色，传入'theme'表示使用当前主题的背景色, 使用数值表示时必须是bigint，普通数值在java会转成Int溢出范围  Parameters​  Parameter\tType\tDescriptioncolor\tstring | bigint\t颜色值,如0xffffcc12n的数值或#ffcc89的字符串  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:27    ","version":"Next","tagName":"h3"},{"title":"clickable()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#clickable","content":" function clickable(clickable): ModifierExt   设置组件可点击，大部分组件会自动添加相应的点击效果  Parameters​  Parameter\tType\tDescriptionclickable\t() =&gt; void\t  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:101    ","version":"Next","tagName":"h3"},{"title":"fillMaxHeight()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#fillmaxheight","content":" function fillMaxHeight(): ModifierExt   Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:50    ","version":"Next","tagName":"h3"},{"title":"fillMaxSize()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#fillmaxsize","content":" function fillMaxSize(): ModifierExt   Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:44    ","version":"Next","tagName":"h3"},{"title":"fillMaxWidth()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#fillmaxwidth","content":" function fillMaxWidth(): ModifierExt   Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:47    ","version":"Next","tagName":"h3"},{"title":"height()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#height","content":" function height(height): ModifierExt   设置高度，单位为dp  Parameters​  Parameter\tType\tDescriptionheight\tnumber\t  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:66    ","version":"Next","tagName":"h3"},{"title":"heightIn()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#heightin","content":" function heightIn(min?, max?): ModifierExt   设置组件最小或最大高度  Parameters​  Parameter\tType\tDescriptionmin?\tnumber\t最小值，可以为null max?\tnumber\t最大值，可以为null  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:133    ","version":"Next","tagName":"h3"},{"title":"horizontalScroll()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#horizontalscroll","content":" function horizontalScroll(): ModifierExt   设置可水平滚动  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:108    ","version":"Next","tagName":"h3"},{"title":"padding()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#padding","content":" function padding( left, top?, right?, bottom?): ModifierExt   设置padding，传递一个值时表示四边均使用此值， 传递两个值时第一个参数表示水平padding，第二个参数表示垂直padding  Parameters​  Parameter\tType\tDescriptionleft\tnumber top?\tnumber right?\tnumber bottom?\tnumber\t  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:86    ","version":"Next","tagName":"h3"},{"title":"rotate()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#rotate","content":" function rotate(angle): ModifierExt   设置旋转角度  Parameters​  Parameter\tType\tDescriptionangle\tnumber\t一般为0~360  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:74    ","version":"Next","tagName":"h3"},{"title":"verticalScroll()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#verticalscroll","content":" function verticalScroll(): ModifierExt   设置可垂直滚动  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:115    ","version":"Next","tagName":"h3"},{"title":"weight()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#weight","content":" function weight(i): ModifierExt   仅在row和column直接子组件上使用有效,表示此组件占用父组件剩余空间的权重, 假如有一个row剩余高度为300，有一个子组件这设置了此修饰符为1,那么它的高度为300, 如果有两个组件都设为1，那么这两个组件各得150高度  Parameters​  Parameter\tType\tDescriptioni\tnumber\t  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:37    ","version":"Next","tagName":"h3"},{"title":"width()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#width","content":" function width(width): ModifierExt   设置高度，单位为dp  Parameters​  Parameter\tType\tDescriptionwidth\tnumber\t  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:58    ","version":"Next","tagName":"h3"},{"title":"widthIn()​","type":1,"pageTitle":"ModifierExtension","url":"/docs/nodejs/docs/vue-ui/namespaces/ModifierExtension#widthin","content":" function widthIn(min?, max?): ModifierExt   设置组件最小或最大宽度  Parameters​  Parameter\tType\tDescriptionmin?\tnumber\t最小值，可以为null max?\tnumber\t最大值，可以为null  Returns​  ModifierExt  Defined in​  src/vue-ui/modifierExtension.ts:124 ","version":"Next","tagName":"h3"},{"title":"概述","type":0,"sectionRef":"#","url":"/docs/nodejs/intro","content":"","keywords":"","version":"Next"},{"title":"启用 nodejs 引擎​","type":1,"pageTitle":"概述","url":"/docs/nodejs/intro#启用-nodejs-引擎","content":" 默认情况下 js 文件由第一代引擎(Rhino)运行，当文件名由 mjs,cjs,node.js 结尾时使用 nodejs 引擎运行，以 mjs 结尾还会启用 esm 模块特性，这是推荐的运行方式  ","version":"Next","tagName":"h2"},{"title":"从全局变量改为导入模块​","type":1,"pageTitle":"概述","url":"/docs/nodejs/intro#从全局变量改为导入模块","content":" 在第 2 代 api，所有模块全部需要使用import 关键字导入，如import { showToast } from 'toast',暂不支持require()和import()动态导入  import { showToast } from &quot;toast&quot;;   ","version":"Next","tagName":"h2"},{"title":"多线程与异步​","type":1,"pageTitle":"概述","url":"/docs/nodejs/intro#多线程与异步","content":" 在 nodejs 引擎将不再支持多线程，取而代之的是Promise和异步函数，第二代 api 大多数都将以返回Promise表示异步操作，对于来自 java 的阻塞调用（如 io 读写）可通过java模块中的相关函数转换成一个Promise而不阻塞 nodejs 线程。  注意 如果你强行使用java.lang.Thread类运行 js 代码将会使引擎崩溃  ........待补充  ","version":"Next","tagName":"h2"},{"title":"autox v7 开发进度​","type":1,"pageTitle":"概述","url":"/docs/nodejs/intro#autox-v7-开发进度","content":"  分离脚本引擎运行的进程使脚本运行在与 app 不同的进程，彻底解决脚本崩溃连同 app 一起崩溃的问题 迁移 app 界面至 m3 风格 完善的插件扩展功能使用一个独立的页面显示已安装和可下载的插件，采用激活/禁用的方式在每次运行脚本时自动加载插件，无需在代码中显式加载 集成基于Javet的 v8/nodejs 引擎 nodejs 引擎功能模块适配 全新的 ui 设计框架，采用 vue3 的vue-core框架与htm模板引擎基于新的引擎设计，支持组件和 vue 一样的响应式状态  ","version":"Next","tagName":"h2"},{"title":"参与开发基本操作​","type":1,"pageTitle":"概述","url":"/docs/nodejs/intro#参与开发基本操作","content":" V7 版本开发目前由开发者【aiselp】组成，如有兴趣共同参与开发和测试可加入本人创建的tg 开发群交流  首先确保你已经 fork 了此仓库，并且已拉取到本地并能够完成构建打开一个终端切换到项目目录输入  git remote add aiselp git@github.com:aiselp/AutoX.git #更新远程仓库 git fetch --all   创建并拉取 v7 分支  git checkout -b setup-v7 aiselp/setup-v7   推送到你的远程仓库并设置为默认git push -u origin setup-v7其中 origin 表示你的远程仓库名，可能并非为 origin ","version":"Next","tagName":"h2"},{"title":"在 vscode 开发","type":0,"sectionRef":"#","url":"/docs/nodejs/vscode","content":"","keywords":"","version":"Next"},{"title":"ts 项目模板​","type":1,"pageTitle":"在 vscode 开发","url":"/docs/nodejs/vscode#ts-项目模板","content":" 你可以在此页面中下载v7-project-demo.rar得到一个基本 ts 项目模板，解压后使用 vscode 打开，随后运行npm install安装所有依赖。  在根目录下有一个 scr 文件夹，这里存放你所有的源代码。  运行npm run build编译源代码并生成 dist 文目录，该文件夹输出的是能运行在 autox 中的项目。  ","version":"Next","tagName":"h2"},{"title":"启用 v7 模块代码提示​","type":1,"pageTitle":"在 vscode 开发","url":"/docs/nodejs/vscode#启用-v7-模块代码提示","content":" 首先，进入项目目录，安装 autox-v7-api  npm i -D autox-v7-api   提示 当 autox v7 新增 api 后可重新运行以上命令获取更新  随后，如果你使用打包工具，可直接从autox-v7-api/[模块id]导入模块，如  import { showToast } from &quot;autox-v7-api/toast&quot;;   此方式会将模块代码一起打包到输出的文件。  否则，如果你不使用打包工具或不想用上面的方式，输入npx install-autox-types根据提示选择项目类型，接着在项目中使用正常的模块导入如  import { showToast } from &quot;toast&quot;;   此方式会修改项目中的 tsconfig.json 文件 ","version":"Next","tagName":"h2"},{"title":"综述","type":0,"sectionRef":"#","url":"/docs/overview","content":"综述 由于原作者不再维护 Auto.js，我计划在原来 4.1 版本的基础上继续维护项目，并将原项目命名为 AutoX.js。 欢迎更多开发者参与这个项目的维护与升级。 这篇文档里有加密相关的内容可能和实际运行情况有冲突，我会逐步完善更新，程序代码，尽可能保持一致。 AutoX.js 使用 JavaScript 作为脚本语言，目前使用 Rhino 1.7.13 作为脚本引擎，支持 ES5 与部分 ES6 特性。 学习 AutoX.js 的 API 之前，建议先学习 JavaScript 的基本语法。如果想要在电脑上开发 AutoX.js，可以使用 VSCode 以及 AutoX.js 插件。如果想要使用 TypeScript 来开发，目前有开发者公布了一个 相关工具。 AutoX.js 下载地址 在 Github Releases 下载 AutoX.js 的功能 AutoX.js 项目工程化：结合 webpack vscode 插件，开发、编译、打包、部署、混淆、加密一体化 文档资料 vscode 插件右键，自动提示操作等 下载地址 vscode 自动补全、方法注释等 文档资料 修复众多 bug，升级到 5.0.1 ,合并打包插件，升级配置文件等功能 建设论坛、提供 交流社区 建设应用商店 提供更好的 SDK 封装 支持 WebSocket 模块 本文档的章节大致上是以模块来划分的，总体上可以分成&quot;自动操作&quot;类模块（控件操作、触摸模拟、按键模拟等）和其他类模块（设备、应用、界面等）。 &quot;自动操作&quot;的部分又可以大致分为 基于控件 和 基于坐标 的操作。 基于坐标的操作是通过指定具体的屏幕坐标，进行点击，例如 click(100, 200) 等，这种方式在游戏类脚本中比较有可行性，结合找图找色、坐标放缩功能也能达到较好的兼容性。但是，这种方式对于一般软件脚本不是很高效，而且需要安卓 7.0 以上或 root 权限才能执行。 软件类脚本（例如：批量添加联系人、自动提取短信验证码等等）我们推荐采用基于控件的模拟操作，结合通知、按键等达成更好的工作流。 其他模块主要包括： app: 应用。启动应用，卸载应用，使用应用查看、编辑文件、访问网页，发送应用间广播等。console: 控制台。记录运行的日志、错误、信息等。device: 设备。获取设备屏幕宽高、系统版本等信息，控制设备音量、亮度等。engines: 脚本引擎。用于启动其他脚本。events: 事件与监听。按键监听，通知监听，触摸监听等。floaty: 悬浮窗。用于显示自定义的悬浮窗。files: 文件系统。文件创建、获取信息、读写。http: HTTP。发送 HTTP 请求，例如 GET, POST 等。websocket: websocket 客户端、服务器端，可以进行主动推送消息images, colors: 图片和图色处理。截图，剪切图片，找图找色，读取保存图片等。keys: 按键模拟。比如音量键、Home 键模拟等。shell: Shell 命令。threads: 多线程支持。ui: UI 界面。用于显示自定义的 UI 界面，和用户交互。 除此之外，AutoX.js 内置了对 Promise 的支持。 参与共建 软件源码 文档源码 本文档更新稍有滞后，某些模块文档并没写完，希望有开发者共同参与维护！ 不用担心你不懂，我们可以讨论交流! 欢迎大家 PR ，共同参与开源！","keywords":"","version":"Next"},{"title":"AutoX.js 文档","type":0,"sectionRef":"#","url":"/docs/rhino/","content":"","keywords":"","version":"Next"},{"title":"本地开发​","type":1,"pageTitle":"AutoX.js 文档","url":"/docs/rhino/#本地开发","content":" fork 本项目clone 自己的仓库到本地使用 vscode 打开安装 npm i docsify-cli -g运行 docsify serve . (后面有个 点)浏览器访问 http://localhost:3000 ","version":"Next","tagName":"h2"},{"title":"Base64 编码","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/base64","content":"Base64 编码 提供基本的 Base64 转换函数。 $base64.encode(str[, encoding = 'utf-8') str {string} 要编码的字符串encoding {string} 可选，字符编码 将字符串 str autox.js 使用 Base64 编码并返回编码后的字符串。 log($base64.encode(&quot;autox.js&quot;)); // 日志输出 YXV0b3gunM= $base64.decode(str[, encoding = 'utf-8']) str {string} 要解码的字符串encoding {string} 可选，字符编码 将字符串 st YXV0b3gunM= r 使用 Base64 解码并返回解码后的字符串。 log($base64.decode(&quot;YXV0b3gunM&quot;)); // 日志输出 autox.js ","keywords":"","version":"Next"},{"title":"Theme","type":0,"sectionRef":"#","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme","content":"","keywords":"","version":"Next"},{"title":"axios","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/axios","content":"","keywords":"","version":"Next"},{"title":"axios.browser​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#axiosbrowser","content":" 用于模拟浏览器环境的对象，包含XMLHttpRequest、FormData等，除了FormData，其他对象都不建议使用。  ","version":"Next","tagName":"h2"},{"title":"axios.utils​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#axiosutils","content":" 包含一些操作blob对象方法  ","version":"Next","tagName":"h2"},{"title":"utils.saveBlobToFile(blob, path)​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#utilssaveblobtofileblob-path","content":" blob 要保存的对象path 保存路径  保存blob对象到指定路径，返回一个Promise。  ","version":"Next","tagName":"h3"},{"title":"utils.openFile(path)​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#utilsopenfilepath","content":" path 要打开的文件路径  打开一个文件，返回一个blob对象  ","version":"Next","tagName":"h3"},{"title":"utils.copyInputStream(inputstream, outputstream)​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#utilscopyinputstreaminputstream-outputstream","content":" inputstreamjava输入流outputstream java输出流  拷贝输入流到输出流，这个函数是阻塞的，且不会自动关闭流。  ","version":"Next","tagName":"h3"},{"title":"utils.ThreadPool​","type":1,"pageTitle":"axios","url":"/docs/rhino/advanced/axios#utilsthreadpool","content":" 此对象用于将一个同步函数转成异步方法运行，返回一个Promise，例如  let promise = ThreadPool.run(()&gt;{ //同步代码，返回值就是Promise的返回值 })  ","version":"Next","tagName":"h3"},{"title":"Interfaces​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"ColorSchemeOptions​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#colorschemeoptions","content":" Properties​  background?​  optional background: Color;   Defined in​  src/vue-ui/theme.ts:17  error?​  optional error: Color;   Defined in​  src/vue-ui/theme.ts:26  errorContainer?​  optional errorContainer: Color;   Defined in​  src/vue-ui/theme.ts:28  inverseOnSurface?​  optional inverseOnSurface: Color;   Defined in​  src/vue-ui/theme.ts:25  inversePrimary?​  optional inversePrimary: Color;   Defined in​  src/vue-ui/theme.ts:8  inverseSurface?​  optional inverseSurface: Color;   Defined in​  src/vue-ui/theme.ts:24  onBackground?​  optional onBackground: Color;   Defined in​  src/vue-ui/theme.ts:18  onError?​  optional onError: Color;   Defined in​  src/vue-ui/theme.ts:27  onErrorContainer?​  optional onErrorContainer: Color;   Defined in​  src/vue-ui/theme.ts:29  onPrimary?​  optional onPrimary: Color;   Defined in​  src/vue-ui/theme.ts:5  onPrimaryContainer?​  optional onPrimaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:7  onSecondary?​  optional onSecondary: Color;   Defined in​  src/vue-ui/theme.ts:10  onSecondaryContainer?​  optional onSecondaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:12  onSurface?​  optional onSurface: Color;   Defined in​  src/vue-ui/theme.ts:20  onSurfaceVariant?​  optional onSurfaceVariant: Color;   Defined in​  src/vue-ui/theme.ts:22  onTertiary?​  optional onTertiary: Color;   Defined in​  src/vue-ui/theme.ts:14  onTertiaryContainer?​  optional onTertiaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:16  outline?​  optional outline: Color;   Defined in​  src/vue-ui/theme.ts:30  outlineVariant?​  optional outlineVariant: Color;   Defined in​  src/vue-ui/theme.ts:31  primary?​  optional primary: Color;   Defined in​  src/vue-ui/theme.ts:4  primaryContainer?​  optional primaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:6  scrim?​  optional scrim: Color;   Defined in​  src/vue-ui/theme.ts:32  secondary?​  optional secondary: Color;   Defined in​  src/vue-ui/theme.ts:9  secondaryContainer?​  optional secondaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:11  surface?​  optional surface: Color;   Defined in​  src/vue-ui/theme.ts:19  surfaceBright?​  optional surfaceBright: Color;   Defined in​  src/vue-ui/theme.ts:33  surfaceContainer?​  optional surfaceContainer: Color;   Defined in​  src/vue-ui/theme.ts:35  surfaceContainerHigh?​  optional surfaceContainerHigh: Color;   Defined in​  src/vue-ui/theme.ts:36  surfaceContainerHighest?​  optional surfaceContainerHighest: Color;   Defined in​  src/vue-ui/theme.ts:37  surfaceContainerLow?​  optional surfaceContainerLow: Color;   Defined in​  src/vue-ui/theme.ts:38  surfaceContainerLowest?​  optional surfaceContainerLowest: Color;   Defined in​  src/vue-ui/theme.ts:39  surfaceDim?​  optional surfaceDim: Color;   Defined in​  src/vue-ui/theme.ts:34  surfaceTint?​  optional surfaceTint: Color;   Defined in​  src/vue-ui/theme.ts:23  surfaceVariant?​  optional surfaceVariant: Color;   Defined in​  src/vue-ui/theme.ts:21  tertiary?​  optional tertiary: Color;   Defined in​  src/vue-ui/theme.ts:13  tertiaryContainer?​  optional tertiaryContainer: Color;   Defined in​  src/vue-ui/theme.ts:15  ","version":"Next","tagName":"h3"},{"title":"Type Aliases​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#type-aliases","content":" ","version":"Next","tagName":"h2"},{"title":"Color​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#color","content":" type Color: string | bigint;   Defined in​  src/vue-ui/theme.ts:2  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#functions","content":" ","version":"Next","tagName":"h2"},{"title":"darkColorScheme()​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#darkcolorscheme","content":" function darkColorScheme(ops): ColorScheme   Parameters​  Parameter\tTypeops\tColorSchemeOptions  Returns​  ColorScheme  Defined in​  src/vue-ui/theme.ts:42    ","version":"Next","tagName":"h3"},{"title":"lightColorScheme()​","type":1,"pageTitle":"Theme","url":"/docs/nodejs/docs/vue-ui/namespaces/Theme#lightcolorscheme","content":" function lightColorScheme(ops): ColorScheme   Parameters​  Parameter\tTypeops\tColorSchemeOptions  Returns​  ColorScheme  Defined in​  src/vue-ui/theme.ts:49 ","version":"Next","tagName":"h3"},{"title":"Canvas 画布","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/canvas","content":"","keywords":"","version":"Next"},{"title":"canvas.drawARGB(a, r, g, b)​","type":1,"pageTitle":"Canvas 画布","url":"/docs/rhino/advanced/canvas#canvasdrawargba-r-g-b","content":" ","version":"Next","tagName":"h2"},{"title":"canvas.draw​","type":1,"pageTitle":"Canvas 画布","url":"/docs/rhino/advanced/canvas#canvasdraw","content":"","version":"Next","tagName":"h2"},{"title":"协程","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/continuation","content":"","keywords":"","version":"Next"},{"title":"Promise.coroutine()​","type":1,"pageTitle":"协程","url":"/docs/rhino/advanced/continuation#promisecoroutine","content":" v6.3.7 新增在该版本引入 bluebird 后你可以使用 bluebird 带来的一项协程特性，这个方法接收一个Generator 函数作为参数，函数内部可以像async 函数一样编写，返回一个返回值为Promise的函数，说起来可能有点难以理解，具体看下方例子  //async函数写法 let main = async function (s) { var result = await Promise.resolve(&quot;value:&quot; + s); return result; }; //Generator 函数写法 let main = Promise.coroutine(function* (s) { var result = yield Promise.resolve(&quot;value:&quot; + s); return result; }); main(&quot;test&quot;).then(log);   可以看到只要将 await 关键换成 yield 就能够代替还不支持的 async 函数，下方是一个异步循环的例子  let main = Promise.coroutine(function* (size) { for (var i = 0; i &lt; size; i++) { yield Promise.delay(1000); log(i); } log(&quot;end&quot;); }); main(10); //在控制台每秒输出一个数字   与 async 函数不同的是 yield 关键字作为表达式使用时必须带上圆括号，否则会有语法错误，在默认情况下 yield 后面只能是 Promise 或带有 then 方法的对象，要处理其他类型数据需要使用Promise.coroutine.addYieldHandler()添加处理器  ","version":"Next","tagName":"h2"},{"title":"Promise.coroutine.addYieldHandler(handler)​","type":1,"pageTitle":"协程","url":"/docs/rhino/advanced/continuation#promisecoroutineaddyieldhandlerhandler","content":" handler {function} 处理函数  函数的参数为 yield 的导出，反回值为 yield 的反回 ","version":"Next","tagName":"h2"},{"title":"crypto 消息处理（加密，摘要）","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/crypto","content":"crypto 消息处理（加密，摘要） $crypto 模块提供了对称加密（例如 AES）、非对称加密（例如 RSA）、消息摘要（例如 MD5, SHA）等支持。 let message = &quot;未加密字符串&quot;; log(&quot;明文: &quot;, message); // 密钥，由于AES等算法要求是16位的倍数，我们这里用一个16位的密钥 let key = new $crypto.Key(&quot;password12345678&quot;); log(&quot;密钥: &quot;, key); // AES加密 let aes = $crypto.encrypt(message, key, &quot;AES/ECB/PKCS5padding&quot;); log(&quot;AES加密后二进制数据: &quot;, aes); log( &quot;AES解密: &quot;, $crypto.decrypt(aes, key, &quot;AES/ECB/PKCS5padding&quot;, { output: &quot;string&quot; }) ); // RSA加密 // 生成RSA密钥 let keyPair = $crypto.generateKeyPair(&quot;RSA&quot;); log(&quot;密钥对: &quot;, keyPair); // 使用私钥加密 let rsa = $crypto.encrypt(message, keyPair.privateKey, &quot;RSA/ECB/PKCS1padding&quot;); log(&quot;RSA私钥加密后二进制数据: &quot;, rsa); // 使用公钥解密 log( &quot;RSA公钥解密: &quot;, $crypto.decrypt(rsa, keyPair.publicKey, &quot;RSA/ECB/PKCS1padding&quot;, { output: &quot;string&quot;, }) ); // 字符串消息摘要 let message = &quot;Hello, Autox.js&quot;; // 输出各种消息摘要算法结果的hex值 log(&quot;字符串: &quot;, message); log(&quot;MD5: &quot;, $crypto.digest(message, &quot;MD5&quot;)); log(&quot;SHA1: &quot;, $crypto.digest(message, &quot;SHA-1&quot;)); log(&quot;SHA256: &quot;, $crypto.digest(message, &quot;SHA-256&quot;)); // 输出各种消息摘要算法结果的base64值 log(&quot;MD5 [base64]: &quot;, $crypto.digest(message, &quot;MD5&quot;, { output: &quot;base64&quot; })); log(&quot;SHA1 [base64]: &quot;, $crypto.digest(message, &quot;SHA-1&quot;, { output: &quot;base64&quot; })); log( &quot;SHA256 [base64]: &quot;, $crypto.digest(message, &quot;SHA-256&quot;, { output: &quot;base64&quot; }) ); // 文件消息摘要 let file = &quot;/sdcard/脚本/_test_for_message_digest.js&quot;; // 写入文件内容，提供为后续计算MD5等 $files.write(file, &quot;Test!&quot;); log(&quot;文件: &quot;, file); log(&quot;MD5: &quot;, $crypto.digest(file, &quot;MD5&quot;, { input: &quot;file&quot; })); log(&quot;SHA1: &quot;, $crypto.digest(file, &quot;SHA-1&quot;, { input: &quot;file&quot; })); log(&quot;SHA256: &quot;, $crypto.digest(file, &quot;SHA-256&quot;, { input: &quot;file&quot; })); ","keywords":"","version":"Next"},{"title":"Engines 引擎","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/engines","content":"","keywords":"","version":"Next"},{"title":"engines.execScript(name, script[, config])​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesexecscriptname-script-config","content":" name {string} 要运行的脚本名称。这个名称和文件名称无关，只是在任务管理中显示的名称。script {string} 要运行的脚本内容。config {Object} 运行配置项 delay {number} 延迟执行的毫秒数，默认为 0loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。interval {number} 循环运行时两次运行之间的时间间隔，默认为 0path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。  在新的脚本环境中运行脚本 script。返回一个ScriptExectuion对象。  所谓新的脚本环境，指定是，脚本中的变量和原脚本的变量是不共享的，并且，脚本会在新的线程中运行。  最简单的例子如下：  engines.execScript(&quot;hello world&quot;, &quot;toast('hello world')&quot;);   如果要循环运行，则：  //每隔 3 秒运行一次脚本，循环 10 次 engines.execScript(&quot;hello world&quot;, &quot;toast('hello world')&quot;, { loopTimes: 10, interval: 3000, });   用字符串来编写脚本非常不方便，可以结合 Function.toString()的方法来执行特定函数:  function helloWorld() { //注意，这里的变量和脚本主体的变量并不共享 toast(&quot;hello world&quot;); } engines.execScript(&quot;hello world&quot;, &quot;helloWorld();\\n&quot; + helloWorld.toString());   如果要传递变量，则可以把这些封装成一个函数：  function exec(action, args) { args = args || {}; engines.execScript( action.name, action + &quot;(&quot; + JSON.stringify(args) + &quot;);\\n&quot; + action.toString() ); } //要执行的函数，是一个简单的加法 function add(args) { toast(args.a + args.b); } //在新的脚本环境中执行 1 + 2 exec(add, { a: 1, b: 2 });   ","version":"Next","tagName":"h2"},{"title":"engines.execScriptFile(path[, config])​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesexecscriptfilepath-config","content":" path {string} 要运行的脚本路径。config {Object} 运行配置项 delay {number} 延迟执行的毫秒数，默认为 0loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。interval {number} 循环运行时两次运行之间的时间间隔，默认为 0path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。  在新的脚本环境中运行脚本文件 path。返回一个ScriptExecution对象。  engines.execScriptFile(&quot;/sdcard/脚本/1.js&quot;);   ","version":"Next","tagName":"h2"},{"title":"engines.execAutoFile(path[, config])​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesexecautofilepath-config","content":" path {string} 要运行的录制文件路径。config {Object} 运行配置项 delay {number} 延迟执行的毫秒数，默认为 0loopTimes {number} 循环运行次数，默认为 1。0 为无限循环。interval {number} 循环运行时两次运行之间的时间间隔，默认为 0path {Array} | {string} 指定脚本运行的目录。这些路径会用于 require 时寻找模块文件。  在新的脚本环境中运行录制文件 path。返回一个ScriptExecution对象。  engines.execAutoFile(&quot;/sdcard/脚本/1.auto&quot;);   ","version":"Next","tagName":"h2"},{"title":"engines.stopAll()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesstopall","content":" 停止所有正在运行的脚本。包括当前脚本自身。  ","version":"Next","tagName":"h2"},{"title":"engines.stopAllAndToast()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesstopallandtoast","content":" 停止所有正在运行的脚本并显示停止的脚本数量。包括当前脚本自身。  ","version":"Next","tagName":"h2"},{"title":"engines.myEngine()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesmyengine","content":" 返回当前脚本的脚本引擎对象(ScriptEngine)  [v4.1.0 新增]特别的，该对象可以通过execArgv来获取他的运行参数，包括外部参数、intent 等。例如：  log(engines.myEngine().execArgv);   普通脚本的运行参数通常为空，通过定时任务的广播启动的则可以获取到启动的 intent。  ","version":"Next","tagName":"h2"},{"title":"engines.all()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#enginesall","content":" 返回 {Array}  返回当前所有正在运行的脚本的脚本引擎ScriptEngine的数组。  log(engines.all());   ScriptExecution  执行脚本时返回的对象，可以通过他获取执行的引擎、配置等，也可以停止这个执行。  要停止这个脚本的执行，使用exectuion.getEngine().forceStop().  ","version":"Next","tagName":"h2"},{"title":"ScriptExecution.getEngine()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptexecutiongetengine","content":" 返回执行该脚本的脚本引擎对象(ScriptEngine)  ","version":"Next","tagName":"h2"},{"title":"ScriptExecution.getConfig()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptexecutiongetconfig","content":" 返回该脚本的运行配置(ScriptConfig)  ScriptEngine  脚本引擎对象。  ","version":"Next","tagName":"h2"},{"title":"ScriptEngine.isDestroyed()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptengineisdestroyed","content":" 返回 {Boolean}  检测该脚本是否执行结束  let e = engines.execScriptFile(&quot;xx.js&quot;); sleep(2000); log(e.getEngine().isDestroyed())   ","version":"Next","tagName":"h2"},{"title":"ScriptEngine.forceStop()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptengineforcestop","content":" 停止脚本引擎的执行。  ","version":"Next","tagName":"h2"},{"title":"ScriptEngine.cwd()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptenginecwd","content":" 返回 {string}  返回脚本执行的路径。对于一个脚本文件而言为这个脚本所在的文件夹；对于其他脚本，例如字符串脚本，则为null或者执行时的设置值。  ","version":"Next","tagName":"h2"},{"title":"ScriptEngine.getSource()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptenginegetsource","content":" 返回 ScriptSource  返回当前脚本引擎正在执行的脚本对象。  log(engines.myEngine().getSource());   ","version":"Next","tagName":"h2"},{"title":"ScriptEngine.emit(eventName[, ...args])​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#scriptengineemiteventname-args","content":" eventName {string} 事件名称...args {any} 事件参数  向该脚本引擎发送一个事件，该事件可以在该脚本引擎对应的脚本的 events 模块监听到并在脚本主线程执行事件处理。  例如脚本 receiver.js 的内容如下：  //监听 say 事件 events.on(&quot;say&quot;, function (words) { toastLog(words); }); //保持脚本运行 setInterval(() =&gt; {}, 1000);   同一目录另一脚本可以启动他并发送该事件：  //运行脚本 var e = engines.execScriptFile(&quot;./receiver.js&quot;); //等待脚本启动 sleep(2000); //向该脚本发送事件 e.getEngine().emit(&quot;say&quot;, &quot;你好&quot;);   ScriptConfig  脚本执行时的配置。  ","version":"Next","tagName":"h2"},{"title":"delay​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#delay","content":" {number}  延迟执行的毫秒数  ","version":"Next","tagName":"h2"},{"title":"interval​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#interval","content":" {number}  循环运行时两次运行之间的时间间隔  ","version":"Next","tagName":"h2"},{"title":"loopTimes​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#looptimes","content":" {number}  循环运行次数  ","version":"Next","tagName":"h2"},{"title":"getPath()​","type":1,"pageTitle":"Engines 引擎","url":"/docs/rhino/advanced/engines#getpath","content":" 返回 {Array}  返回一个字符串数组表示脚本运行时模块寻找的路径。 ","version":"Next","tagName":"h2"},{"title":"Media 多媒体","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/media","content":"","keywords":"","version":"Next"},{"title":"media.scanFile(path)​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediascanfilepath","content":" path {string} 媒体文件路径  扫描路径 path 的媒体文件，将它加入媒体库中；或者如果该文件以及被删除，则通知媒体库移除该文件。  媒体库包括相册、音乐库等，因此该函数可以用于把某个图片文件加入相册。  //请求截图 requestScreenCapture(false); //截图 var im = captureScreen(); var path = &quot;/sdcard/screenshot.png&quot;; //保存图片 im.saveTo(path); //把图片加入相册 media.scanFile(path);   ","version":"Next","tagName":"h2"},{"title":"media.playMusic(path[, volume, looping])​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediaplaymusicpath-volume-looping","content":" path {string} 音乐文件路径volume {number} 播放音量，为 0~1 的浮点数，默认为 1looping {boolean} 是否循环播放，如果 looping 为true则循环播放，默认为false  播放音乐文件 path。该函数不会显示任何音乐播放界面。如果文件不存在或者文件不是受支持的音乐格式，则抛出UncheckedIOException异常。  //播放音乐 media.playMusic(&quot;/sdcard/1.mp3&quot;); //让音乐播放完 sleep(media.getMusicDuration());   如果要循环播放音乐，则使用 looping 参数：  ```js //传递第三个参数为true以循环播放音乐 media.playMusic(&quot;/sdcard/1.mp3&quot;, 1, true); //等待三次播放的时间 sleep(media.getMusicDuration() * 3);   如果要使用音乐播放器播放音乐，调用app.viewFile(path)函数。  ","version":"Next","tagName":"h2"},{"title":"media.musicSeekTo(msec)​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediamusicseektomsec","content":" msec {number} 毫秒数，表示音乐进度  把当前播放进度调整到时间 msec 的位置。如果当前没有在播放音乐，则调用函数没有任何效果。  例如，要把音乐调到 1 分钟的位置，为media.musicSeekTo(60 * 1000)。  //播放音乐 media.playMusic(&quot;/sdcard/1.mp3&quot;); //调整到30秒的位置 media.musicSeekTo(30 * 1000); //等待音乐播放完成 sleep(media.getMusicDuration() - 30 * 1000);   ","version":"Next","tagName":"h2"},{"title":"media.pauseMusic()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediapausemusic","content":" 暂停音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。  ","version":"Next","tagName":"h2"},{"title":"media.resumeMusic()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediaresumemusic","content":" 继续音乐播放。如果当前没有播放过音乐，则调用该函数没有任何效果。  ","version":"Next","tagName":"h2"},{"title":"media.stopMusic()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediastopmusic","content":" 停止音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。  ","version":"Next","tagName":"h2"},{"title":"media.isMusicPlaying()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediaismusicplaying","content":" 返回 {boolean}  返回当前是否正在播放音乐。  ","version":"Next","tagName":"h2"},{"title":"media.getMusicDuration()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediagetmusicduration","content":" 返回 {number}  返回当前音乐的时长。单位毫秒。  ","version":"Next","tagName":"h2"},{"title":"media.getMusicCurrentPosition()​","type":1,"pageTitle":"Media 多媒体","url":"/docs/rhino/advanced/media#mediagetmusiccurrentposition","content":" 返回 {number}  返回当前音乐的播放进度(已经播放的时间)，单位毫秒。 ","version":"Next","tagName":"h2"},{"title":"Floaty 悬浮窗","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/floaty","content":"","keywords":"","version":"Next"},{"title":"floaty.checkPermission()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#floatycheckpermission","content":" [4.2.17 新增]  返回 {boolean}  返回当前应用是否有悬浮窗权限。（不会触发请求权限操作）  ","version":"Next","tagName":"h2"},{"title":"floaty.requestPermission()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#floatyrequestpermission","content":" [4.2.17 新增]  跳转到系统的悬浮窗权限请求界面。  if (!floaty.checkPermission()) { // 没有悬浮窗权限，提示用户并跳转请求 toast( &quot;本脚本需要悬浮窗权限来显示悬浮窗，请在随后的界面中允许并重新运行本脚本。&quot; ); floaty.requestPermission(); exit(); } else { toastLog(&quot;已有悬浮窗权限&quot;); }   ","version":"Next","tagName":"h2"},{"title":"floaty.window(layout)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#floatywindowlayout","content":" layout {xml} | {View} 悬浮窗界面的 XML 或者 View  指定悬浮窗的布局，创建并显示一个悬浮窗，返回一个FloatyWindow对象。  该悬浮窗自带关闭、调整大小、调整位置按键，可根据需要调用setAdjustEnabled()函数来显示或隐藏。  其中 layout 参数可以是 xml 布局或者一个 View，更多信息参见 ui 模块的说明。  例子：  var w = floaty.window( &lt;frame gravity=&quot;center&quot;&gt; &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt; &lt;/frame&gt; ); setTimeout(() =&gt; { w.close(); }, 2000);   这段代码运行后将会在屏幕上显示悬浮文字，并在两秒后消失。  另外，因为脚本运行的线程不是 UI 线程，而所有对控件的修改操作需要在 UI 线程执行，此时需要用ui.run，例如:  ui.run(function () { w.text.setText(&quot;文本&quot;); });   有关返回的FloatyWindow对象的说明，参见下面的FloatyWindow章节。  ","version":"Next","tagName":"h2"},{"title":"floaty.rawWindow(layout)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#floatyrawwindowlayout","content":" layout {xml} | {View} 悬浮窗界面的 XML 或者 View  指定悬浮窗的布局，创建并显示一个原始悬浮窗，返回一个FloatyRawWindow对象。  与floaty.window()函数不同的是，该悬浮窗不会增加任何额外设施（例如调整大小、位置按钮），您可以根据自己需要编写任何布局。  而且，该悬浮窗支持完全全屏，可以覆盖状态栏，因此可以做护眼模式之类的应用。  var w = floaty.rawWindow( &lt;frame gravity=&quot;center&quot;&gt; &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt; &lt;/frame&gt; ); w.setPosition(500, 500); setTimeout(() =&gt; { w.close(); }, 2000);   这段代码运行后将会在屏幕上显示悬浮文字，并在两秒后消失。  有关返回的FloatyRawWindow对象的说明，参见下面的FloatyRawWindow章节。  ","version":"Next","tagName":"h2"},{"title":"floaty.closeAll()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#floatycloseall","content":" 关闭所有本脚本的悬浮窗。  FloatyWindow  悬浮窗对象，可通过FloatyWindow.{id}获取悬浮窗界面上的元素。例如, 悬浮窗 window 上一个控件的 id 为 aaa, 那么window.aaa即可获取到该控件，类似于 ui。  ","version":"Next","tagName":"h2"},{"title":"window.setAdjustEnabled(enabled)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsetadjustenabledenabled","content":" enabled {boolean} 是否启用悬浮窗调整(大小、位置)  如果 enabled 为 true，则在悬浮窗左上角、右上角显示可供位置、大小调整的标示，就像控制台一样； 如果 enabled 为 false，则隐藏上述标示。  ","version":"Next","tagName":"h2"},{"title":"window.setPosition(x, y)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsetpositionx-y","content":" x {number} xx {number} y  设置悬浮窗位置。  ","version":"Next","tagName":"h2"},{"title":"window.getX()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetx","content":" 返回悬浮窗位置的 X 坐标。  ","version":"Next","tagName":"h2"},{"title":"window.getY()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgety","content":" 返回悬浮窗位置的 Y 坐标。  ","version":"Next","tagName":"h2"},{"title":"window.setSize(width, height)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsetsizewidth-height","content":" width {number} 宽度height {number} 高度  设置悬浮窗宽高。  ","version":"Next","tagName":"h2"},{"title":"window.getWidht()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetwidht","content":" 返回悬浮窗宽度。  ","version":"Next","tagName":"h2"},{"title":"window.getHeight()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetheight","content":" 返回悬浮窗高度。  ","version":"Next","tagName":"h2"},{"title":"window.close()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowclose","content":" 关闭悬浮窗。如果悬浮窗已经是关闭状态，则此函数将不执行任何操作。  被关闭后的悬浮窗不能再显示。  ","version":"Next","tagName":"h2"},{"title":"window.exitOnClose()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowexitonclose","content":" 使悬浮窗被关闭时自动结束脚本运行。  FloatyRawWindow  原始悬浮窗对象，可通过window.{id}获取悬浮窗界面上的元素。例如, 悬浮窗 window 上一个控件的 id 为 aaa, 那么window.aaa即可获取到该控件，类似于 ui。  ","version":"Next","tagName":"h2"},{"title":"window.setTouchable(touchable)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsettouchabletouchable","content":" touchable {Boolean} 是否可触摸  设置悬浮窗是否可触摸，如果为 true, 则悬浮窗将接收到触摸、点击等事件并且无法继续传递到悬浮窗下面；如果为 false, 悬浮窗上的触摸、点击等事件将被直接传递到悬浮窗下面。处于安全考虑，被悬浮窗接收的触摸事情无法再继续传递到下层。  可以用此特性来制作护眼模式脚本。  var w = floaty.rawWindow(&lt;frame gravity=&quot;center&quot; bg=&quot;#44ffcc00&quot; /&gt;); w.setSize(-1, -1); w.setTouchable(false); setTimeout(() =&gt; { w.close(); }, 4000);   ","version":"Next","tagName":"h2"},{"title":"window.setPosition(x, y)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsetpositionx-y-1","content":" x {number} xx {number} y  设置悬浮窗位置。  ","version":"Next","tagName":"h2"},{"title":"window.getX()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetx-1","content":" 返回悬浮窗位置的 X 坐标。  ","version":"Next","tagName":"h2"},{"title":"window.getY()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgety-1","content":" 返回悬浮窗位置的 Y 坐标。  ","version":"Next","tagName":"h2"},{"title":"window.setSize(width, height)​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowsetsizewidth-height-1","content":" width {number} 宽度height {number} 高度  设置悬浮窗宽高。  特别地，如果设置为-1，则为占满全屏；设置为-2 则为根据悬浮窗内容大小而定。例如：  var w = floaty.rawWindow( &lt;frame gravity=&quot;center&quot; bg=&quot;#77ff0000&quot;&gt; &lt;text id=&quot;text&quot;&gt;悬浮文字&lt;/text&gt; &lt;/frame&gt; ); w.setSize(-1, -1); setTimeout(() =&gt; { w.close(); }, 2000);   ","version":"Next","tagName":"h2"},{"title":"window.getWidht()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetwidht-1","content":" 返回悬浮窗宽度。  ","version":"Next","tagName":"h2"},{"title":"window.getHeight()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowgetheight-1","content":" 返回悬浮窗高度。  ","version":"Next","tagName":"h2"},{"title":"window.close()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowclose-1","content":" 关闭悬浮窗。如果悬浮窗已经是关闭状态，则此函数将不执行任何操作。  被关闭后的悬浮窗不能再显示。  ","version":"Next","tagName":"h2"},{"title":"window.exitOnClose()​","type":1,"pageTitle":"Floaty 悬浮窗","url":"/docs/rhino/advanced/floaty#windowexitonclose-1","content":" 使悬浮窗被关闭时自动结束脚本运行。 ","version":"Next","tagName":"h2"},{"title":"OCR 文字识别","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/ocr","content":"","keywords":"","version":"Next"},{"title":"paddle.ocr(img, path)​","type":1,"pageTitle":"OCR 文字识别","url":"/docs/rhino/advanced/ocr#paddleocrimg-path","content":" img {Image} 图片path {String} 自定义模型路径,必须是绝对路径return {Array}  使用自定义模型进行文字识别  // files.path() 将相对路径转为绝对路径 let myModelPath = files.path(&quot;./models&quot;); let result = paddle.ocr(img, myModelPath)   ","version":"Next","tagName":"h2"},{"title":"paddle.ocr(img[, cpuThreadNum=4, useSlim=true])​","type":1,"pageTitle":"OCR 文字识别","url":"/docs/rhino/advanced/ocr#paddleocrimg-cputhreadnum4-useslimtrue","content":" img {Image} 图片cpuThreadNum {Number} 识别使用的 CPU 核心数量useSlim {Boolean} 加载的模型,可选值: true ocr_v2_for_cpu(slim) :快速模型,默认false ocr_v2_for_cpu : 精准模型 return {Array}  高精度识别，返回值包含坐标，置信度  let res = paddle.ocr(img); toastLog(JSON.stringify(res));   返回值示例  [ { &quot;bounds&quot;: { &quot;bottom&quot;: 535, &quot;left&quot;: 348, &quot;right&quot;: 631, &quot;top&quot;: 384 }, &quot;confidence&quot;: 0.9808736, &quot;inferenceTime&quot;: 188.0, &quot;preprocessTime&quot;: 53.0, &quot;text&quot;: &quot;约定&quot;, &quot;words&quot;: &quot;约定&quot; } ]   ","version":"Next","tagName":"h2"},{"title":"paddle.ocrText(img[, cpuThreadNum=4, useSlim=true])​","type":1,"pageTitle":"OCR 文字识别","url":"/docs/rhino/advanced/ocr#paddleocrtextimg-cputhreadnum4-useslimtrue","content":" img {Image} 图片cpuThreadNum {Number} 识别使用的 CPU 核心数量useSlim {Boolean} 加载的模型,可选值: true ocr_v2_for_cpu(slim) :快速模型,默认false ocr_v2_for_cpu : 精准模型 return {Array} 字符串数组  只返回文本识别信息  let res = paddle.ocrText(img); toastLog(&quot;识别信息: &quot; + JSON.stringify(res)); //[&quot;约定&quot;,&quot;最终相遇&quot;]   ","version":"Next","tagName":"h2"},{"title":"paddle.release()​","type":1,"pageTitle":"OCR 文字识别","url":"/docs/rhino/advanced/ocr#paddlerelease","content":" 释放 native 内存，非必要，供万一出现内存泄露时使用  Tessract OCR  6.2.9 新增前往 github 下载完整例子：TessractOCR  Google ML kIT OCR  6.3.4 新增  ","version":"Next","tagName":"h2"},{"title":"gmlkit.ocr(img,Language)​","type":1,"pageTitle":"OCR 文字识别","url":"/docs/rhino/advanced/ocr#gmlkitocrimglanguage","content":" img {Image} 图片Language {String} 识别语言，可选值为： la 拉丁zh 中文sa 梵文ja 日语ko 韩语更多语言 retrun {Object} Json  //识别中文 let result = gmlkit.ocr(img, &quot;zh&quot;); log(result.text)  ","version":"Next","tagName":"h2"},{"title":"Events 事件与监听","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/events","content":"","keywords":"","version":"Next"},{"title":"events.emitter()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsemitter","content":" 返回一个新的EventEmitter。这个 EventEmitter 没有内置任何事件。  ","version":"Next","tagName":"h2"},{"title":"events.observeKey()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsobservekey","content":" 启用按键监听，例如音量键、Home 键。按键监听使用无障碍服务实现，如果无障碍服务未启用会抛出异常并提示开启。  只有这个函数成功执行后, onKeyDown, onKeyUp等按键事件的监听才有效。  该函数在安卓 4.3 以上才能使用。  ","version":"Next","tagName":"h2"},{"title":"events.onKeyDown(keyName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsonkeydownkeyname-listener","content":" keyName {string} 要监听的按键名称listener {Function} 按键监听器。参数为一个KeyEvent。  注册一个按键监听函数，当有 keyName 对应的按键被按下会调用该函数。可用的按键名称参见Keys。  例如:  //启用按键监听 events.observeKey(); //监听音量上键按下 events.onKeyDown(&quot;volume_up&quot;, function (event) { toast(&quot;音量上键被按下了&quot;); }); //监听菜单键按下 events.onKeyDown(&quot;menu&quot;, function (event) { toast(&quot;菜单键被按下了&quot;); exit(); });   ","version":"Next","tagName":"h2"},{"title":"events.onKeyUp(keyName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsonkeyupkeyname-listener","content":" keyName {string} 要监听的按键名称listener {Function} 按键监听器。参数为一个KeyEvent。  注册一个按键监听函数，当有 keyName 对应的按键弹起会调用该函数。可用的按键名称参见Keys。  一次完整的按键动作包括了按键按下和弹起。按下事件会在手指按下一个按键的&quot;瞬间&quot;触发, 弹起事件则在手指放开这个按键时触发。  例如:  //启用按键监听 events.observeKey(); //监听音量下键弹起 events.onKeyDown(&quot;volume_down&quot;, function (event) { toast(&quot;音量下键弹起&quot;); }); //监听Home键弹起 events.onKeyDown(&quot;home&quot;, function (event) { toast(&quot;Home键弹起&quot;); exit(); });   ","version":"Next","tagName":"h2"},{"title":"events.onceKeyDown(keyName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsoncekeydownkeyname-listener","content":" keyName {string} 要监听的按键名称listener {Function} 按键监听器。参数为一个KeyEvent  注册一个按键监听函数，当有 keyName 对应的按键被按下时会调用该函数，之后会注销该按键监听器。  也就是 listener 只有在 onceKeyDown 调用后的第一次按键事件被调用一次。  ","version":"Next","tagName":"h2"},{"title":"events.onceKeyUp(keyName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsoncekeyupkeyname-listener","content":" keyName {string} 要监听的按键名称listener {Function} 按键监听器。参数为一个KeyEvent  注册一个按键监听函数，当有 keyName 对应的按键弹起时会调用该函数，之后会注销该按键监听器。  也就是 listener 只有在 onceKeyUp 调用后的第一次按键事件被调用一次。  ","version":"Next","tagName":"h2"},{"title":"events.removeAllKeyDownListeners(keyName)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsremoveallkeydownlistenerskeyname","content":" keyName {string} 按键名称  删除该按键的 KeyDown(按下)事件的所有监听。  ","version":"Next","tagName":"h2"},{"title":"events.removeAllKeyUpListeners(keyName)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsremoveallkeyuplistenerskeyname","content":" keyName {string} 按键名称  删除该按键的 KeyUp(弹起)事件的所有监听。  ","version":"Next","tagName":"h2"},{"title":"events.setKeyInterceptionEnabled([key, ]enabled)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventssetkeyinterceptionenabledkey-enabled","content":" enabled {boolean}key {string} 要屏蔽的按键  设置按键屏蔽是否启用。所谓按键屏蔽指的是，屏蔽原有按键的功能，例如使得音量键不再能调节音量，但此时仍然能通过按键事件监听按键。  如果不加参数 key 则会屏蔽所有按键。  例如，调用events.setKeyInterceptionEnabled(true)会使系统的音量、Home、返回等键不再具有调节音量、回到主页、返回的作用，但此时仍然能通过按键事件监听按键。  该函数通常于按键监听结合，例如想监听音量键并使音量键按下时不弹出音量调节框则为：  events.setKeyInterceptionEnabled(&quot;volume_up&quot;, true); events.observeKey(); events.onKeyDown(&quot;volume_up&quot;, () =&gt; { log(&quot;音量上键被按下&quot;); });   只要有一个脚本屏蔽了某个按键，该按键便会被屏蔽；当脚本退出时，会自动解除所有按键屏蔽。  ","version":"Next","tagName":"h2"},{"title":"events.observeTouch()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsobservetouch","content":" 启用屏幕触摸监听。（需要 root 权限）  只有这个函数被成功执行后, 触摸事件的监听才有效。  没有 root 权限调用该函数则什么也不会发生。  ","version":"Next","tagName":"h2"},{"title":"events.setTouchEventTimeout(timeout)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventssettoucheventtimeouttimeout","content":" timeout {number} 两个触摸事件的最小间隔。单位毫秒。默认为 10 毫秒。如果 number 小于 0，视为 0 处理。  设置两个触摸事件分发的最小时间间隔。  例如间隔为 10 毫秒的话，前一个触摸事件发生并被注册的监听器处理后，至少要过 10 毫秒才能分发和处理下一个触摸事件，这 10 毫秒之间的触摸将会被忽略。  建议在满足需要的情况下尽量提高这个间隔。一个简单滑动动作可能会连续触发上百个触摸事件，如果 timeout 设置过低可能造成事件拥堵。强烈建议不要设置 timeout 为 0。  ","version":"Next","tagName":"h2"},{"title":"events.getTouchEventTimeout()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsgettoucheventtimeout","content":" 返回触摸事件的最小时间间隔。  ","version":"Next","tagName":"h2"},{"title":"events.onTouch(listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsontouchlistener","content":" listener {Function} 参数为Point的函数  注册一个触摸监听函数。相当于on(&quot;touch&quot;, listener)。  例如:  //启用触摸监听 events.observeTouch(); //注册触摸监听器 events.onTouch(function (p) { //触摸事件发生时, 打印出触摸的点的坐标 log(p.x + &quot;, &quot; + p.y); });   ","version":"Next","tagName":"h2"},{"title":"events.removeAllTouchListeners()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsremovealltouchlisteners","content":" 删除所有事件监听函数。  ","version":"Next","tagName":"h2"},{"title":"事件: 'key'​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-key","content":" keyCode {number} 键值event {KeyEvent} 事件  当有按键被按下或弹起时会触发该事件。 例如：  auto(); events.observeKey(); events.on(&quot;key&quot;, function (keyCode, event) { //处理按键事件 });   其中监听器的参数 KeyCode 包括：  keys.home 主页键keys.back 返回键keys.menu 菜单键keys.volume_up 音量上键keys.volume_down 音量下键  例如：  auto(); events.observeKey(); events.on(&quot;key&quot;, function (keyCode, event) { if (keyCode == keys.menu &amp;&amp; event.getAction() == event.ACTION_UP) { toast(&quot;菜单键按下&quot;); } });   ","version":"Next","tagName":"h2"},{"title":"事件: 'key_down'​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-key_down","content":" keyCode {number} 键值event {KeyEvent} 事件  当有按键被按下时会触发该事件。  auto(); events.observeKey(); events.on(&quot;key_down&quot;, function (keyCode, event) { //处理按键按下事件 });   ","version":"Next","tagName":"h2"},{"title":"事件: 'key_up'​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-key_up","content":" keyCode {number} 键值event {KeyEvent} 事件  当有按键弹起时会触发该事件。  auto(); events.observeKey(); events.on(&quot;key_up&quot;, function (keyCode, event) { //处理按键弹起事件 });   ","version":"Next","tagName":"h2"},{"title":"事件: 'exit`​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-exit","content":" 当脚本正常或者异常退出时会触发该事件。事件处理中如果有异常抛出，则立即中止 exit 事件的处理（即使 exit 事件有多个处理函数）并在控制台和日志中打印该异常。  一个脚本停止运行时，会关闭该脚本的所有悬浮窗，触发 exit 事件，之后再回收资源。如果 exit 事件的处理中有死循环，则后续资源无法得到及时回收。 此时脚本会停留在任务列表，如果在任务列表中关闭，则会强制结束 exit 事件的处理并回收后续资源。  log(&quot;开始运行&quot;); events.on(&quot;exit&quot;, function () { log(&quot;结束运行&quot;); }); log(&quot;即将结束运行&quot;);   ","version":"Next","tagName":"h2"},{"title":"events.observeNotification()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsobservenotification","content":" 开启通知监听。例如 QQ 消息、微信消息、推送等通知。  通知监听依赖于通知服务，如果通知服务没有运行，会抛出异常并跳转到通知权限开启界面。（有时即使通知权限已经开启通知服务也没有运行，这时需要关闭权限再重新开启一次）  例如：  events.observeNotification(); events.onNotification(function (notification) { log(notification.getText()); });   ","version":"Next","tagName":"h2"},{"title":"events.observeToast()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventsobservetoast","content":" 开启 Toast 监听。  Toast 监听依赖于无障碍服务，因此此函数会确保无障碍服务运行。  ","version":"Next","tagName":"h2"},{"title":"事件: 'toast'​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-toast","content":" toast {Object} getText() 获取 Toast 的文本内容getPackageName() 获取发出 Toast 的应用包名  当有应用发出 toast(气泡消息)时会触发该事件。但 Auto.js 软件本身的 toast 除外。  例如，要记录发出所有 toast 的应用：  events.observeToast(); events.onToast(function (toast) { log(&quot;Toast内容: &quot; + toast.getText() + &quot; 包名: &quot; + toast.getPackageName()); });   ","version":"Next","tagName":"h2"},{"title":"事件: 'notification'​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#事件-notification","content":" notification Notification 通知对象  当有应用发出通知时会触发该事件，参数为Notification。  例如：  events.observeNotification(); events.on(&quot;notification&quot;, function (n) { log( &quot;收到新通知:\\n 标题: %s, 内容: %s, \\n包名: %s&quot;, n.getTitle(), n.getText(), n.getPackageName() ); });   Notification  通知对象，可以获取通知详情，包括通知标题、内容、发出通知的包名、时间等，也可以对通知进行操作，比如点击、删除。  ","version":"Next","tagName":"h2"},{"title":"Notification.number​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationnumber","content":" {number}  通知数量。例如 QQ 连续收到两条消息时 number 为 2。  ","version":"Next","tagName":"h2"},{"title":"Notification.when​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationwhen","content":" {number}  通知发出时间的时间戳，可以用于构造Date对象。例如：  events.observeNotification(); events.on(&quot;notification&quot;, function (n) { log(&quot;通知时间为}&quot; + new Date(n.when)); });   ","version":"Next","tagName":"h2"},{"title":"Notification.getPackageName()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationgetpackagename","content":" 返回 {string}  获取发出通知的应用包名。  ","version":"Next","tagName":"h2"},{"title":"Notification.getTitle()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationgettitle","content":" 返回 {string}  获取通知的标题。  ","version":"Next","tagName":"h2"},{"title":"Notification.getText()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationgettext","content":" 返回 {string}  获取通知的内容。  ","version":"Next","tagName":"h2"},{"title":"Notification.click()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationclick","content":" 点击该通知。例如对于一条 QQ 消息，点击会进入具体的聊天界面。  ","version":"Next","tagName":"h2"},{"title":"Notification.delete()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#notificationdelete","content":" 删除该通知。该通知将从通知栏中消失。  KeyEvent  稳定性: 稳定  ","version":"Next","tagName":"h2"},{"title":"KeyEvent.getAction()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#keyeventgetaction","content":" 返回事件的动作。包括：  KeyEvent.ACTION_DOWN 按下事件KeyEvent.ACTION_UP 弹起事件  ","version":"Next","tagName":"h2"},{"title":"KeyEvent.getKeyCode()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#keyeventgetkeycode","content":" 返回按键的键值。包括：  KeyEvent.KEYCODE_HOME 主页键KeyEvent.KEYCODE_BACK 返回键KeyEvent.KEYCODE_MENU 菜单键KeyEvent.KEYCODE_VOLUME_UP 音量上键KeyEvent.KEYCODE_VOLUME_DOWN 音量下键  ","version":"Next","tagName":"h2"},{"title":"KeyEvent.getEventTime()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#keyeventgeteventtime","content":" 返回 {number}  返回事件发生的时间戳。  ","version":"Next","tagName":"h2"},{"title":"KeyEvent.getDownTime()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#keyeventgetdowntime","content":" 返回最近一次按下事件的时间戳。如果本身是按下事件，则与getEventTime()相同。  ","version":"Next","tagName":"h2"},{"title":"KeyEvent.keyCodeToString(keyCode)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#keyeventkeycodetostringkeycode","content":" 把键值转换为字符串。例如 KEYCODE_HOME 转换为&quot;KEYCODE_HOME&quot;。  keys  稳定性: 稳定  按键事件中所有可用的按键名称为：  volume_up 音量上键volume_down 音量下键home 主屏幕键back 返回键menu 菜单键  EventEmitter  稳定性: 稳定  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.defaultMaxListeners​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterdefaultmaxlisteners","content":" 每个事件默认可以注册最多 10 个监听器。 单个 EventEmitter 实例的限制可以使用 emitter.setMaxListeners(n) 方法改变。 所有 EventEmitter 实例的默认值可以使用 EventEmitter.defaultMaxListeners 属性改变。  设置 EventEmitter.defaultMaxListeners 要谨慎，因为会影响所有 EventEmitter 实例，包括之前创建的。 因而，调用 emitter.setMaxListeners(n) 优先于 EventEmitter.defaultMaxListeners。  注意，与 Node.js 不同，这是一个硬性限制。 EventEmitter 实例不允许添加更多的监听器，监听器超过最大数量时会抛出 TooManyListenersException。  emitter.setMaxListeners(emitter.getMaxListeners() + 1); emitter.once(&quot;event&quot;, () =&gt; { // 做些操作 emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0)); });   ","version":"Next","tagName":"h2"},{"title":"EventEmitter.addListener(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitteraddlistenereventname-listener","content":" eventName {any}listener {Function}  emitter.on(eventName, listener) 的别名。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.emit(eventName[, ...args])​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitteremiteventname-args","content":" eventName {any}args {any}  按监听器的注册顺序，同步地调用每个注册到名为 eventName 事件的监听器，并传入提供的参数。  如果事件有监听器，则返回 true ，否则返回 false。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.eventNames()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemittereventnames","content":" 返回一个列出触发器已注册监听器的事件的数组。 数组中的值为字符串或符号。  const myEE = events.emitter(); myEE.on(&quot;foo&quot;, () =&gt; {}); myEE.on(&quot;bar&quot;, () =&gt; {}); const sym = Symbol(&quot;symbol&quot;); myEE.on(sym, () =&gt; {}); console.log(myEE.eventNames()); // 打印: [ 'foo', 'bar', Symbol(symbol) ]   ","version":"Next","tagName":"h2"},{"title":"EventEmitter.getMaxListeners()​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemittergetmaxlisteners","content":" 返回 EventEmitter 当前的最大监听器限制值，该值可以通过 emitter.setMaxListeners(n) 设置或默认为 EventEmitter.defaultMaxListeners。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.listenerCount(eventName)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterlistenercounteventname","content":" eventName {string} 正在被监听的事件名  返回正在监听名为 eventName 的事件的监听器的数量。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.listeners(eventName)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterlistenerseventname","content":" eventName {string}  返回名为 eventName 的事件的监听器数组的副本。  server.on(&quot;connection&quot;, (stream) =&gt; { console.log(&quot;someone connected!&quot;); }); console.log(util.inspect(server.listeners(&quot;connection&quot;))); // 打印: [ [Function] ]   ","version":"Next","tagName":"h2"},{"title":"EventEmitter.on(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitteroneventname-listener","content":" eventName {any} 事件名listener {Function} 回调函数  添加 listener 函数到名为 eventName 的事件的监听器数组的末尾。 不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。  server.on(&quot;connection&quot;, (stream) =&gt; { console.log(&quot;有连接！&quot;); });   返回一个 EventEmitter 引用，可以链式调用。  默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。  const myEE = events.emitter(); myEE.on(&quot;foo&quot;, () =&gt; console.log(&quot;a&quot;)); myEE.prependListener(&quot;foo&quot;, () =&gt; console.log(&quot;b&quot;)); myEE.emit(&quot;foo&quot;); // 打印: // b // a   ","version":"Next","tagName":"h2"},{"title":"EventEmitter.once(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitteronceeventname-listener","content":" eventName {any} 事件名listener {Function} 回调函数  添加一个单次 listener 函数到名为 eventName 的事件。 下次触发 eventName 事件时，监听器会被移除，然后调用。  server.once(&quot;connection&quot;, (stream) =&gt; { console.log(&quot;首次调用！&quot;); });   返回一个 EventEmitter 引用，可以链式调用。  默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。  const myEE = events.emitter(); myEE.once(&quot;foo&quot;, () =&gt; console.log(&quot;a&quot;)); myEE.prependOnceListener(&quot;foo&quot;, () =&gt; console.log(&quot;b&quot;)); myEE.emit(&quot;foo&quot;); // 打印: // b // a   ","version":"Next","tagName":"h2"},{"title":"EventEmitter.prependListener(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterprependlistenereventname-listener","content":" eventName {any} 事件名listener {Function} 回调函数  添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。  server.prependListener(&quot;connection&quot;, (stream) =&gt; { console.log(&quot;有连接！&quot;); });   返回一个 EventEmitter 引用，可以链式调用。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.prependOnceListener(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterprependoncelistenereventname-listener","content":" eventName {any} 事件名listener {Function} 回调函数  添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 下次触发 eventName 事件时，监听器会被移除，然后调用。  server.prependOnceListener(&quot;connection&quot;, (stream) =&gt; { console.log(&quot;首次调用！&quot;); });   返回一个 EventEmitter 引用，可以链式调用。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.removeAllListeners([eventName])​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterremovealllistenerseventname","content":" eventName {any}  移除全部或指定 eventName 的监听器。  注意，在代码中移除其他地方添加的监听器是一个不好的做法，尤其是当 EventEmitter 实例是其他组件或模块创建的。  返回一个 EventEmitter 引用，可以链式调用。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.removeListener(eventName, listener)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemitterremovelistenereventname-listener","content":" eventName {any}listener {Function}  从名为 eventName 的事件的监听器数组中移除指定的 listener。  const callback = (stream) =&gt; { console.log(&quot;有连接！&quot;); }; server.on(&quot;connection&quot;, callback); // ... server.removeListener(&quot;connection&quot;, callback);   removeListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。  注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。 这意味着，在事件触发后、最后一个监听器完成执行前，任何 removeListener() 或 removeAllListeners() 调用都不会从 emit() 中移除它们。 随后的事件会像预期的那样发生。  const myEmitter = events.emitter(); const callbackA = () =&gt; { console.log(&quot;A&quot;); myEmitter.removeListener(&quot;event&quot;, callbackB); }; const callbackB = () =&gt; { console.log(&quot;B&quot;); }; myEmitter.on(&quot;event&quot;, callbackA); myEmitter.on(&quot;event&quot;, callbackB); // callbackA 移除了监听器 callbackB，但它依然会被调用。 // 触发是内部的监听器数组为 [callbackA, callbackB] myEmitter.emit(&quot;event&quot;); // 打印: // A // B // callbackB 被移除了。 // 内部监听器数组为 [callbackA] myEmitter.emit(&quot;event&quot;); // 打印: // A   因为监听器是使用内部数组进行管理的，所以调用它会改变在监听器被移除后注册的任何监听器的位置索引。 虽然这不会影响监听器的调用顺序，但意味着由 emitter.listeners() 方法返回的监听器数组副本需要被重新创建。  返回一个 EventEmitter 引用，可以链式调用。  ","version":"Next","tagName":"h2"},{"title":"EventEmitter.setMaxListeners(n)​","type":1,"pageTitle":"Events 事件与监听","url":"/docs/rhino/advanced/events#eventemittersetmaxlistenersn","content":" n {number}  默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 此限制有助于寻找内存泄露。 但是，并不是所有的事件都要被限为 10 个。 emitter.setMaxListeners() 方法允许修改指定的 EventEmitter 实例的限制。 值设为 Infinity（或 0）表明不限制监听器的数量。  返回一个 EventEmitter 引用，可以链式调用。  events.broadcast  脚本间广播  脚本间通信除了使用 engines 模块提供的ScriptEngine.emit()方法以外，也可以使用 events 模块提供的 broadcast 广播。  events.broadcast 本身是一个 EventEmitter，但它的事件是在脚本间共享的，所有脚本都能发送和监听这些事件；事件处理会在脚本主线程执行（后续可能加入函数onThisThread(eventName, ...args)来提供在其他线程执行的能力）。  例如在一个脚本发送一个广播 hello:  events.broadcast.emit(&quot;hello&quot;, &quot;小明&quot;);   在其他脚本中监听并处理：  events.broadcast.on(&quot;hello&quot;, function (name) { toast(&quot;你好, &quot; + name); }); //保持脚本运行 setInterval(() =&gt; {}, 1000);  ","version":"Next","tagName":"h2"},{"title":"module (模块)","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/modules","content":"","keywords":"","version":"Next"},{"title":"require函数​","type":1,"pageTitle":"module (模块)","url":"/docs/rhino/advanced/modules#require函数","content":" require函数用于加载模块，返回模块中module.exports的值。  该函数有一个参数用于查找模块位置，可以是相对路径(以'./'或'../'开头)，也可以是绝对路径(以'/'开头)， 还可以是以'http://'或'https://'开头的uri地址，用于加载网络模块，出于安全和加载速度考虑，此方式不建议使用。  当没有以这些开头时，将会视为内置模块，从内置模块目录依次查找，由于历史原因，在脚本主文件中仍然会先尝试解析成相对路径解析，若解析成功则会忽略内置模块直接加载，强烈不建议使用此方式加载相对路径的模块，该方式在模块中不可用并且被弃用，在未来版本可能会被移除。  和nodejs类似，当传入的是一个目录，则会尝试加载该目录下的index.js文件，若存在package.json文件则会先解析该文件中的main字段，若main字段指向一个有效的模块将直接加载该模块。  ","version":"Next","tagName":"h3"},{"title":"模块变量​","type":1,"pageTitle":"module (模块)","url":"/docs/rhino/advanced/modules#模块变量","content":" 这些变量只存在于模块中，并非全局变量  module 储存当前模块一些信息的对象，其中最重要的是module.exports表示该模块导出的对象 exports 相当于预先运行了var exports = module.exports __dirname 当前模块的目录名 __filename 当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。 ","version":"Next","tagName":"h3"},{"title":"Sensors 传感器","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/sensors","content":"","keywords":"","version":"Next"},{"title":"sensors.register(sensorName[, delay])​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#sensorsregistersensorname-delay","content":" sensorName {string} 传感器名称，常用的传感器名称如上面所述delay {number} 传感器数据更新频率，可选，默认为sensors.delay.normal。可用的值如下： sensors.delay.normal 正常频率sensors.delay.ui 适合于用户界面的更新频率sensors.delay.game 适合于游戏的更新频率sensors.delay.fastest 最快的更新频率】 返回 SensorEventEmiiter  注册一个传感器监听并返回SensorEventEmitter。  例如:  console.show(); //注册传感器监听 var sensor = sensors.register(&quot;gravity&quot;); if (sensor == null) { toast(&quot;不支持重力传感器&quot;); exit(); } //监听数据 sensor.on(&quot;change&quot;, (gx, gy, gz) =&gt; { log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz); });   可以通过 delay 参数来指定传感器数据的更新频率，例如：  var sensor = sensors.register(&quot;gravity&quot;, sensors.delay.game);   另外，如果不支持sensorName所指定的传感器，那么该函数将返回null；但如果sensors.ignoresUnsupportedSensor的值被设置为true, 则该函数会返回一个不会分发任何传感器事件的SensorEventEmitter。  例如:  sensors.ignoresUnsupportedSensor = true; //无需null判断 sensors.register(&quot;gravity&quot;).on(&quot;change&quot;, (gx, gy, gz) =&gt; { log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz); });   更多信息，参见SensorEventEmitter和sensors.ignoresUnsupportedSensor。  ","version":"Next","tagName":"h2"},{"title":"sensors.unregister(emitter)​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#sensorsunregisteremitter","content":" emiiter SensorEventEmitter  注销该传感器监听器。被注销的监听器将不再能监听传感器数据。  //注册一个传感器监听器 var sensor = sensors.register(&quot;gravity&quot;); if (sensor == null) { exit(); } //2秒后注销该监听器 setTimeout(() =&gt; { sensors.unregister(sensor); }, 2000);   ","version":"Next","tagName":"h2"},{"title":"sensors.unregisterAll()​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#sensorsunregisterall","content":" 注销所有传感器监听器。  ","version":"Next","tagName":"h2"},{"title":"sensors.ignoresUnsupportedSensor​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#sensorsignoresunsupportedsensor","content":" {boolean}  表示是否忽略不支持的传感器。如果该值被设置为true，则函数sensors.register()即使对不支持的传感器也会返回一个无任何数据的虚拟传感器监听，也就是sensors.register()不会返回null从而避免非空判断，并且此时会触发sensors的&quot;unsupported_sensor&quot;事件。  //忽略不支持的传感器 sensors.ignoresUnsupportedSensor = true; //监听有不支持的传感器时的事件 sensors.on(&quot;unsupported_sensor&quot;, function (sensorName) { toastLog(&quot;不支持的传感器: &quot; + sensorName); }); //随便注册一个不存在的传感器。 log(sensors.register(&quot;aaabbb&quot;));   ","version":"Next","tagName":"h2"},{"title":"事件: 'unsupported_sensor'​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#事件-unsupported_sensor","content":" sensorName {string} 不支持的传感器名称  当sensors.ignoresUnsupportedSensor被设置为true并且有不支持的传感器被注册时触发该事件。事件参数的传感器名称。  SensorEventEmitter  注册传感器返回的对象，其本身是一个 EventEmmiter，用于监听传感器事件。  ","version":"Next","tagName":"h2"},{"title":"事件: 'change'​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#事件-change","content":" ..args {Any} 传感器参数  当传感器数据改变时触发该事件；该事件触发的最高频繁由sensors.register()指定的 delay 参数决定。  事件参数根据传感器类型不同而不同，具体参见本章最前面的列表。  一个监听光线传感器和加速度传感器并且每 0.5 秒获取一个数据并最终写入一个 csv 表格文件的例子如下：  //csv文件路径 cosnt csvPath = &quot;/sdcard/data.csv&quot;; //记录光线传感器的数据 var light = 0; //记录加速度传感器的数据 var ax = 0; var ay = 0; var az = 0; //监听光线传感器 sensors.register(&quot;light&quot;, sensors.delay.fastest) .on(&quot;change&quot;, l =&gt; { light = l; }); //监听加速度传感器 sensors.register(&quot;accelerometer&quot;, sensors.delay.fastest) .on(&quot;change&quot;, (ax0, ay0, az0) =&gt; { ax = ax0; ay = ay0; az = az0; }); var file = open(csvPath, &quot;w&quot;); //写csv表格头 file.writeline(&quot;light,ax,ay,az&quot;) //每0.5秒获取一次数据并写入文件 setInterval(()=&gt;{ file.writeline(util.format(&quot;%d,%d,%d,%d&quot;, light, ax, ay, az)); }, 500); //10秒后退出并打开文件 setTimeout(()=&gt;{ file.close(); sensors.unregsiterAll(); app.viewFile(csvPath); }, 10 * 1000);   ","version":"Next","tagName":"h2"},{"title":"事件: 'accuracy_change'​","type":1,"pageTitle":"Sensors 传感器","url":"/docs/rhino/advanced/sensors#事件-accuracy_change","content":" accuracy {number} 表示传感器精度。为以下值之一: -1 传感器未连接0 传感器不可读1 低精度2 中精度3 高精度  当传感器精度改变时会触发的事件。比较少用。 ","version":"Next","tagName":"h2"},{"title":"Images 图片与颜色","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/images","content":"","keywords":"","version":"Next"},{"title":"colors.toString(color)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorstostringcolor","content":" color {number} 整数 RGB 颜色值返回 {string}  返回颜色值的字符串，格式为 &quot;#AARRGGBB&quot;。  ","version":"Next","tagName":"h2"},{"title":"colors.red(color)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsredcolor","content":" color {number} | {string} 颜色值返回 {number}  返回颜色 color 的 R 通道的值，范围 0~255.  ","version":"Next","tagName":"h2"},{"title":"colors.green(color)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsgreencolor","content":" color {number} | {string} 颜色值返回 {number}  返回颜色 color 的 G 通道的值，范围 0~255.  ","version":"Next","tagName":"h2"},{"title":"colors.blue(color)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsbluecolor","content":" color {number} | {string} 颜色值返回 {number}  返回颜色 color 的 B 通道的值，范围 0~255.  ","version":"Next","tagName":"h2"},{"title":"colors.alpha(color)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsalphacolor","content":" color {number} | {string} 颜色值返回 {number}  返回颜色 color 的 Alpha 通道的值，范围 0~255.  ","version":"Next","tagName":"h2"},{"title":"colors.rgb(red, green, blue)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsrgbred-green-blue","content":" red {number} 颜色的 R 通道的值blue {number} 颜色的 G 通道的值green {number} 颜色的 B 通道的值返回 {number}  返回这些颜色通道构成的整数颜色值。Alpha 通道将是 255（不透明）。  ","version":"Next","tagName":"h2"},{"title":"colors.argb(alpha, red, green, blue)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsargbalpha-red-green-blue","content":" alpha {number} 颜色的 Alpha 通道的值red {number} 颜色的 R 通道的值green {number} 颜色的 G 通道的值blue {number} 颜色的 B 通道的值返回 {number}  返回这些颜色通道构成的整数颜色值。  ","version":"Next","tagName":"h2"},{"title":"colors.parseColor(colorStr)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsparsecolorcolorstr","content":" colorStr {string} 表示颜色的字符串，例如&quot;#112233&quot;返回 {number}  返回颜色的整数值。  ","version":"Next","tagName":"h2"},{"title":"colors.isSimilar(color2, color2[, threshold, algorithm])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsissimilarcolor2-color2-threshold-algorithm","content":" color1 {number} | {string} 颜色值 1color1 {number} | {string} 颜色值 2threshold {number} 颜色相似度临界值，默认为 4。取值范围为 0~255。这个值越大表示允许的相似程度越小，如果这个值为 0，则两个颜色相等时该函数才会返回 true。algorithm {string} 颜色匹配算法，默认为&quot;diff&quot;, 包括: &quot;diff&quot;: 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。&quot;rgb&quot;: rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。&quot;rgb+&quot;: 加权 rgb 欧拉距离匹配(LAB Delta E)。&quot;hs&quot;: hs 欧拉距离匹配。hs 为 HSV 空间的色调值。 返回 {Boolean}  返回两个颜色是否相似。  ","version":"Next","tagName":"h2"},{"title":"colors.equals(color1, color2)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsequalscolor1-color2","content":" color1 {number} | {string} 颜色值 1color1 {number} | {string} 颜色值 2返回 {Boolean}  返回两个颜色是否相等。*注意该函数会忽略 Alpha 通道的值进行比较。  log(colors.equals(&quot;#112233&quot;, &quot;#112234&quot;)); log(colors.equals(0xff112233, 0xff223344));   ","version":"Next","tagName":"h2"},{"title":"colors.BLACK​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsblack","content":" 黑色，颜色值 #FF000000  ","version":"Next","tagName":"h2"},{"title":"colors.DKGRAY​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsdkgray","content":" 深灰色，颜色值 #FF444444  ","version":"Next","tagName":"h2"},{"title":"colors.GRAY​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsgray","content":" 灰色，颜色值 #FF888888  ","version":"Next","tagName":"h2"},{"title":"colors.LTGRAY​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsltgray","content":" 亮灰色，颜色值 #FFCCCCCC  ","version":"Next","tagName":"h2"},{"title":"colors.WHITE​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorswhite","content":" 白色，颜色值 #FFFFFFFF  ","version":"Next","tagName":"h2"},{"title":"colors.RED​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsred","content":" 红色，颜色值 #FFFF0000  ","version":"Next","tagName":"h2"},{"title":"colors.GREEN​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsgreen","content":" 绿色，颜色值 #FF00FF00  ","version":"Next","tagName":"h2"},{"title":"colors.BLUE​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsblue","content":" 蓝色，颜色值 #FF0000FF  ","version":"Next","tagName":"h2"},{"title":"colors.YELLOW​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsyellow","content":" 黄色，颜色值 #FFFFFF00  ","version":"Next","tagName":"h2"},{"title":"colors.CYAN​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorscyan","content":" 青色，颜色值 #FF00FFFF  ","version":"Next","tagName":"h2"},{"title":"colors.MAGENTA​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorsmagenta","content":" 品红色，颜色值 #FFFF00FF  ","version":"Next","tagName":"h2"},{"title":"colors.TRANSPARENT​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#colorstransparent","content":" 透明，颜色值 #00000000  Images  稳定性: 稳定  images 模块提供了一些手机设备中常见的图片处理函数，包括截图、读写图片、图片剪裁、旋转、二值化、找色找图等。  该模块分为两个部分，找图找色部分和图片处理部分。  需要注意的是，image 对象创建后尽量在不使用时进行回收，同时避免循环创建大量图片。因为图片是一种占用内存比较大的资源，尽管 Auto.js 通过各种方式（比如图片缓存机制、垃圾回收时回收图片、脚本结束时回收所有图片）尽量降低图片资源的泄漏和内存占用，但是糟糕的代码仍然可以占用大量内存。  Image 对象通过调用recycle()函数来回收。例如：  // 读取图片 var img = images.read(&quot;./1.png&quot;); //对图片进行操作 ... // 回收图片 img.recycle();   例外的是，caputerScreen()返回的图片不需要回收。  ","version":"Next","tagName":"h2"},{"title":"图片处理​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#图片处理","content":" ","version":"Next","tagName":"h2"},{"title":"images.read(path)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesreadpath","content":" path {string} 图片路径  读取在路径 path 的图片文件并返回一个 Image 对象。如果文件不存在或者文件无法解码则返回 null。  ","version":"Next","tagName":"h2"},{"title":"images.load(url)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesloadurl","content":" url {string} 图片 URL 地址  加载在地址 URL 的网络图片并返回一个 Image 对象。如果地址不存在或者图片无法解码则返回 null。  ","version":"Next","tagName":"h2"},{"title":"images.copy(img)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagescopyimg","content":" img {Image} 图片返回 {Image}  复制一张图片并返回新的副本。该函数会完全复制 img 对象的数据。  ","version":"Next","tagName":"h2"},{"title":"images.save(image, path[, format = \"png\", quality = 100])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagessaveimage-path-format--png-quality--100","content":" image {Image} 图片path {string} 路径format {string} 图片格式，可选的值为: pngjpeg/jpgwebp quality {number} 图片质量，为 0~100 的整数值  把图片 image 以 PNG 格式保存到 path 中。如果文件不存在会被创建；文件存在会被覆盖。  //把图片压缩为原来的一半质量并保存 var img = images.read(&quot;/sdcard/1.png&quot;); images.save(img, &quot;/sdcard/1.jpg&quot;, &quot;jpg&quot;, 50); app.viewFile(&quot;/sdcard/1.jpg&quot;);   ","version":"Next","tagName":"h2"},{"title":"images.fromBase64(base64)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfrombase64base64","content":" base64 {string} 图片的 Base64 数据返回 {Image}  解码 Base64 数据并返回解码后的图片 Image 对象。如果 base64 无法解码则返回null。  ","version":"Next","tagName":"h2"},{"title":"images.toBase64(img[, format = \"png\", quality = 100])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagestobase64img-format--png-quality--100","content":" image {image} 图片format {string} 图片格式，可选的值为: pngjpeg/jpgwebp quality {number} 图片质量，为 0~100 的整数值返回 {string}  把图片编码为 base64 数据并返回。  ","version":"Next","tagName":"h2"},{"title":"images.fromBytes(bytes)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfrombytesbytes","content":" bytes {byte[]} 字节数组  解码字节数组 bytes 并返回解码后的图片 Image 对象。如果 bytes 无法解码则返回null。  ","version":"Next","tagName":"h2"},{"title":"images.toBytes(img[, format = \"png\", quality = 100])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagestobytesimg-format--png-quality--100","content":" image {image} 图片format {string} 图片格式，可选的值为: pngjpeg/jpgwebp quality {number} 图片质量，为 0~100 的整数值返回 {byte[]}  把图片编码为字节数组并返回。  ","version":"Next","tagName":"h2"},{"title":"images.clip(img, x, y, w, h)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesclipimg-x-y-w-h","content":" img {Image} 图片x {number} 剪切区域的左上角横坐标y {number} 剪切区域的左上角纵坐标w {number} 剪切区域的宽度h {number} 剪切区域的高度返回 {Image}  从图片 img 的位置(x, y)处剪切大小为 w * h 的区域，并返回该剪切区域的新图片。  var src = images.read(&quot;/sdcard/1.png&quot;); var clip = images.clip(src, 100, 100, 400, 400); images.save(clip, &quot;/sdcard/clip.png&quot;);   ","version":"Next","tagName":"h2"},{"title":"images.resize(img, size[, interpolation])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesresizeimg-size-interpolation","content":" [v4.1.0 新增]  img {Image} 图片 size {Array} 两个元素的数组[w, h]，分别表示宽度和高度；如果只有一个元素，则宽度和高度相等 interpolation {string} 插值方法，可选，默认为&quot;LINEAR&quot;（线性插值），可选的值有： NEAREST 最近邻插值LINEAR 线性插值（默认）AREA 区域插值CUBIC 三次样条插值LANCZOS4 Lanczos 插值 参见InterpolationFlags 返回 {Image}  调整图片大小，并返回调整后的图片。例如把图片放缩为 200*300：images.resize(img, [200, 300])。  参见Imgproc.resize。  ","version":"Next","tagName":"h2"},{"title":"images.scale(img, fx, fy[, interpolation])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesscaleimg-fx-fy-interpolation","content":" [v4.1.0 新增]  img {Image} 图片 fx {number} 宽度放缩倍数 fy {number} 高度放缩倍数 interpolation {string} 插值方法，可选，默认为&quot;LINEAR&quot;（线性插值），可选的值有： NEAREST 最近邻插值LINEAR 线性插值（默认）AREA 区域插值CUBIC 三次样条插值LANCZOS4 Lanczos 插值 参见InterpolationFlags 返回 {Image}  放缩图片，并返回放缩后的图片。例如把图片变成原来的一半：images.scale(img, 0.5, 0.5)。  参见Imgproc.resize。  ","version":"Next","tagName":"h2"},{"title":"images.rotate(img, degress[, x, y])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesrotateimg-degress-x-y","content":" [v4.1.0 新增]  img {Image} 图片degress {number} 旋转角度。x {number} 旋转中心 x 坐标，默认为图片中点y {number} 旋转中心 y 坐标，默认为图片中点返回 {Image}  将图片逆时针旋转 degress 度，返回旋转后的图片对象。  例如逆时针旋转 90 度为images.rotate(img, 90)。  ","version":"Next","tagName":"h2"},{"title":"images.concat(img1, image2[, direction])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesconcatimg1-image2-direction","content":" [v4.1.0 新增]  img1 {Image} 图片 1img2 {Image} 图片 2direction {string} 连接方向，默认为&quot;RIGHT&quot;，可选的值有： LEFT 将图片 2 接到图片 1 左边RIGHT 将图片 2 接到图片 1 右边TOP 将图片 2 接到图片 1 上边BOTTOM 将图片 2 接到图片 1 下边 返回 {Image}  连接两张图片，并返回连接后的图像。如果两张图片大小不一致，小的那张将适当居中。  ","version":"Next","tagName":"h2"},{"title":"images.grayscale(img)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesgrayscaleimg","content":" [v4.1.0 新增]  img {Image} 图片返回 {Image}  灰度化图片，并返回灰度化后的图片。  ","version":"Next","tagName":"h2"},{"title":"image.threshold(img, threshold, maxVal[, type])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagethresholdimg-threshold-maxval-type","content":" [v4.1.0 新增]  img {Image} 图片threshold {number} 阈值maxVal {number} 最大值type {string} 阈值化类型，默认为&quot;BINARY&quot;，参见ThresholdTypes, 可选的值: BINARYBINARY_INVTRUNCTOZEROTOZERO_INVOTSUTRIANGLE 返回 {Image}  将图片阈值化，并返回处理后的图像。可以用这个函数进行图片二值化。例如：images.threshold(img, 100, 255, &quot;BINARY&quot;)，这个代码将图片中大于 100 的值全部变成 255，其余变成 0，从而达到二值化的效果。如果 img 是一张灰度化图片，这个代码将会得到一张黑白图片。  可以参考有关博客（比如threshold 函数的使用）或者 OpenCV 文档threshold。  ","version":"Next","tagName":"h2"},{"title":"images.adaptiveThreshold(img, maxValue, adaptiveMethod, thresholdType, blockSize, C)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesadaptivethresholdimg-maxvalue-adaptivemethod-thresholdtype-blocksize-c","content":" [v4.1.0 新增]  img {Image} 图片maxValue {number} 最大值adaptiveMethod {string} 在一个邻域内计算阈值所采用的算法，可选的值有： MEAN_C 计算出领域的平均值再减去参数 C 的值GAUSSIAN_C 计算出领域的高斯均值再减去参数 C 的值 thresholdType {string} 阈值化类型，可选的值有： BINARYBINARY_INV blockSize {number} 邻域块大小C {number} 偏移值调整量返回 {Image}  对图片进行自适应阈值化处理，并返回处理后的图像。  可以参考有关博客（比如threshold 与 adaptiveThreshold）或者 OpenCV 文档adaptiveThreshold。  ","version":"Next","tagName":"h2"},{"title":"images.cvtColor(img, code[, dstCn])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagescvtcolorimg-code-dstcn","content":" [v4.1.0 新增]  img {Image} 图片code {string} 颜色空间转换的类型，可选的值有一共有 205 个（参见ColorConversionCodes），这里只列出几个： BGR2GRAY BGR 转换为灰度BGR2HSV BGR 转换为 HSV`` dstCn {number} 目标图像的颜色通道数量，如果不填写则根据其他参数自动决定。返回 {Image}  对图像进行颜色空间转换，并返回转换后的图像。  可以参考有关博客（比如颜色空间转换）或者 OpenCV 文档cvtColor。  ","version":"Next","tagName":"h2"},{"title":"images.inRange(img, lowerBound, upperBound)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesinrangeimg-lowerbound-upperbound","content":" [v4.1.0 新增]  img {Image} 图片lowerBound {string} | {number} 颜色下界upperBound {string} | {number} 颜色下界返回 {Image}  将图片二值化，在 lowerBound~upperBound 范围以外的颜色都变成 0，在范围以内的颜色都变成 255。  例如images.inRange(img, &quot;#000000&quot;, &quot;#222222&quot;)。  ","version":"Next","tagName":"h2"},{"title":"images.interval(img, color, interval)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesintervalimg-color-interval","content":" [v4.1.0 新增]  img {Image} 图片color {string} | {number} 颜色值interval {number} 每个通道的范围间隔返回 {Image}  将图片二值化，在 color-interval ~ color+interval 范围以外的颜色都变成 0，在范围以内的颜色都变成 255。这里对 color 的加减是对每个通道而言的。  例如images.interval(img, &quot;#888888&quot;, 16)，每个通道的颜色值均为 0x88，加减 16 后的范围是[0x78, 0x98]，因此这个代码将把#787878~#989898 的颜色变成#FFFFFF，而把这个范围以外的变成#000000。  ","version":"Next","tagName":"h2"},{"title":"images.blur(img, size[, anchor, type])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesblurimg-size-anchor-type","content":" [v4.1.0 新增]  img {Image} 图片size {Array} 定义滤波器的大小，如[3, 3]anchor {Array} 指定锚点位置(被平滑点)，默认为图像中心type {string} 推断边缘像素类型，默认为&quot;DEFAULT&quot;，可选的值有： CONSTANT iiiiii|abcdefgh|iiiiiii with some specified iREPLICATE aaaaaa|abcdefgh|hhhhhhhREFLECT fedcba|abcdefgh|hgfedcbWRAP cdefgh|abcdefgh|abcdefgREFLECT_101 gfedcb|abcdefgh|gfedcbaTRANSPARENT uvwxyz|abcdefgh|ijklmnoREFLECT101 same as BORDER_REFLECT_101DEFAULT same as BORDER_REFLECT_101ISOLATED do not look outside of ROI 返回 {Image}  对图像进行模糊（平滑处理），返回处理后的图像。  可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档blur。  ","version":"Next","tagName":"h2"},{"title":"images.medianBlur(img, size)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesmedianblurimg-size","content":" [v4.1.0 新增]  img {Image} 图片size {Array} 定义滤波器的大小，如[3, 3]返回 {Image}  对图像进行中值滤波，返回处理后的图像。  可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档blur。  ","version":"Next","tagName":"h2"},{"title":"images.gaussianBlur(img, size[, sigmaX, sigmaY, type])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesgaussianblurimg-size-sigmax-sigmay-type","content":" [v4.1.0 新增]  img {Image} 图片size {Array} 定义滤波器的大小，如[3, 3]sigmaX {number} x 方向的标准方差，不填写则自动计算sigmaY {number} y 方向的标准方差，不填写则自动计算type {string} 推断边缘像素类型，默认为&quot;DEFAULT&quot;，参见images.blur返回 {Image}  对图像进行高斯模糊，返回处理后的图像。  可以参考有关博客（比如实现图像平滑处理）或者 OpenCV 文档GaussianBlur。  ","version":"Next","tagName":"h2"},{"title":"images.matToImage(mat)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesmattoimagemat","content":" [v4.1.0 新增]  mat {Mat} OpenCV 的 Mat 对象返回 {Image}  把 Mat 对象转换为 Image 对象。  ","version":"Next","tagName":"h2"},{"title":"找图找色​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#找图找色","content":" ","version":"Next","tagName":"h2"},{"title":"images.requestScreenCapture([landscape])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesrequestscreencapturelandscape","content":" landscape {boolean} 截屏方向 true 横屏截图false 竖屏截图不指定值，由当前设备屏幕方向决定截图方向 return {boolean}  向系统申请屏幕截图权限，返回是否请求成功,仅需执行一次  建议在本软件界面运行该函数，在其他软件界面运行时容易出现一闪而过的黑屏现象。  示例:  //请求截图 //每次使用该函数都会弹出截图权限请求，建议选择“总是允许”。 if (!requestScreenCapture()) { toast(&quot;请求截图失败&quot;); exit(); } //连续截图 10 张图片(间隔 1 秒)并保存到存储卡目录 for (var i = 0; i &lt; 10; i++) { captureScreen(&quot;/sdcard/screencapture&quot; + i + &quot;.png&quot;); sleep(1000); }   //安卓版本高于Android 9 if (device.sdkInt &gt; 28) { //等待截屏权限申请并同意 threads.start(function () { packageName(&quot;com.android.systemui&quot;).text(&quot;立即开始&quot;).waitFor(); text(&quot;立即开始&quot;).click(); }); } //申请截屏权限 if (!requestScreenCapture()) { toast(&quot;请求截图失败&quot;); exit(); }   该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"images.stopScreenCapturer()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesstopscreencapturer","content":" [v6.5.8 新增]  停止截图权限并释放相关资源，若之后再调用images.captureScreen()截图会抛出错误  ","version":"Next","tagName":"h2"},{"title":"images.captureScreen()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagescapturescreen","content":" return {Image}  截取当前屏幕并返回一个 Image 对象。  没有截图权限时执行该函数会抛出 SecurityException。  该函数不会返回 null，两次调用可能返回相同的 Image 对象。这是因为设备截图的更新需要一定的时间，短时间内（一般来说是 16ms）连续调用则会返回同一张截图。  截图需要转换为 Bitmap 格式，从而该函数执行需要一定的时间(0~20ms)。  另外在 requestScreenCapture()执行成功后需要一定时间后才有截图可用，因此如果立即调用 captureScreen()，会等待一定时间后(一般为几百 ms)才返回截图。  例子:  //请求横屏截图 requestScreenCapture(true); //截图 var img = captureScreen(); //获取在点(100, 100)的颜色值 var color = images.pixel(img, 100, 100); //显示该颜色值 toast(colors.toString(color));   该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"images.captureScreen(path)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagescapturescreenpath","content":" path {string} 截图保存路径  截取当前屏幕并以 PNG 格式保存到 path 中。如果文件不存在会被创建；文件存在会被覆盖。  该函数不会返回任何值。该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"images.pixel(image, x, y)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagespixelimage-x-y","content":" image {Image} 图片x {number} 要获取的像素的横坐标。y {number} 要获取的像素的纵坐标。  返回图片 image 在点(x, y)处的像素的 ARGB 值。  该值的格式为 0xAARRGGBB，是一个&quot;32 位整数&quot;(虽然 JavaScript 中并不区分整数类型和其他数值类型)。  坐标系以图片左上角为原点。以图片左侧边为 y 轴，上侧边为 x 轴。  ","version":"Next","tagName":"h2"},{"title":"images.readPixels(path)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesreadpixelspath","content":" path {string} 图片的地址return {Object} 包括图片的像素数据和宽高，{data,width,height}  读取图片的像素数据和宽高。  ","version":"Next","tagName":"h2"},{"title":"images.findColor(image, color, options)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindcolorimage-color-options","content":" image {Image} 图片color {number} | {string} 要寻找的颜色的 RGB 值。如果是一个整数，则以 0xRRGGBB 的形式代表 RGB 值（A 通道会被忽略）；如果是字符串，则以&quot;#RRGGBB&quot;代表其 RGB 值。options {Object} 选项包括： region {Array} 找色区域。是一个两个或四个元素的数组。(region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有 region 只有两个元素，则找色区域为(region[0], region[1])到屏幕右下角。如果不指定 region 选项，则找色区域为整张图片。threshold {number} 找色时颜色相似度的临界值，范围为 0255（越小越相似，0 为颜色相等，255 为任何颜色都能匹配）。默认为 4。threshold 和浮点数相似度(0.01.0)的换算为 similarity = (255 - threshold) / 255.  在图片中寻找颜色 color。找到时返回找到的点 Point，找不到时返回 null。  该函数也可以作为全局函数使用。  一个循环找色的例子如下：  requestScreenCapture(); //循环找色，找到红色(#ff0000)时停止并报告坐标 while (true) { var img = captureScreen(); var point = findColor(img, &quot;#ff0000&quot;); if (point) { toast(&quot;找到红色，坐标为(&quot; + point.x + &quot;, &quot; + point.y + &quot;)&quot;); } }   一个区域找色的例子如下：  //读取本地图片/sdcard/1.png var img = images.read(&quot;/sdcard/1.png&quot;); //判断图片是否加载成功 if (!img) { toast(&quot;没有该图片&quot;); exit(); } //在该图片中找色，指定找色区域为在位置(400, 500)的宽为300长为200的区域，指定找色临界值为4 var point = findColor(img, &quot;#00ff00&quot;, { region: [400, 500, 300, 200], threshold: 4, }); if (point) { toast(&quot;找到啦:&quot; + point); } else { toast(&quot;没找到&quot;); }   ","version":"Next","tagName":"h2"},{"title":"images.findColorInRegion(img, color, x, y[, width, height, threshold])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindcolorinregionimg-color-x-y-width-height-threshold","content":" 区域找色的简便方法。  相当于  images.findColor(img, color, { region: [x, y, width, height], threshold: threshold, });   该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"images.findColorEquals(img, color[, x, y, width, height])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindcolorequalsimg-color-x-y-width-height","content":" img {Image} 图片color {number} | {string} 要寻找的颜色x {number} 找色区域的左上角横坐标y {number} 找色区域的左上角纵坐标width {number} 找色区域的宽度height {number} 找色区域的高度返回 {Point}  在图片 img 指定区域中找到颜色和 color 完全相等的某个点，并返回该点的左边；如果没有找到，则返回null。  找色区域通过x, y, width, height指定，如果不指定找色区域，则在整张图片中寻找。  该函数也可以作为全局函数使用。  示例： (通过找 QQ 红点的颜色来判断是否有未读消息)  requestScreenCapture(); launchApp(&quot;QQ&quot;); sleep(1200); var p = findColorEquals(captureScreen(), &quot;#f64d30&quot;); if (p) { toast(&quot;有未读消息&quot;); } else { toast(&quot;没有未读消息&quot;); }   ","version":"Next","tagName":"h2"},{"title":"images.findAllPointsForColor(img, color, options)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindallpointsforcolorimg-color-options","content":" img {Image} 图片color {number | string} 要检测的颜色options {Object} 选项包括： region {Array} 找色区域。是一个两个或四个元素的数组。(region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果 region只有两个元素，则找色区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找色区域为整张图片。similarity {number} 找色时颜色相似度，范围为 0~1（越大越相似，1 为颜色相等，0 为任何颜色都能匹配）。threshold {number} 找色时颜色相似度的临界值，范围为 0 ~ 255（越小越相似，0 为颜色相等，255 为任何颜色都能匹配）。默认为 4。similarity与threshold的换算为similarity = (255 - threshold) / 255 。二选一，同时存在则以similarity为准。 return {Array}  在图片中寻找所有颜色为color的点。找到时返回找到的点 Point 的数组，找不到时返回null。  例如找出所有白色的点：  log(images.findAllPointsForColor(img, &quot;#ffffff&quot;));   ","version":"Next","tagName":"h2"},{"title":"images.findMultiColors(img, firstColor, colors[, options])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindmulticolorsimg-firstcolor-colors-options","content":" img {Image} 要找色的图片firstColor {number} | {string} 第一个点的颜色colors {Array} 表示剩下的点相对于第一个点的位置和颜色的数组，数组的每个元素为[x, y, color]options {Object} 选项，包括： region {Array} 找色区域。是一个两个或四个元素的数组。(region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有 region 只有两个元素，则找色区域为(region[0], region[1])到屏幕右下角。如果不指定 region 选项，则找色区域为整张图片。threshold {number} 找色时颜色相似度的临界值，范围为 0255（越小越相似，0 为颜色相等，255 为任何颜色都能匹配）。默认为 4。threshold 和浮点数相似度(0.01.0)的换算为 similarity = (255 - threshold) / 255.  多点找色，类似于按键精灵的多点找色，其过程如下：  在图片 img 中找到颜色 firstColor 的位置(x0, y0)对于数组 colors 的每个元素[x, y, color]，检查图片 img 在位置(x + x0, y + y0)上的像素是否是颜色 color，是的话返回(x0, y0)，否则继续寻找 firstColor 的位置，重新执行第 1 步整张图片都找不到时返回null  例如，对于代码images.findMultiColors(img, &quot;#123456&quot;, [[10, 20, &quot;#ffffff&quot;], [30, 40, &quot;#000000&quot;]])，假设图片在(100, 200)的位置的颜色为#123456, 这时如果(110, 220)的位置的颜色为#fffff 且(130, 240)的位置的颜色为#000000，则函数返回点(100, 200)。  如果要指定找色区域，则在 options 中指定，例如:  var p = images.findMultiColors( img, &quot;#123456&quot;, [ [10, 20, &quot;#ffffff&quot;], [30, 40, &quot;#000000&quot;], ], { region: [0, 960, 1080, 960], } );   ","version":"Next","tagName":"h2"},{"title":"images.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesdetectscolorimage-color-x-y-threshold--16-algorithm--diff","content":" image {Image} 图片 color {number} | {string} 要检测的颜色 x {number} 要检测的位置横坐标 y {number} 要检测的位置纵坐标 threshold {number} 颜色相似度临界值，默认为 16。取值范围为 0~255。 algorithm {string} 颜色匹配算法，包括: &quot;equal&quot;: 相等匹配，只有与给定颜色 color 完全相等时才匹配。 &quot;diff&quot;: 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。 &quot;rgb&quot;: rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。 &quot;rgb+&quot;: 加权 rgb 欧拉距离匹配(LAB Delta E)。 &quot;hs&quot;: hs 欧拉距离匹配。hs 为 HSV 空间的色调值。  返回图片 image 在位置(x, y)处是否匹配到颜色 color。用于检测图片中某个位置是否是特定颜色。  一个判断微博客户端的某个微博是否被点赞过的例子：  requestScreenCapture(); //找到点赞控件 var like = id(&quot;ly_feed_like_icon&quot;).findOne(); //获取该控件中点坐标 var x = like.bounds().centerX(); var y = like.bounds().centerY(); //截图 var img = captureScreen(); //判断在该坐标的颜色是否为橙红色 if (images.detectsColor(img, &quot;#fed9a8&quot;, x, y)) { //是的话则已经是点赞过的了，不做任何动作 } else { //否则点击点赞按钮 like.click(); }   ","version":"Next","tagName":"h2"},{"title":"images.findImage(img, template[, options])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindimageimg-template-options","content":" img {Image} 大图片template {Image} 小图片（模板）options {Object} 选项包括： threshold {number} 图片相似度。取值范围为 0~1 的浮点数。默认值为 0.9。region {Array} 找图区域。参见 findColor 函数关于 region 的说明。level {number} 一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level 参数表示金字塔的层次, level 越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要用到该参数。  找图。在大图片 img 中查找小图片 template 的位置（模块匹配），找到时返回位置坐标(Point)，找不到时返回 null。  该函数也可以作为全局函数使用。  一个最简单的找图例子如下：  var img = images.read(&quot;/sdcard/大图.png&quot;); var templ = images.read(&quot;/sdcard/小图.png&quot;); var p = findImage(img, templ); if (p) { toast(&quot;找到啦:&quot; + p); } else { toast(&quot;没找到&quot;); }   稍微复杂点的区域找图例子如下：  auto(); requestScreenCapture(); var wx = images.read(&quot;/sdcard/微信图标.png&quot;); //返回桌面 home(); //截图并找图 var p = findImage(captureScreen(), wx, { region: [0, 50], threshold: 0.8, }); if (p) { toast(&quot;在桌面找到了微信图标啦: &quot; + p); } else { toast(&quot;在桌面没有找到微信图标&quot;); }   ","version":"Next","tagName":"h2"},{"title":"images.findImageInRegion(img, template, x, y[, width, height, threshold])​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindimageinregionimg-template-x-y-width-height-threshold","content":" 区域找图的简便方法。相当于：  images.findImage(img, template, { region: [x, y, width, height], threshold: threshold, });   该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"images.matchTemplate(img, template, options)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesmatchtemplateimg-template-options","content":" [v4.1.0 新增]  img {Image} 大图片template {Image} 小图片（模板）options {Object} 找图选项： threshold {number} 图片相似度。取值范围为 0~1 的浮点数。默认值为 0.9。region {Array} 找图区域。参见 findColor 函数关于 region 的说明。max {number} 找图结果最大数量，默认为 5level {number} 一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level 参数表示金字塔的层次, level 越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要用到该参数。 返回 {MatchingResult}  在大图片中搜索小图片，并返回搜索结果 MatchingResult。该函数可以用于找图时找出多个位置，可以通过 max 参数控制最大的结果数量。也可以对匹配结果进行排序、求最值等操作。  ","version":"Next","tagName":"h2"},{"title":"images.findCircles(gray, options)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesfindcirclesgray-options","content":" gray {Image} 灰度图片options {Object} 选项包括： region {Array} 找圆区域。是一个两个或四个元素的数组。(region[0], region[1])表示找圆区域的左上角；region[2]*region[3]表示找圆区域的宽高。如果只有 region 只有两个元素，则找圆区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找圆区域为整张图片。dp {number} dp 是累加面与原始图像相比的分辨率的反比参数，dp=2 时累计面分辨率是元素图像的一半，宽高都缩减为原来的一半，dp=1 时，两者相同。默认为 1。minDst {number} minDist 定义了两个圆心之间的最小距离。默认为图片高度的八分之一。param1 {number} param1 是 Canny 边缘检测的高阈值，低阈值被自动置为高阈值的一半。默认为 100，范围为 0-255。param2 {number} param2 是累加平面对是否是圆的判定阈值，默认为 100。minRadius {number} 定义了检测到的圆的半径的最小值，默认为 0。maxRadius {number} 定义了检测到的圆的半径的最大值，0 为不限制最大值，默认为 0。 return {Array}  在图片中寻找圆（做霍夫圆变换）。找到时返回找到的所有圆{x,y,radius}的数组，找不到时返回 null。  一个寻找圆的例子：  // 请求截图 requestScreenCapture(); // 截图 let img = captureScreen(); // 灰度化图片 let gray = images.grayscale(img); // 找圆 let arr = findCircles(gray, { dp: 1, minDst: 80, param1: 100, param2: 100, minRadius: 50, maxRadius: 80, }); // 回收图片 gray.recycle();   MatchingResult  [v4.1.0 新增]  ","version":"Next","tagName":"h2"},{"title":"matches​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#matches","content":" {Array} 匹配结果的数组。  数组的元素是一个 Match 对象：  point {Point} 匹配位置similarity {number} 相似度  例如:  var result = images.matchTemplate(img, template, { max: 100, }); result.matches.forEach((match) =&gt; { log(&quot;point = &quot; + match.point + &quot;, similarity = &quot; + match.similarity); });   ","version":"Next","tagName":"h2"},{"title":"points​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#points","content":" {Array} 匹配位置的数组。  ","version":"Next","tagName":"h2"},{"title":"first()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#first","content":" 返回 {Match}  第一个匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"last()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#last","content":" 返回 {Match}  最后一个匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"leftmost()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#leftmost","content":" 返回 {Match}  位于大图片最左边的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"topmost()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#topmost","content":" 返回 {Match}  位于大图片最上边的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"rightmost()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#rightmost","content":" 返回 {Match}  位于大图片最右边的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"bottommost()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#bottommost","content":" 返回 {Match}  位于大图片最下边的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"best()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#best","content":" 返回 {Match}  相似度最高的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"worst()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#worst","content":" 返回 {Match}  相似度最低的匹配结果。如果没有任何匹配，则返回null。  ","version":"Next","tagName":"h2"},{"title":"sortBy(cmp)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#sortbycmp","content":" cmp {Function}|{string} 比较函数，或者是一个字符串表示排序方向。例如&quot;left&quot;表示将匹配结果按匹配位置从左往右排序、&quot;top&quot;表示将匹配结果按匹配位置从上往下排序，&quot;left-top&quot;表示将匹配结果按匹配位置从左往右、从上往下排序。方向包括left（左）, top （上）, right （右）, bottom（下）。{MatchingResult}  对匹配结果进行排序，并返回排序后的结果。  var result = images.matchTemplate(img, template, { max: 100, }); log(result.sortBy(&quot;top-right&quot;));   Image  表示一张图片，可以是截图的图片，或者本地读取的图片，或者从网络获取的图片。  ","version":"Next","tagName":"h2"},{"title":"Image.getWidth()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagegetwidth","content":" 返回以像素为单位图片宽度。  ","version":"Next","tagName":"h2"},{"title":"Image.getHeight()​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagegetheight","content":" 返回以像素为单位的图片高度。  ","version":"Next","tagName":"h2"},{"title":"Image.saveTo(path)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagesavetopath","content":" path {string} 路径  把图片保存到路径 path。（如果文件存在则覆盖）  ","version":"Next","tagName":"h2"},{"title":"Image.pixel(x, y)​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#imagepixelx-y","content":" x {number} 横坐标y {number} 纵坐标  返回图片 image 在点(x, y)处的像素的 ARGB 值。  该值的格式为 0xAARRGGBB，是一个&quot;32 位整数&quot;(虽然 JavaScript 中并不区分整数类型和其他数值类型)。  坐标系以图片左上角为原点。以图片左侧边为 y 轴，上侧边为 x 轴。  Point  findColor, findImage 返回的对象。表示一个点（坐标）。  ","version":"Next","tagName":"h2"},{"title":"Point.x​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#pointx","content":" 横坐标。  ","version":"Next","tagName":"h2"},{"title":"Point.y​","type":1,"pageTitle":"Images 图片与颜色","url":"/docs/rhino/advanced/images#pointy","content":" 纵坐标。 ","version":"Next","tagName":"h2"},{"title":"shell 终端","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/shell","content":"","keywords":"","version":"Next"},{"title":"shell(cmd[, root])​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#shellcmd-root","content":" cmd {string} 要执行的命令root {Boolean} 是否以 root 权限运行，默认为 false。  一次性执行命令 cmd, 并返回命令的执行结果。返回对象的其属性如下:  code {number} 返回码。执行成功时为 0，失败时为非 0 的数字。result {string} 运行结果(stdout 输出结果)error {string} 运行的错误信息(stderr 输出结果)。例如执行需要 root 权限的命令但没有授予 root 权限会返回错误信息&quot;Permission denied&quot;。  示例（强制停止微信）：  var result = shell(&quot;am force-stop com.tencent.mm&quot;, true); log(result); console.show(); if (result.code == 0) { toast(&quot;执行成功&quot;); } else { toast(&quot;执行失败！请到控制台查看错误信息&quot;); }   Shell  稳定性: 稳定  shell 函数通过用来一次性执行单条命令并获取结果。如果有多条命令需要执行，用 Shell 对象的效率更高。这是因为，每次运行 shell 函数都会打开一个单独的 shell 进程并在运行结束后关闭他，这个过程需要一定的时间；而 Shell 对象自始至终使用同一个 shell 进程。  ","version":"Next","tagName":"h2"},{"title":"new Shell(root)​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#new-shellroot","content":" root {Boolean} 是否以 root 权限运行一个 shell 进程，默认为 false。这将会影响其后使用该 Shell 对象执行的命令的权限  Shell 对象的&quot;构造函数&quot;。  var sh = new Shell(true); //强制停止微信 sh.exec(&quot;am force-stop com.tencent.mm&quot;); sh.exit();   ","version":"Next","tagName":"h2"},{"title":"Shell.exec(cmd)​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#shellexeccmd","content":" cmd {string} 要执行的命令  执行命令 cmd。该函数不会返回任何值。  注意，命令执行是&quot;异步&quot;的、非阻塞的。也就是不会等待命令完成后才继续向下执行。  尽管这样的设计使用起来有很多不便之处，但受限于终端模拟器，暂时没有解决方式；如果后续能找到解决方案，则将提供Shell.execAndWaitFor函数。  ","version":"Next","tagName":"h2"},{"title":"Shell.exit()​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#shellexit","content":" 直接退出 shell。正在执行的命令会被强制退出。  ","version":"Next","tagName":"h2"},{"title":"Shell.exitAndWaitFor()​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#shellexitandwaitfor","content":" 执行&quot;exit&quot;命令并等待执行命令执行完成、退出 shell。  此函数会执行 exit 命令来正常退出 shell。  ","version":"Next","tagName":"h2"},{"title":"Shell.setCallback(callback)​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#shellsetcallbackcallback","content":" callback {Object} 回调函数  设置该 Shell 的回调函数，以便监听 Shell 的输出。可以包括以下属性：  onOutput {Function} 每当 shell 有新的输出时便会调用该函数。其参数是一个字符串。onNewLine {Function} 每当 shell 有新的一行输出时便会调用该函数。其参数是一个字符串(不包括最后的换行符)。  例如:  var sh = new Shell(); sh.setCallback({ onNewLine: function (line) { //有新的一行输出时打印到控制台 log(line); }, }); while (true) { //循环输入命令 var cmd = dialogs.rawInput(&quot;请输入要执行的命令，输入exit退出&quot;); if (cmd == &quot;exit&quot;) { break; } //执行命令 sh.exec(cmd); } sh.exit();   附录: shell 命令简介  以下关于 shell 命令的资料来自AndroidStudio 用户指南：Shell 命令。  ","version":"Next","tagName":"h2"},{"title":"am 命令​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#am-命令","content":" am 命令即 Activity Manager 命令，用于管理应用程序活动、服务等。  以下命令均以&quot;am &quot;开头，例如shell('am start -p com.tencent.mm');(启动微信)  ","version":"Next","tagName":"h2"},{"title":"start [options] intent​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#start-options-intent","content":" 启动 intent 指定的 Activity(应用程序活动)。 请参阅 intent 参数的规范。  选项包括：  -D：启用调试。-W：等待启动完成。--start-profiler file：启动分析器并将结果发送到 file。-P file：类似于 --start-profiler，但当应用进入空闲状态时分析停止。-R count：重复 Activity 启动 count 次数。在每次重复前，将完成顶部 Activity。-S：启动 Activity 前强行停止目标应用。--opengl-trace：启用 OpenGL 函数的跟踪。--user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。  ","version":"Next","tagName":"h3"},{"title":"startservice [options] intent​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#startservice-options-intent","content":" 启动 intent 指定的 Service(服务)。 请参阅 intent 参数的规范。 选项包括：  --user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。  ","version":"Next","tagName":"h3"},{"title":"force-stop package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#force-stop-package","content":" 强行停止与 package（应用包名）关联的所有应用。  ","version":"Next","tagName":"h3"},{"title":"kill [options] package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#kill-options-package","content":" 终止与 package（应用包名）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。 选项包括：  --user user_id | all | current：指定将终止其进程的用户；如果未指定，则终止所有用户的进程。  ","version":"Next","tagName":"h3"},{"title":"kill-all​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#kill-all","content":" 终止所有后台进程。  ","version":"Next","tagName":"h3"},{"title":"broadcast [options] intent​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#broadcast-options-intent","content":" 发出广播 intent。 请参阅 intent 参数的规范。  选项包括：  [--user user_id | all | current]：指定要发送到的用户；如果未指定，则发送到所有用户。  ","version":"Next","tagName":"h3"},{"title":"instrument [options] component​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#instrument-options-component","content":" 使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package/runner_class。 选项包括：  -r：输出原始结果（否则对 report_key_streamresult 进行解码）。与 [-e perf true] 结合使用以生成性能测量的原始输出。-e name value：将参数 name 设为 value。对于测试运行器，通用表单为 -e testrunner_flag value[,value...]。-p file：将分析数据写入 file。-w：先等待仪器完成，然后再返回。测试运行器需要使用此选项。--no-window-animation：运行时关闭窗口动画。--user user_id | current：指定仪器在哪个用户中运行；如果未指定，则在当前用户中运行。profile start process file 启动 process 的分析器，将结果写入 file。profile stop process 停止 process 的分析器。  ","version":"Next","tagName":"h3"},{"title":"dumpheap [options] process file​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#dumpheap-options-process-file","content":" 转储 process 的堆，写入 file。  选项包括：  --user [user_id|current]：提供进程名称时，指定要转储的进程用户；如果未指定，则使用当前用户。-n：转储原生堆，而非托管堆。set-debug-app [options] package 将应用 package 设为调试。  选项包括：  -w：应用启动时等待调试程序。--persistent：保留此值。clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。  ","version":"Next","tagName":"h3"},{"title":"monitor [options] 启动对崩溃或 ANR 的监控。​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#monitor-options-启动对崩溃或-anr-的监控","content":" 选项包括：  --gdb：在崩溃/ANR 时在给定端口上启动 gdbserv。  ","version":"Next","tagName":"h3"},{"title":"screen-compat {on|off} package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#screen-compat-onoff-package","content":" 控制 package 的屏幕兼容性模式。  ","version":"Next","tagName":"h3"},{"title":"display-size [reset|widthxheight]​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#display-size-resetwidthxheight","content":" 替换模拟器/设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。 示例：  shell(&quot;am display-size 1280x800&quot;, true);   ","version":"Next","tagName":"h3"},{"title":"display-density dpi​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#display-density-dpi","content":" 替换模拟器/设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。 示例：  shell(&quot;am display-density 480&quot;, true);   ","version":"Next","tagName":"h3"},{"title":"to-uri intent​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#to-uri-intent","content":" 将给定的 intent 规范以 URI 的形式输出。 请参阅 intent 参数的规范。  ","version":"Next","tagName":"h3"},{"title":"to-intent-uri intent​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#to-intent-uri-intent","content":" 将给定的 intent 规范以 intent:URI 的形式输出。 请参阅 intent 参数的规范。  ","version":"Next","tagName":"h3"},{"title":"intent 参数的规范​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#intent-参数的规范","content":" 对于采用 intent 参数的 am 命令，您可以使用以下选项指定 intent：  -a action 指定 intent 操作，如“android.intent.action.VIEW”。此指定只能声明一次。-d data_uri 指定 intent 数据 URI，如“content://contacts/people/1”。此指定只能声明一次。-t mime_type 指定 intent MIME 类型，如“image/png”。此指定只能声明一次。-c category 指定 intent 类别，如“android.intent.category.APP_CONTACTS”。-n component 指定带有软件包名称前缀的组件名称以创建显式 intent，如“com.example.app/.ExampleActivity”。-f flags 将标志添加到 setFlags() 支持的 intent。--esn extra_key 添加一个 null extra。URI intent 不支持此选项。-e|--es extra_key extra_string_value 添加字符串数据作为键值对。--ez extra_key extra_boolean_value 添加布尔型数据作为键值对。--ei extra_key extra_int_value 添加整数型数据作为键值对。--el extra_key extra_long_value 添加长整型数据作为键值对。--ef extra_key extra_float_value 添加浮点型数据作为键值对。--eu extra_key extra_uri_value 添加 URI 数据作为键值对。--ecn extra_key extra_component_name_value 添加组件名称，将其作为 ComponentName 对象进行转换和传递。--eia extra_key extra_int_value[,extra_int_value...] 添加整数数组。--ela extra_key extra_long_value[,extra_long_value...] 添加长整型数组。--efa extra_key extra_float_value[,extra_float_value...] 添加浮点型数组。--grant-read-uri-permission 包含标志 FLAG_GRANT_READ_URI_PERMISSION。--grant-write-uri-permission 包含标志 FLAG_GRANT_WRITE_URI_PERMISSION。--debug-log-resolution 包含标志 FLAG_DEBUG_LOG_RESOLUTION。--exclude-stopped-packages 包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES。--include-stopped-packages 包含标志 FLAG_INCLUDE_STOPPED_PACKAGES。--activity-brought-to-front 包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT。--activity-clear-top 包含标志 FLAG_ACTIVITY_CLEAR_TOP。--activity-clear-when-task-reset 包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET。--activity-exclude-from-recents 包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS。--activity-launched-from-history 包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY。--activity-multiple-task 包含标志 FLAG_ACTIVITY_MULTIPLE_TASK。--activity-no-animation 包含标志 FLAG_ACTIVITY_NO_ANIMATION。--activity-no-history 包含标志 FLAG_ACTIVITY_NO_HISTORY。--activity-no-user-action 包含标志 FLAG_ACTIVITY_NO_USER_ACTION。--activity-previous-is-top 包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP。--activity-reorder-to-front 包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT。--activity-reset-task-if-needed 包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。--activity-single-top 包含标志 FLAG_ACTIVITY_SINGLE_TOP。--activity-clear-task 包含标志 FLAG_ACTIVITY_CLEAR_TASK。--activity-task-on-home 包含标志 FLAG_ACTIVITY_TASK_ON_HOME。--receiver-registered-only 包含标志 FLAG_RECEIVER_REGISTERED_ONLY。--receiver-replace-pending 包含标志 FLAG_RECEIVER_REPLACE_PENDING。--selector 需要使用 -d 和 -t 选项以设置 intent 数据和类型。  URI component package​  如果不受上述某一选项的限制，您可以直接指定 URI、软件包名称和组件名称。当参数不受限制时，如果参数包含一个“:”（冒号），则此工具假定参数是一个 URI；如果参数包含一个“/”（正斜杠），则此工具假定参数是一个组件名称；否则，此工具假定参数是一个软件包名称。  ","version":"Next","tagName":"h3"},{"title":"应用包名​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#应用包名","content":" 所谓应用包名，是唯一确定应用的标识。例如微信的包名是&quot;com.tencent.mm&quot;, QQ 的包名是&quot;com.tencent.mobileqq&quot;。 要获取一个应用的包名，可以通过函数getPackageName(appName)获取。参见帮助-&gt;其他一般函数。  ","version":"Next","tagName":"h2"},{"title":"pm 命令​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#pm-命令","content":" pm 命令用于管理应用程序，例如卸载应用、冻结应用等。 以下命令均以&quot;pm &quot;开头，例如&quot;shell(&quot;pm disable com.tencent.mm&quot;);&quot;(冻结微信)  ","version":"Next","tagName":"h2"},{"title":"list packages [options] filter​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-packages-options-filter","content":" 输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。 选项：  -f：查看它们的关联文件。-d：进行过滤以仅显示已停用的软件包。-e：进行过滤以仅显示已启用的软件包。-s：进行过滤以仅显示系统软件包。-3：进行过滤以仅显示第三方软件包。-i：查看软件包的安装程序。-u：也包括卸载的软件包。--user user_id：要查询的用户空间。  ","version":"Next","tagName":"h3"},{"title":"list permission-groups​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-permission-groups","content":" 输出所有已知的权限组。  ","version":"Next","tagName":"h3"},{"title":"list permissions [options] group​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-permissions-options-group","content":" 输出所有已知权限，或者，仅输出 group 中的权限。 选项：  -g：按组加以组织。-f：输出所有信息。-s：简短摘要。-d：仅列出危险权限。-u：仅列出用户将看到的权限。  ","version":"Next","tagName":"h3"},{"title":"list instrumentation [options]​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-instrumentation-options","content":" 列出所有测试软件包。 选项：  -f：列出用于测试软件包的 APK 文件。target_package：列出仅用于此应用的测试软件包。  ","version":"Next","tagName":"h3"},{"title":"list features​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-features","content":" 输出系统的所有功能。  ","version":"Next","tagName":"h3"},{"title":"list libraries​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-libraries","content":" 输出当前设备支持的所有库。  ","version":"Next","tagName":"h3"},{"title":"list users​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#list-users","content":" 输出系统上的所有用户。  ","version":"Next","tagName":"h3"},{"title":"path package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#path-package","content":" 输出给定 package 的 APK 的路径。  ","version":"Next","tagName":"h3"},{"title":"install [options] path​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#install-options-path","content":" 将软件包（通过 path 指定）安装到系统。 选项：  -l：安装具有转发锁定功能的软件包。-r：重新安装现有应用，保留其数据。-t：允许安装测试 APK。-i installer_package_name：指定安装程序软件包名称。-s：在共享的大容量存储（如 sdcard）上安装软件包。-f：在内部系统内存上安装软件包。-d：允许版本代码降级。-g：授予应用清单文件中列出的所有权限。  ","version":"Next","tagName":"h3"},{"title":"uninstall [options] package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#uninstall-options-package","content":" 从系统中卸载软件包。 选项：  -k：移除软件包后保留数据和缓存目录。  ","version":"Next","tagName":"h3"},{"title":"clear package​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#clear-package","content":" 删除与软件包关联的所有数据。  ","version":"Next","tagName":"h3"},{"title":"enable package_or_component​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#enable-package_or_component","content":" 启用给定软件包或组件（作为“package/class”写入）。  ","version":"Next","tagName":"h3"},{"title":"disable package_or_component​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#disable-package_or_component","content":" 停用给定软件包或组件（作为“package/class”写入）。  ","version":"Next","tagName":"h3"},{"title":"disable-user [options] package_or_component​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#disable-user-options-package_or_component","content":" 选项：  --user user_id：要停用的用户。  ","version":"Next","tagName":"h3"},{"title":"grant package_name permission​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#grant-package_name-permission","content":" 向应用授予权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。  ","version":"Next","tagName":"h3"},{"title":"revoke package_name permission​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#revoke-package_name-permission","content":" 从应用中撤销权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。  ","version":"Next","tagName":"h3"},{"title":"set-install-location location​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#set-install-location-location","content":" 更改默认安装位置。位置值：  0：自动—让系统决定最佳位置。1：内部—安装在内部设备存储上。2：外部—安装在外部介质上。  注：此命令仅用于调试目的；使用此命令会导致应用中断和其他意外行为。  ","version":"Next","tagName":"h3"},{"title":"get-install-location​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#get-install-location","content":" 返回当前安装位置。返回值：  0 [auto]：让系统决定最佳位置。1 [internal]：安装在内部设备存储上2 [external]：安装在外部介质上  ","version":"Next","tagName":"h3"},{"title":"set-permission-enforced permission [true|false]​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#set-permission-enforced-permission-truefalse","content":" 指定是否应强制执行给定的权限。  ","version":"Next","tagName":"h3"},{"title":"trim-caches desired_free_space​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#trim-caches-desired_free_space","content":" 减少缓存文件以达到给定的可用空间。  ","version":"Next","tagName":"h3"},{"title":"create-user user_name​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#create-user-user_name","content":" 使用给定的 user_name 创建新用户，输出新用户的标识符。  ","version":"Next","tagName":"h3"},{"title":"remove-user user_id​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#remove-user-user_id","content":" 移除具有给定的 user_id 的用户，删除与该用户关联的所有数据。  ","version":"Next","tagName":"h3"},{"title":"get-max-users​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#get-max-users","content":" 输出设备支持的最大用户数。  ","version":"Next","tagName":"h3"},{"title":"其他命令​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#其他命令","content":" ","version":"Next","tagName":"h2"},{"title":"进行屏幕截图​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#进行屏幕截图","content":" screencap 命令是一个用于对设备显示屏进行屏幕截图的 shell 实用程序。在 shell 中，此语法为：  screencap filename   例如：  shell(&quot;screencap /sdcard/screen.png&quot;);   ","version":"Next","tagName":"h3"},{"title":"列表文件​","type":1,"pageTitle":"shell 终端","url":"/docs/rhino/advanced/shell#列表文件","content":" ls filepath   例如:  log(shell(&quot;ls /system/bin&quot;).result);  ","version":"Next","tagName":"h3"},{"title":"Threads 多线程","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/threads","content":"","keywords":"","version":"Next"},{"title":"threads.start(action)​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsstartaction","content":" action {Function} 要在新线程执行的函数返回 Thread  启动一个新线程并执行 action。  例如:  threads.start(function () { //在新线程执行的代码 while (true) { log(&quot;子线程&quot;); } }); while (true) { log(&quot;脚本主线程&quot;); }   通过该函数返回的Thread对象可以获取该线程的状态，控制该线程的运行中。例如:  var thread = threads.start(function () { while (true) { log(&quot;子线程&quot;); } }); //停止线程执行 thread.interrupt();   更多信息参见Thread。  ","version":"Next","tagName":"h2"},{"title":"threads.shutDownAll()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsshutdownall","content":" 停止所有通过threads.start()启动的子线程。  ","version":"Next","tagName":"h2"},{"title":"threads.currentThread()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadscurrentthread","content":" 返回 Thread  返回当前线程。  ","version":"Next","tagName":"h2"},{"title":"threads.disposable()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsdisposable","content":" 返回 Disposable  新建一个 Disposable 对象，用于等待另一个线程的某个一次性结果。更多信息参见线程通信以及Disposable。  ","version":"Next","tagName":"h2"},{"title":"threads.atomic([initialValue])​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsatomicinitialvalue","content":" initialValue {number} 初始整数值，默认为 0返回AtomicLong  新建一个整数原子变量。更多信息参见线程安全以及AtomicLong。  ","version":"Next","tagName":"h2"},{"title":"threads.lock()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadslock","content":" 返回ReentrantLock  新建一个可重入锁。更多信息参见线程安全以及ReentrantLock。  Thread  线程对象，threads.start()返回的对象，用于获取和控制线程的状态，与其他线程交互等。  Thread 对象提供了和 timers 模块一样的 API，例如setTimeout(), setInterval()等，用于在该线程执行相应的定时回调，从而使线程之间可以直接交互。例如：  var thread = threads.start(function () { //在子线程执行的定时器 setInterval(function () { log(&quot;子线程:&quot; + threads.currentThread()); }, 1000); }); log(&quot;当前线程为主线程:&quot; + threads.currentThread()); //等待子线程启动 thread.waitFor(); //在子线程执行的定时器 thread.setTimeout(function () { //这段代码会在子线程执行 log(&quot;当前线程为子线程:&quot; + threads.currentThread()); }, 2000); sleep(30 * 1000); thread.interrupt();   ","version":"Next","tagName":"h2"},{"title":"Thread.interrupt()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadinterrupt","content":" 中断线程运行。  ","version":"Next","tagName":"h2"},{"title":"Thread.join([timeout])​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadjointimeout","content":" timeout {number} 等待时间，单位毫秒  等待线程执行完成。如果 timeout 为 0，则会一直等待直至该线程执行完成；否则最多等待 timeout 毫秒的时间。  例如:  var sum = 0; //启动子线程计算1加到10000 var thread = threads.start(function () { for (var i = 0; i &lt; 10000; i++) { sum += i; } }); //等待该线程完成 thread.join(); toast(&quot;sum = &quot; + sum);   ","version":"Next","tagName":"h2"},{"title":"Thread.isAlive()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadisalive","content":" 返回 {boolean}  返回线程是否存活。如果线程仍未开始或已经结束，返回false; 如果线程已经开始或者正在运行中，返回true。  ","version":"Next","tagName":"h2"},{"title":"Thread.waitFor()​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadwaitfor","content":" 等待线程开始执行。调用threads.start()以后线程仍然需要一定时间才能开始执行，因此调用此函数会等待线程开始执行；如果线程已经处于执行状态则立即返回。  var thread = threads.start(function () { //do something }); thread.waitFor(); thread.setTimeout(function () { //do something }, 1000);   ","version":"Next","tagName":"h2"},{"title":"Thread.setTimeout(callback, delay[, ...args])​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsettimeoutcallback-delay-args","content":" 参见timers.setTimeout。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  log(&quot;当前线程(主线程):&quot; + threads.currentThread()); var thread = threads.start(function () { //设置一个空的定时来保持线程的运行状态 setInterval(function () {}, 1000); }); sleep(1000); thread.setTimeout(function () { log(&quot;当前线程(子线程):&quot; + threads.currentThread()); exit(); }, 1000);   ","version":"Next","tagName":"h2"},{"title":"Thread.setInterval(callback, delay[, ...args])​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsetintervalcallback-delay-args","content":" 参见timers.setInterval()。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  ","version":"Next","tagName":"h2"},{"title":"Thread.setImmediate(callback[, ...args])​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadsetimmediatecallback-args","content":" 参见timers.setImmediate。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  ","version":"Next","tagName":"h2"},{"title":"Thread.clearInterval(id)​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadclearintervalid","content":" 参见timers.clearInterval()。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  ","version":"Next","tagName":"h2"},{"title":"Thread.clearTimeout(id)​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadcleartimeoutid","content":" 参见timers.clearTimeout()。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  ","version":"Next","tagName":"h2"},{"title":"Thread.clearImmediate(id)​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#threadclearimmediateid","content":" 参见timers.clearImmediate()。  区别在于, 该定时器会在该线程执行。如果当前线程仍未开始执行或已经执行结束，则抛出IllegalStateException。  线程安全  线程安全问题是一个相对专业的编程问题，本章节只提供给有需要的用户。  引用维基百科的解释：  线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。  在 Auto.js 中，线程间变量在符合 JavaScript 变量作用域规则的前提下是共享的，例如全局变量在所有线程都能访问，并且保证他们在所有线程的可见性。但是，不保证任何操作的原子性。例如经典的自增&quot;i++&quot;将不是原子性操作。  Rhino 和 Auto.js 提供了一些简单的设施来解决简单的线程安全问题，如锁threads.lock(), 函数同步锁sync(), 整数原子变量threads.atomic()等。  例如，对于多线程共享下的整数的自增操作(自增操作会导致问题，是因为自增操作实际上为i = i + 1，也就是先读取 i 的值, 把他加 1, 再赋值给 i, 如果两个线程同时进行自增操作，可能出现 i 的值只增加了 1 的情况)，应该使用threads.atomic()函数来新建一个整数原子变量，或者使用锁threads.lock()来保证操作的原子性，或者用sync()来增加同步锁。  线程不安全的代码如下：  var i = 0; threads.start(function () { while (true) { log(i++); } }); while (true) { log(i++); }   此段代码运行后打开日志，可以看到日志中有重复的值出现。  使用threads.atomic()的线程安全的代码如下:  //atomic返回的对象保证了自增的原子性 var i = threads.atomic(); threads.start(function () { while (true) { log(i.getAndIncrement()); } }); while (true) { log(i.getAndIncrement()); }   或者:  //锁保证了操作的原子性 var lock = threads.lock(); var i = 0; threads.start(function () { while (true) { lock.lock(); log(i++); lock.unlock(); } }); while (true) { lock.lock(); log(i++); lock.unlock(); }   或者:  //sync函数会把里面的函数加上同步锁，使得在同一时刻最多只能有一个线程执行这个函数 var i = 0; var getAndIncrement = sync(function () { return i++; }); threads.start(function () { while (true) { log(getAndIncrement()); } }); while (true) { log(getAndIncrement()); }   另外，数组 Array 不是线程安全的，如果有这种复杂的需求，请用 Android 和 Java 相关 API 来实现。例如CopyOnWriteList, Vector等都是代替数组的线程安全的类，用于不同的场景。例如:  var nums = new java.util.Vector(); nums.add(123); nums.add(456); toast(&quot;长度为&quot; + nums.size()); toast(&quot;第一个元素为&quot; + nums.get(0));   但很明显的是，这些类不像数组那样简便易用，也不能使用诸如slice()之类的方便的函数。在未来可能会加入线程安全的数组来解决这个问题。当然您也可以为每个数组的操作加锁来解决线程安全问题：  var nums = []; var numsLock = threads.lock(); threads.start(function () { //向数组添加元素123 numsLock.lock(); nums.push(123); log(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums); numsLock.unlock(); }); threads.start(function () { //向数组添加元素456 numsLock.lock(); nums.push(456); log(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums); numsLock.unlock(); }); //删除数组最后一个元素 numsLock.lock(); nums.pop(); log(&quot;线程: %s, 数组: %s&quot;, threads.currentThread(), nums); numsLock.unlock();   ","version":"Next","tagName":"h2"},{"title":"sync(func)​","type":1,"pageTitle":"Threads 多线程","url":"/docs/rhino/advanced/threads#syncfunc","content":" func {Function} 函数返回 {Function}  给函数 func 加上同步锁并作为一个新函数返回。  var i = 0; function add(x) { i += x; } var syncAdd = sync(add); syncAdd(10); toast(i);   线程通信  Auto.js 提供了一些简单的设施来支持简单的线程通信。threads.disposable()用于一个线程等待另一个线程的(一次性)结果，同时Lock.newCondition()提供了 Condition 对象用于一般的线程通信(await, signal)。另外，events模块也可以用于线程通信，通过指定EventEmiiter的回调执行的线程来实现。  使用threads.disposable()可以简单地等待和获取某个线程的执行结果。例如要等待某个线程计算&quot;1+.....+10000&quot;:  var sum = threads.disposable(); //启动子线程计算 threads.start(function () { var s = 0; //从1加到10000 for (var i = 1; i &lt;= 10000; i++) { s += i; } //通知主线程接收结果 sum.setAndNotify(s); }); //blockedGet()用于等待结果 toast(&quot;sum = &quot; + sum.blockedGet());   如果上述代码用Condition实现：  //新建一个锁 var lock = threads.lock(); //新建一个条件，即&quot;计算完成&quot; var complete = lock.newCondition(); var sum = 0; threads.start(function () { //从1加到10000 for (var i = 1; i &lt;= 10000; i++) { sum += i; } //通知主线程接收结果 lock.lock(); complete.signal(); lock.unlock(); }); //等待计算完成 lock.lock(); complete.await(); lock.unlock(); //打印结果 toast(&quot;sum = &quot; + sum);   如果上诉代码用events模块实现：  //新建一个emitter, 并指定回调执行的线程为当前线程 var sum = events.emitter(threads.currentThread()); threads.start(function () { var s = 0; //从1加到10000 for (var i = 1; i &lt;= 10000; i++) { s += i; } //发送事件result通知主线程接收结果 sum.emit(&quot;result&quot;, s); }); sum.on(&quot;result&quot;, function (s) { toastLog(&quot;sum = &quot; + s + &quot;, 当前线程: &quot; + threads.currentThread()); });   有关线程的其他问题，例如生产者消费者等问题，请用 Java 相关方法解决，例如java.util.concurrent.BlockingQueue。 ","version":"Next","tagName":"h2"},{"title":"Zips 压缩与解压","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/zips","content":"","keywords":"","version":"Next"},{"title":"压缩​","type":1,"pageTitle":"Zips 压缩与解压","url":"/docs/rhino/advanced/zips#压缩","content":" //压缩文件路径(必须是完整路径) var filePath = &quot;/sdcard/脚本.7z&quot;; //目录路径(必须是完整路径) var dirPath = &quot;/sdcard/脚本&quot;; //压缩类型 //支持的压缩类型包括: // zip 7z bz2 bzip2 tbz2 tbz gz gzip tgz tar wim swm xz txz。 var type = &quot;7z&quot;; //压缩密码 var password = &quot;password&quot;; //7z加密压缩(若文件已存在则跳过) //zips.A(type, filePath, dirPath, password) //压缩 switch (zips.A(type, filePath, dirPath)) { case 0: toastLog(&quot;压缩成功！文件已保存为： &quot; + filePath); break; case 1: toastLog(&quot;压缩结束，存在非致命错误（例如某些文件正在被使用，没有被压缩）&quot;); break; case 2: toastLog(&quot;致命错误&quot;); break; case 7: toastLog(&quot;命令行错误&quot;); break; case 8: toastLog(&quot;没有足够内存&quot;); break; case 255: toastLog(&quot;用户中止操作&quot;); break; default: toastLog(&quot;未知错误&quot;); }   ","version":"Next","tagName":"h2"},{"title":"解压​","type":1,"pageTitle":"Zips 压缩与解压","url":"/docs/rhino/advanced/zips#解压","content":" //压缩文件路径(必须是完整路径) var filePath = files.path(&quot;./bonus.rar&quot;); //目录路径(必须是完整路径) var dirPath = &quot;/sdcard/脚本&quot;; //压缩密码 var password = &quot;password&quot;; //支持的解压缩类型包括： // zip、7z、bz2、bzip2、tbz2、tbz、gz、gzip、tgz、tar、 // wim、swm、xz、txz以及rar、chm、iso、msi等众多格式。 //解压无加密的压缩包(若文件已存在则跳过) //zips.X(filePath, dirPath) //解压加密的压缩包(若文件已存在则跳过) switch (zips.X(filePath, dirPath, password)) { case 0: toastLog(&quot;解压缩成功！请到 &quot; + dirPath + &quot; 目录下查看。&quot;); break; case 1: toastLog(&quot;压缩结束，存在非致命错误（例如某些文件正在被使用，没有被压缩）&quot;); break; case 2: toastLog(&quot;致命错误&quot;); break; case 7: toastLog(&quot;命令行错误&quot;); break; case 8: toastLog(&quot;没有足够内存&quot;); break; case 255: toastLog(&quot;用户中止操作&quot;); break; default: toastLog(&quot;未知错误&quot;); }  ","version":"Next","tagName":"h2"},{"title":"基于坐标的触摸模拟","type":0,"sectionRef":"#","url":"/docs/rhino/base/coordinatesBasedAutomation","content":"","keywords":"","version":"Next"},{"title":"setScreenMetrics(width, height)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#setscreenmetricswidth-height","content":" width {number} 屏幕宽度，单位像素height {number} 屏幕高度，单位像素  设置脚本坐标点击所适合的屏幕宽高。如果脚本运行时，屏幕宽度不一致会自动放缩坐标。  例如在 1920*1080 的设备中，某个操作的代码为  setScreenMetrics(1080, 1920); click(800, 200); longClick(300, 500);   那么在其他设备上 AutoJs 会自动放缩坐标以便脚本仍然有效。例如在 540 * 960 的屏幕中click(800, 200)实际上会点击位置(400, 100)。  安卓 7.0 以上的触摸和手势模拟  稳定性: 稳定  注意以下命令只有 Android7.0 及以上才有效  ","version":"Next","tagName":"h2"},{"title":"click(x, y)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#clickx-y","content":" x {number} 要点击的坐标的 x 值y {number} 要点击的坐标的 y 值  模拟点击坐标(x, y)，并返回是否点击成功。只有在点击执行完成后脚本才继续执行。  一般而言，只有点击过程(大约 150 毫秒)中被其他事件中断(例如用户自行点击)才会点击失败。  使用该函数模拟连续点击时可能有点击速度过慢的问题，这时可以用press()函数代替。  ","version":"Next","tagName":"h2"},{"title":"longClick(x, y)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#longclickx-y","content":" x {number} 要长按的坐标的 x 值y {number} 要长按的坐标的 y 值  模拟长按坐标(x, y), 并返回是否成功。只有在长按执行完成（大约 600 毫秒）时脚本才会继续执行。  一般而言，只有长按过程中被其他事件中断(例如用户自行点击)才会长按失败。  ","version":"Next","tagName":"h2"},{"title":"press(x, y, duration)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#pressx-y-duration","content":" x {number} 要按住的坐标的 x 值y {number} 要按住的坐标的 y 值duration {number} 按住时长，单位毫秒  模拟按住坐标(x, y), 并返回是否成功。只有按住操作执行完成时脚本才会继续执行。  如果按住时间过短，那么会被系统认为是点击；如果时长超过 500 毫秒，则认为是长按。  一般而言，只有按住过程中被其他事件中断才会操作失败。  一个连点器的例子如下：  //循环100次 for (var i = 0; i &lt; 100; i++) { //点击位置(500, 1000), 每次用时1毫秒 press(500, 1000, 1); }   ","version":"Next","tagName":"h2"},{"title":"swipe(x1, y1, x2, y2, duration)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#swipex1-y1-x2-y2-duration","content":" x1 {number} 滑动的起始坐标的 x 值y1 {number} 滑动的起始坐标的 y 值x2 {number} 滑动的结束坐标的 x 值y2 {number} 滑动的结束坐标的 y 值duration {number} 滑动时长，单位毫秒  模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。  一般而言，只有滑动过程中被其他事件中断才会滑动失败。  ","version":"Next","tagName":"h2"},{"title":"gesture(duration, [x1, y1], [x2, y2], ...)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#gestureduration-x1-y1-x2-y2-","content":" duration {number} 手势的时长[x, y] ... 手势滑动路径的一系列坐标  模拟手势操作。例如gesture(1000, [0, 0], [500, 500], [500, 1000])为模拟一个从(0, 0)到(500, 500)到(500, 100)的手势操作，时长为 2 秒。  ","version":"Next","tagName":"h2"},{"title":"gestures([delay1, duration1, [x1, y1], [x2, y2], ...], [delay2, duration2, [x3, y3], [x4, y4], ...], ...)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#gesturesdelay1-duration1-x1-y1-x2-y2--delay2-duration2-x3-y3-x4-y4--","content":" 同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay 为延迟多久(毫秒)才执行该手势；duration 为手势执行时长；坐标为手势经过的点的坐标。其中 delay 参数可以省略，默认为 0。  例如手指捏合：  gestures([0, 500, [800, 300], [500, 1000]], [0, 500, [300, 1500], [500, 1000]]);   RootAutomator  稳定性: 稳定  RootAutomator 是一个使用 root 权限来模拟触摸的对象，用它可以完成触摸与多点触摸，并且这些动作的执行没有延迟。  一个脚本中最好只存在一个 RootAutomator，并且保证脚本结束退出他。可以在 exit 事件中退出 RootAutomator，例如：  var ra = new RootAutomator(); events.on('exit', function(){ ra.exit(); }); //执行一些点击操作 ...   注意以下命令需要 root 权限  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.tap(x, y[, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatortapx-y-id","content":" x {number} 横坐标y {number} 纵坐标id {number} 多点触摸 id，可选，默认为 1，可以通过 setDefaultId 指定。  点击位置(x, y)。其中 id 是一个整数值，用于区分多点触摸，不同的 id 表示不同的&quot;手指&quot;，例如：  var ra = new RootAutomator(); //让&quot;手指1&quot;点击位置(100, 100) ra.tap(100, 100, 1); //让&quot;手指2&quot;点击位置(200, 200); ra.tap(200, 200, 2); ra.exit();   如果不需要多点触摸，则不需要 id 这个参数。 多点触摸通常用于手势或游戏操作，例如模拟双指捏合、双指上滑等。  某些情况下可能存在 tap 点击无反应的情况，这时可以用RootAutomator.press()函数代替。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.swipe(x1, x2, y1, y2[, duration, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatorswipex1-x2-y1-y2-duration-id","content":" x1 {number} 滑动起点横坐标y1 {number} 滑动起点纵坐标x2 {number} 滑动终点横坐标y2 {number} 滑动终点纵坐标duration {number} 滑动时长，单位毫秒，默认值为 300id {number} 多点触摸 id，可选，默认为 1  模拟一次从(x1, y1)到(x2, y2)的时间为 duration 毫秒的滑动。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.press(x, y, duration[, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatorpressx-y-duration-id","content":" x {number} 横坐标y {number} 纵坐标duration {number} 按下时长id {number} 多点触摸 id，可选，默认为 1  模拟按下位置(x, y)，时长为 duration 毫秒。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.longPress(x, y[, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatorlongpressx-y-id","content":" x {number} 横坐标y {number} 纵坐标duration {number} 按下时长id {number} 多点触摸 id，可选，默认为 1  模拟长按位置(x, y)。  以上为简单模拟触摸操作的函数。如果要模拟一些复杂的手势，需要更底层的函数。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.touchDown(x, y[, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatortouchdownx-y-id","content":" x {number} 横坐标y {number} 纵坐标id {number} 多点触摸 id，可选，默认为 1  模拟手指按下位置(x, y)。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.touchMove(x, y[, id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatortouchmovex-y-id","content":" x {number} 横坐标y {number} 纵坐标id {number} 多点触摸 id，可选，默认为 1  模拟移动手指到位置(x, y)。  ","version":"Next","tagName":"h2"},{"title":"RootAutomator.touchUp([id])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#rootautomatortouchupid","content":" id {number} 多点触摸 id，可选，默认为 1  模拟手指弹起。  使用 root 权限点击和滑动的简单命令  稳定性: 实验  注意：本章节的函数在后续版本很可能有改动！请勿过分依赖本章节函数的副作用。推荐使用RootAutomator代替本章节的触摸函数。  以下函数均需要 root 权限，可以实现任意位置的点击、滑动等。  这些函数通常首字母大写以表示其特殊的权限。这些函数均不返回任何值。并且，这些函数的执行是异步的、非阻塞的，在不同机型上所用的时间不同。脚本不会等待动作执行完成才继续执行。因此最好在每个函数之后加上适当的 sleep 来达到期望的效果。  例如:  Tap(100, 100); sleep(500);   注意，动作的执行可能无法被停止，例如：  for (var i = 0; i &lt; 100; i++) { Tap(100, 100); }   这段代码执行后可能会出现在任务管理中停止脚本后点击仍然继续的情况。 因此，强烈建议在每个动作后加上延时：  for (var i = 0; i &lt; 100; i++) { Tap(100, 100); sleep(500); }   ","version":"Next","tagName":"h2"},{"title":"Tap(x, y)​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#tapx-y","content":" x, y {number} 要点击的坐标。  点击位置(x, y), 您可以通过&quot;开发者选项&quot;开启指针位置来确定点击坐标。  ","version":"Next","tagName":"h2"},{"title":"Swipe(x1, y1, x2, y2, [duration])​","type":1,"pageTitle":"基于坐标的触摸模拟","url":"/docs/rhino/base/coordinatesBasedAutomation#swipex1-y1-x2-y2-duration-1","content":" x1, y1 {number} 滑动起点的坐标x2, y2 {number} 滑动终点的坐标duration {number} 滑动动作所用的时间  滑动。从(x1, y1)位置滑动到(x2, y2)位置。 ","version":"Next","tagName":"h2"},{"title":"Device 设备","type":0,"sectionRef":"#","url":"/docs/rhino/base/device","content":"","keywords":"","version":"Next"},{"title":"device.width​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicewidth","content":" {number}  设备屏幕分辨率宽度。例如 1080。  ","version":"Next","tagName":"h2"},{"title":"device.height​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceheight","content":" {number}  设备屏幕分辨率高度。例如 1920。  ","version":"Next","tagName":"h2"},{"title":"device.buildId​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicebuildid","content":" {string}  Either a changelist number, or a label like &quot;M4-rc20&quot;.  修订版本号，或者诸如&quot;M4-rc20&quot;的标识。  ","version":"Next","tagName":"h2"},{"title":"device.broad​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicebroad","content":" {string}  The name of the underlying board, like &quot;goldfish&quot;.  设备的主板(?)型号。  ","version":"Next","tagName":"h2"},{"title":"device.brand​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicebrand","content":" {string}  The consumer-visible brand with which the product/hardware will be associated, if any.  与产品或硬件相关的厂商品牌，如&quot;Xiaomi&quot;, &quot;Huawei&quot;等。  ","version":"Next","tagName":"h2"},{"title":"device.device​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicedevice","content":" {string}  The name of the industrial design.  设备在工业设计中的名称。  ","version":"Next","tagName":"h2"},{"title":"device.model​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicemodel","content":" {string}  The end-user-visible name for the end product.  设备型号。  ","version":"Next","tagName":"h2"},{"title":"device.product​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceproduct","content":" {string}  The name of the overall product.  整个产品的名称。  ","version":"Next","tagName":"h2"},{"title":"device.bootloader​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicebootloader","content":" {string}  The system bootloader version number.  设备 Bootloader 的版本。  ","version":"Next","tagName":"h2"},{"title":"device.hardware​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicehardware","content":" {string}  The name of the hardware (from the kernel command line or /proc).  设备的硬件名称(来自内核命令行或者/proc)。  ","version":"Next","tagName":"h2"},{"title":"device.fingerprint​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicefingerprint","content":" {string}  A string that uniquely identifies this build. Do not attempt to parse this value.  构建(build)的唯一标识码。  ","version":"Next","tagName":"h2"},{"title":"device.serial​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceserial","content":" {string}  A hardware serial number, if available. Alphanumeric only, case-insensitive.  硬件序列号。  ","version":"Next","tagName":"h2"},{"title":"device.sdkInt​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesdkint","content":" {number}  The user-visible SDK version of the framework; its possible values are defined in Build.VERSION_CODES.  安卓系统 API 版本。例如安卓 4.4 的 sdkInt 为 19。  ","version":"Next","tagName":"h2"},{"title":"device.incremental​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceincremental","content":" {string}  The internal value used by the underlying source control to represent this build. E.g., a perforce changelist number or a git hash.  ","version":"Next","tagName":"h2"},{"title":"device.release​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicerelease","content":" {string}  The user-visible version string. E.g., &quot;1.0&quot; or &quot;3.4b5&quot;.  Android 系统版本号。例如&quot;5.0&quot;, &quot;7.1.1&quot;。  ","version":"Next","tagName":"h2"},{"title":"device.baseOS​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicebaseos","content":" {string}  The base OS build the product is based on.  ","version":"Next","tagName":"h2"},{"title":"device.securityPatch​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesecuritypatch","content":" {string}  The user-visible security patch level.  安全补丁程序级别。  ","version":"Next","tagName":"h2"},{"title":"device.codename​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicecodename","content":" {string}  The current development codename, or the string &quot;REL&quot; if this is a release build.  开发代号，例如发行版是&quot;REL&quot;。  ","version":"Next","tagName":"h2"},{"title":"device.getIMEI()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetimei","content":" {string}  返回设备的 IMEI.  ","version":"Next","tagName":"h2"},{"title":"device.getAndroidId()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetandroidid","content":" {string}  返回设备的 Android ID。  Android ID 为一个用 16 进制字符串表示的 64 位整数，在设备第一次使用时随机生成，之后不会更改，除非恢复出厂设置。  ","version":"Next","tagName":"h2"},{"title":"device.getMacAddress()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetmacaddress","content":" {string}  返回设备的 Mac 地址。该函数需要在有 WLAN 连接的情况下才能获取，否则会返回 null。  可能的后续修改：未来可能增加有 root 权限的情况下通过 root 权限获取，从而在没有 WLAN 连接的情况下也能返回正确的 Mac 地址，因此请勿使用此函数判断 WLAN 连接。  ","version":"Next","tagName":"h2"},{"title":"device.getBrightness()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetbrightness","content":" {number}  返回当前的(手动)亮度。范围为 0~255。  ","version":"Next","tagName":"h2"},{"title":"device.getBrightnessMode()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetbrightnessmode","content":" {number}  返回当前亮度模式，0 为手动亮度，1 为自动亮度。  ","version":"Next","tagName":"h2"},{"title":"device.setBrightness(b)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesetbrightnessb","content":" b {number} 亮度，范围 0~255  设置当前手动亮度。如果当前是自动亮度模式，该函数不会影响屏幕的亮度。  此函数需要&quot;修改系统设置&quot;的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。  ","version":"Next","tagName":"h2"},{"title":"device.setBrightnessMode(mode)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesetbrightnessmodemode","content":" mode {number} 亮度模式，0 为手动亮度，1 为自动亮度  设置当前亮度模式。  此函数需要&quot;修改系统设置&quot;的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。  ","version":"Next","tagName":"h2"},{"title":"device.getMusicVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetmusicvolume","content":" {number} 整数值  返回当前媒体音量。  ","version":"Next","tagName":"h2"},{"title":"device.getNotificationVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetnotificationvolume","content":" {number} 整数值  返回当前通知音量。  ","version":"Next","tagName":"h2"},{"title":"device.getAlarmVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetalarmvolume","content":" {number} 整数值  返回当前闹钟音量。  ","version":"Next","tagName":"h2"},{"title":"device.getMusicMaxVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetmusicmaxvolume","content":" {number} 整数值  返回媒体音量的最大值。  ","version":"Next","tagName":"h2"},{"title":"device.getNotificationMaxVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetnotificationmaxvolume","content":" {number} 整数值  返回通知音量的最大值。  ","version":"Next","tagName":"h2"},{"title":"device.getAlarmMaxVolume()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetalarmmaxvolume","content":" {number} 整数值  返回闹钟音量的最大值。  ","version":"Next","tagName":"h2"},{"title":"device.setMusicVolume(volume)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesetmusicvolumevolume","content":" volume {number} 音量  设置当前媒体音量。  此函数需要&quot;修改系统设置&quot;的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。  ","version":"Next","tagName":"h2"},{"title":"device.setNotificationVolume(volume)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesetnotificationvolumevolume","content":" volume {number} 音量  设置当前通知音量。  此函数需要&quot;修改系统设置&quot;的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。  ","version":"Next","tagName":"h2"},{"title":"device.setAlarmVolume(volume)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicesetalarmvolumevolume","content":" volume {number} 音量  设置当前闹钟音量。  此函数需要&quot;修改系统设置&quot;的权限。如果没有该权限，会抛出 SecurityException 并跳转到权限设置界面。  ","version":"Next","tagName":"h2"},{"title":"device.getBattery()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetbattery","content":" {number} 0.0~100.0 的浮点数  返回当前电量百分比。  ","version":"Next","tagName":"h2"},{"title":"device.isCharging()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceischarging","content":" {boolean}  返回设备是否正在充电。  ","version":"Next","tagName":"h2"},{"title":"device.getTotalMem()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegettotalmem","content":" {number}  返回设备内存总量，单位字节(B)。1MB = 1024 * 1024B。  ","version":"Next","tagName":"h2"},{"title":"device.getAvailMem()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetavailmem","content":" {number}  返回设备当前可用的内存，单位字节(B)。  ","version":"Next","tagName":"h2"},{"title":"device.isScreenOn()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#deviceisscreenon","content":" 返回 {boolean}  返回设备屏幕是否是亮着的。如果屏幕亮着，返回true; 否则返回false。  需要注意的是，类似于 vivo xplay 系列的息屏时钟不属于&quot;屏幕亮着&quot;的情况，虽然屏幕确实亮着但只能显示时钟而且不可交互，此时isScreenOn()也会返回false。  ","version":"Next","tagName":"h2"},{"title":"device.wakeUp()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicewakeup","content":" 唤醒设备。包括唤醒设备 CPU、屏幕等。可以用来点亮屏幕。  ","version":"Next","tagName":"h2"},{"title":"device.wakeUpIfNeeded()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicewakeupifneeded","content":" 如果屏幕没有点亮，则唤醒设备。  ","version":"Next","tagName":"h2"},{"title":"device.keepScreenOn([timeout])​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicekeepscreenontimeout","content":" timeout {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。  保持屏幕常亮。  此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。  在某些设备上，如果不加参数 timeout，只能在 Auto.js 的界面保持屏幕常亮，在其他界面会自动失效，这是因为设备的省电策略造成的。因此，建议使用比较长的时长来代替&quot;一直保持屏幕常亮&quot;的功能，例如device.keepScreenOn(3600 * 1000)。  可以使用device.cancelKeepingAwake()来取消屏幕常亮。  //一直保持屏幕常亮 device.keepScreenOn()   ","version":"Next","tagName":"h2"},{"title":"device.keepScreenDim([timeout])​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicekeepscreendimtimeout","content":" timeout {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。  保持屏幕常亮，但允许屏幕变暗来节省电量。此函数可以用于定时脚本唤醒屏幕操作，不需要用户观看屏幕，可以让屏幕变暗来节省电量。  此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。  可以使用device.cancelKeepingAwake()来取消屏幕常亮。  ","version":"Next","tagName":"h2"},{"title":"device.cancelKeepingAwake()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicecancelkeepingawake","content":" 取消设备保持唤醒状态。用于取消device.keepScreenOn(), device.keepScreenDim()等函数设置的屏幕常亮。  ","version":"Next","tagName":"h2"},{"title":"device.vibrate(millis)​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicevibratemillis","content":" millis {number} 震动时间，单位毫秒  使设备震动一段时间。  //震动两秒 device.vibrate(2000);   ","version":"Next","tagName":"h2"},{"title":"device.cancelVibration()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicecancelvibration","content":" [v4.2.7 新增]如果设备处于震动状态，则取消震动。  ","version":"Next","tagName":"h2"},{"title":"device.checkDeviceHasNavigationBar()​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicecheckdevicehasnavigationbar","content":" [v4.2.7 新增]  {boolean} 返回 true|false 设备是否存储虚拟导航栏  ","version":"Next","tagName":"h2"},{"title":"device.getVirtualBarHeigh();​","type":1,"pageTitle":"Device 设备","url":"/docs/rhino/base/device#devicegetvirtualbarheigh","content":" [v4.2.7 新增]  {number} 返回导航栏的高度 设备虚拟导航栏的高度,可以用设备高度 减去 这个高度，再按一定比例 点击底部附件的坐标 ","version":"Next","tagName":"h2"},{"title":"WebView 与 HTML","type":0,"sectionRef":"#","url":"/docs/rhino/advanced/webViewAndHtml","content":"","keywords":"","version":"Next"},{"title":"*JsBridge​","type":1,"pageTitle":"WebView 与 HTML","url":"/docs/rhino/advanced/webViewAndHtml#jsbridge","content":" v6.3.9新增 html&gt;&gt;  &lt;html&gt; &lt;body style=&quot;font: size 2em&quot;&gt; &lt;div style=&quot;font-size: 100px&quot;&gt;原内容&lt;/div&gt; &lt;!-- 导入依赖包，也可以不加，不过需要监听AutoxJsBridgeReady事件后才能使用$autox --&gt; &lt;script src=&quot;autox://sdk.v1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function addText(text) { const div = document.createElement(&quot;div&quot;); div.innerHTML = text; document.body.appendChild(div); } //注册一个监听函数 $autox.registerHandler(&quot;jsTest&quot;, (data, callBack) =&gt; { addText(`来自安卓调用，data=${data}`); setTimeout(() =&gt; { //回调安卓 callBack(&quot;web回调数据&quot;); }, 1000); }); //调用安卓端 $autox.callHandler(&quot;test&quot;, &quot;web调用数据&quot;, (data) =&gt; { addText(&quot;安卓回调, data:&quot; + data); }); document.addEventListener(&quot;AutoxJsBridgeReady&quot;, () =&gt; { //$autox. }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   js代码  &quot;ui&quot;; ui.layout(` &lt;vertical&gt; &lt;webview id=&quot;web&quot; h=&quot;*&quot;/&gt; &lt;/vertical&gt;`) ui.web.loadUrl(&quot;file://&quot; + files.path(&quot;./网页.html&quot;)) /* 注意：在web与安卓端传递的数据只能是字符串，其他数据需自行使用JSON序列化 在调用callHandler时传入了回调函数，但web端没有调用则会造成内存泄露。 jsBridge自动注入依赖于webViewClient，如设置了自定义webViewClient则需要在合适的时机（页面加载完成后）调用webview.injectionJsBridge()手动注入 */ //注册一个监听函数 ui.web.jsBridge.registerHandler(&quot;test&quot;, (data, callBack) =&gt; { toastLog(&quot;web调用安卓,data:&quot; + data) setTimeout(() =&gt; { //回调web callBack(&quot;1155&quot;) }, 2000) }) //定时器中等待web加载完成 setTimeout(() =&gt; { ui.web.jsBridge.callHandler('jsTest', '数据', (data) =&gt; { toastLog('web回调,data:' + data) }) }, 1000)   ","version":"Next","tagName":"h2"},{"title":"纯js实现​","type":1,"pageTitle":"WebView 与 HTML","url":"/docs/rhino/advanced/webViewAndHtml#纯js实现","content":" &quot;ui&quot;; ui.layout( &lt;vertical&gt; &lt;horizontal bg=&quot;#c7edcc&quot; gravity=&quot;center&quot; h=&quot;auto&quot;&gt; &lt;button text=&quot;网络冲浪&quot; id=&quot;surfInternetBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt; &lt;button text=&quot;记忆翻牌&quot; id=&quot;loadLocalHtmlBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt; &lt;button text=&quot;控制台&quot; id=&quot;consoleBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt; &lt;/horizontal&gt; &lt;vertical h=&quot;*&quot; w=&quot;*&quot;&gt; &lt;webview id=&quot;webView&quot; layout_below=&quot;title&quot; w=&quot;*&quot; h=&quot;*&quot; /&gt; &lt;/vertical&gt; &lt;/vertical&gt; ); function callJavaScript(webViewWidget, script, callback) { try { console.assert(webViewWidget != null, &quot;webView控件为空&quot;); //console.log(script.toString()) webViewWidget.evaluateJavascript(&quot;javascript:&quot; + script, new JavaAdapter(android.webkit.ValueCallback, { onReceiveValue: (val) =&gt; { if (callback) { callback(val); } } })); } catch (e) { console.error(&quot;执行JavaScript失败&quot;); console.trace(e); } } function AutoX() { let getAutoXFrame = () =&gt; { let bridgeFrame = document.getElementById(&quot;AutoXFrame&quot;); if (!bridgeFrame) { bridgeFrame = document.createElement('iframe'); bridgeFrame.id = &quot;AutoXFrame&quot;; bridgeFrame.style = &quot;display: none&quot;; document.body.append(bridgeFrame); } return bridgeFrame; }; const h5Callbackers = {}; let h5CallbackIndex = 1; let setCallback = (callback) =&gt; { let callId = h5CallbackIndex++; h5Callbackers[callId] = { &quot;callback&quot;: callback }; return callId; }; let getCallback = (callId) =&gt; { let callback = h5Callbackers[callId]; if (callback) { delete h5Callbackers[callId]; } return callback; }; function invoke(cmd, params, callback) { let callId = null; try { let paramsStr = JSON.stringify(params); let AutoXFrame = getAutoXFrame(); callId = setCallback(callback); AutoXFrame.src = &quot;jsbridge://&quot; + cmd + &quot;/&quot; + callId + &quot;/&quot; + encodeURIComponent(paramsStr); } catch (e) { if (callId) { getCallback(callId); } console.trace(e); } }; let callback = (data) =&gt; { let callId = data.callId; let params = data.params; let callbackFun = getCallback(callId); if (callbackFun) { callbackFun.callback(params); } }; return { invoke: invoke, callback: callback }; }; function bridgeHandler_handle(cmd, params) { console.log('bridgeHandler处理 cmd=%s, params=%s', cmd, JSON.stringify(params)); let fun = this[cmd]; if (!fun) { throw new Error(&quot;cmd= &quot; + cmd + &quot; 没有定义实现&quot;); } let ret = fun(params) return ret; } function mFunction(params) { toastLog(params.toString()); device.vibrate(120); return files.isDir('/storage/emulated/0/Download')//'toast提示成功'; } function webViewExpand_init(webViewWidget) { webViewWidget.webViewClient = new JavaAdapter(android.webkit.WebViewClient, { onPageFinished: (webView, curUrl) =&gt; { try { // 注入 AutoX callJavaScript(webView, AutoX.toString() + &quot;;var auto0 = AutoX();auto0.invoke('mFunction','This is AutoX!',(data) =&gt; {console.log('接收到callback1:' + JSON.stringify(data));});&quot;, null); } catch (e) { console.trace(e) } }, shouldOverrideUrlLoading: (webView, request) =&gt; { let url = ''; try { url = (request.a &amp;&amp; request.a.a) || (request.url); if (url instanceof android.net.Uri) { url = url.toString(); } if (url.indexOf(&quot;jsbridge://&quot;) == 0) { let uris = url.split(&quot;/&quot;); let cmd = uris[2]; let callId = uris[3]; let params = java.net.URLDecoder.decode(uris[4], &quot;UTF-8&quot;); console.log('AutoX处理JavaScript调用请求: callId=%s, cmd=%s, params=%s', callId, cmd, params); let result = null; try { result = bridgeHandler_handle(cmd, JSON.parse(params)); } catch (e) { console.trace(e); result = { message: e.message }; } result = result || {}; webView.loadUrl(&quot;javascript:auto0.callback({'callId':&quot; + callId + &quot;, 'params': &quot; + JSON.stringify(result) + &quot;});&quot;); } else if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;) || url.startsWith(&quot;file://&quot;) || url.startsWith(&quot;ws://&quot;) || url.startsWith(&quot;wss://&quot;)) { webView.loadUrl(url); } else { } return true; } catch (e) { if (e.javaException instanceof android.content.ActivityNotFoundException) { webView.loadUrl(url); } else { toastLog('无法打开URL: ' + url); } console.trace(e); } }, onReceivedError: (webView, webResourceRequest, webResourceError) =&gt; { let url = webResourceRequest.getUrl(); let errorCode = webResourceError.getErrorCode(); let description = webResourceError.getDescription(); console.trace(errorCode + &quot; &quot; + description + &quot; &quot; + url); } }); webViewWidget.webChromeClient = new JavaAdapter(android.webkit.WebChromeClient, { onConsoleMessage: (msg) =&gt; { console.log(&quot;[%s:%s]: %s&quot;, msg.sourceId(), msg.lineNumber(), msg.message()); } }); } webViewExpand_init(ui.webView) ui.webView.loadUrl(&quot;https://wht.im&quot;); ui.surfInternetBtn.on(&quot;click&quot;, () =&gt; { webViewExpand_init(ui.webView); ui.webView.loadUrl(&quot;https://wht.im&quot;); }); ui.consoleBtn.on(&quot;click&quot;, () =&gt; { app.startActivity(&quot;console&quot;); }); ui.loadLocalHtmlBtn.on('click', () =&gt; { webViewExpand_init(ui.webView); let path = &quot;file:&quot; + files.path(&quot;game.html&quot;); ui.webView.loadUrl(path); });  ","version":"Next","tagName":"h2"},{"title":"APP 应用","type":0,"sectionRef":"#","url":"/docs/rhino/base/app","content":"","keywords":"","version":"Next"},{"title":"app.versionCode​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appversioncode","content":" return {number}  当前软件版本号，整数值。例如 160, 256 等。  如果在 Auto.js 中运行则为 Auto.js 的版本号；在打包的软件中则为打包软件的版本号。  toastLog(app.versionCode);   ","version":"Next","tagName":"h2"},{"title":"app.versionName​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appversionname","content":" return {string}  当前软件的版本名称，例如&quot;3.0.0 Beta&quot;。  如果在 Auto.js 中运行则为 Auto.js 的版本名称；在打包的软件中则为打包软件的版本名称。  toastLog(app.verionName);   ","version":"Next","tagName":"h2"},{"title":"app.autojs.versionCode​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appautojsversioncode","content":" return {number}  Auto.js 版本号，整数值。例如 160, 256 等。  ","version":"Next","tagName":"h2"},{"title":"app.autojs.versionName​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appautojsversionname","content":" return {string}  Auto.js 版本名称，例如&quot;3.0.0 Beta&quot;。  ","version":"Next","tagName":"h2"},{"title":"app.launchApp(appName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#applaunchappappname","content":" appName {string} 应用名称  通过应用名称启动应用。如果该名称对应的应用不存在，则返回 false; 否则返回 true。如果该名称对应多个应用，则只启动其中某一个。  该函数也可以作为全局函数使用。  launchApp(&quot;Auto.js&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.launch(packageName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#applaunchpackagename","content":" packageName {string} 应用包名  通过应用包名启动应用。如果该包名对应的应用不存在，则返回 false；否则返回 true。  该函数也可以作为全局函数使用。  //启动微信 launch(&quot;com.tencent.mm&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.launchPackage(packageName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#applaunchpackagepackagename","content":" packageName {string} 应用包名  相当于app.launch(packageName)。  ","version":"Next","tagName":"h2"},{"title":"app.getPackageName(appName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appgetpackagenameappname","content":" appName {string} 应用名称  获取应用名称对应的已安装的应用的包名，如果该找不到该应用，返回 null 。如果该名称对应多个应用，则只返回其中某一个的包名。  该函数也可以作为全局函数使用。  var name = getPackageName(&quot;QQ&quot;); //返回&quot;com.tencent.mobileqq&quot;   ","version":"Next","tagName":"h2"},{"title":"app.getAppName(packageName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appgetappnamepackagename","content":" packageName {string} 应用包名  获取应用包名对应的已安装的应用的名称。如果该找不到该应用，返回 null。  该函数也可以作为全局函数使用。  var name = getAppName(&quot;com.tencent.mobileqq&quot;); //返回&quot;QQ&quot;   ","version":"Next","tagName":"h2"},{"title":"app.openAppSetting(packageName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appopenappsettingpackagename","content":" packageName {string} 应用包名return {Boolean}  打开应用的详情页(设置页)。如果找不到该应用，返回 false; 否则返回 true。  该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"app.viewFile(path)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appviewfilepath","content":" path {string} 文件路径  用其他应用查看文件。文件不存在的情况由查看文件的应用处理。  如果找不出可以查看该文件的应用，则抛出ActivityNotException。  //查看文本文件 app.viewFile(&quot;/sdcard/1.txt&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.editFile(path)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appeditfilepath","content":" path {string} 文件路径  用其他应用编辑文件。文件不存在的情况由编辑文件的应用处理。  如果找不出可以编辑该文件的应用，则抛出ActivityNotException。  //编辑文本文件 app.editFile(&quot;/sdcard/1.txt/&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.uninstall(packageName)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appuninstallpackagename","content":" packageName {string} 应用包名  卸载应用。执行后会会弹出卸载应用的提示框。如果该包名的应用未安装，由应用卸载程序处理，可能弹出&quot;未找到应用&quot;的提示。  //卸载QQ app.uninstall(&quot;com.tencent.mobileqq&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.openUrl(url)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appopenurlurl","content":" url {string} 网站的 Url，如果不以&quot;http://&quot;或&quot;https://&quot;开头则默认是&quot;http://&quot;。  用浏览器打开网站 url。  如果没有安装浏览器应用，则抛出ActivityNotException。  ","version":"Next","tagName":"h2"},{"title":"app.sendEmail(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appsendemailoptions","content":" options {Object} 发送邮件的参数。包括: email {string} | {Array} 收件人的邮件地址。如果有多个收件人，则用字符串数组表示cc {string} | {Array} 抄送收件人的邮件地址。如果有多个抄送收件人，则用字符串数组表示bcc {string} | {Array} 密送收件人的邮件地址。如果有多个密送收件人，则用字符串数组表示subject {string} 邮件主题(标题)text {string} 邮件正文attachment {string} 附件的路径。  根据选项options调用邮箱应用发送邮件。这些选项均是可选的。  如果没有安装邮箱应用，则抛出ActivityNotException。  //发送邮件给10086@qq.com和10001@qq.com。 app.sendEmail({ email: [&quot;10086@qq.com&quot;, &quot;10001@qq.com&quot;], subject: &quot;这是一个邮件标题&quot;, text: &quot;这是邮件正文&quot;, });   ","version":"Next","tagName":"h2"},{"title":"app.startActivity(name)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appstartactivityname","content":" name {string} 活动名称，可选的值为: console 日志界面settings 设置界面  启动 Auto.js 的特定界面。该函数在 Auto.js 内运行则会打开 Auto.js 内的界面，在打包应用中运行则会打开打包应用的相应界面。  app.startActivity(&quot;console&quot;);   进阶: 意图 Intent  Intent(意图) 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：  启动活动(Activity)： Activity 表示应用中的一个&quot;屏幕&quot;。例如应用主入口都是一个 Activity，应用的功能通常也以 Activity 的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同的 Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。 启动服务(Service)： Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。 传递广播： 广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。  本模块提供了构建 Intent 的函数(app.intent()), 启动 Activity 的函数app.startActivity(), 发送广播的函数app.sendBroadcast()。  使用这些方法可以用来方便的调用其他应用。例如直接打开某个 QQ 号的个人卡片页，打开某个 QQ 号的聊天窗口等。  var qq = &quot;2732014414&quot;; app.startActivity({ action: &quot;android.intent.action.VIEW&quot;, data: &quot;mqq://im/chat?chat_type=wpa&amp;version=1&amp;src_type=web&amp;uin=&quot; + qq, packageName: &quot;com.tencent.mobileqq&quot;, });   ","version":"Next","tagName":"h2"},{"title":"app.intent(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appintentoptions","content":" [v4.1.0 新增]  options {Object} 选项，包括： action {string} 意图的 Action，指意图要完成的动作，是一个字符串常量，比如&quot;android.intent.action.SEND&quot;。当 action 以&quot;android.intent.action&quot;开头时，可以省略前缀，直接用&quot;SEND&quot;代替。参见Actions。type {string} 意图的 MimeType，表示和该意图直接相关的数据的类型，表示比如&quot;text/plain&quot;为纯文本类型。data {string} 意图的 Data，表示和该意图直接相关的数据，是一个 Uri, 可以是文件路径或者 Url 等。例如要打开一个文件, action 为&quot;android.intent.action.VIEW&quot;, data 为&quot;file:///sdcard/1.txt&quot;。category {Array} 意图的类别。比较少用。参见Categories。packageName {string} 目标包名className {string} 目标 Activity 或 Service 等组件的名称extras {Object} 以键值对构成的这个 Intent 的 Extras(额外信息)。提供该意图的其他信息，例如发送邮件时的邮件标题、邮件正文。参见Extras。flags {Array} intent 的标识，字符串数组，例如[&quot;activity_new_task&quot;, &quot;grant_read_uri_permission&quot;]。参见Flags。root {Boolea} 是否以 root 权限启动、发送该 intent。使用该参数后，不能使用`context.  根据选项，构造一个意图 Intent 对象。  例如：  //打开应用来查看图片文件 var i = app.intent({ action: &quot;VIEW&quot;, type: &quot;image/png&quot;, data: &quot;file:///sdcard/1.png&quot;, }); context.startActivity(i);   需要注意的是，除非应用专门暴露 Activity 出来，否则在没有 root 权限的情况下使用 intent 是无法跳转到特定 Activity、应用的特定界面的。例如我们能通过 Intent 跳转到 QQ 的分享界面，是因为 QQ 对外暴露了分享的 Activity；而在没有 root 权限的情况下，我们无法通过 intent 跳转到 QQ 的设置界面，因为 QQ 并没有暴露这个 Activity。  但如果有 root 权限，则在 intent 的参数加上&quot;root&quot;: true即可。例如使用 root 权限跳转到 Auto.js 的设置界面为：  app.startActivity({ packageName: &quot;org.autojs.autojs&quot;, className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;, root: true, });   另外，关于 intent 的参数如何获取的问题，一些 intent 是意外发现并且在网络中传播的（例如跳转 QQ 聊天窗口是因为 QQ 给网页提供了跳转到客服 QQ 的方法），如果要自己获取活动的 intent 的参数，可以通过例如&quot;intent 记录&quot;，&quot;隐式启动&quot;等应用拦截内部 intent 或者查询暴露的 intent。其中拦截内部 intent 需要 XPosed 框架，或者可以通过反编译等手段获取参数。总之，没有简单直接的方法。  更多信息，请百度安卓 Intent或参考Android 指南: Intent。  ","version":"Next","tagName":"h2"},{"title":"app.startActivity(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appstartactivityoptions","content":" options {Object} 选项  根据选项构造一个 Intent，并启动该 Activity。  app.startActivity({ action: &quot;SEND&quot;, type: &quot;text/plain&quot;, data: &quot;file:///sdcard/1.txt&quot;, });   ","version":"Next","tagName":"h2"},{"title":"app.sendBroadcast(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appsendbroadcastoptions","content":" options {Object} 选项  根据选项构造一个 Intent，并发送该广播。  ","version":"Next","tagName":"h2"},{"title":"app.startService(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appstartserviceoptions","content":" options {Object} 选项  根据选项构造一个 Intent，并启动该服务。  ","version":"Next","tagName":"h2"},{"title":"app.sendBroadcast(name)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appsendbroadcastname","content":" [v4.1.0 新增]  name {string} 特定的广播名称，包括： inspect_layout_hierarchy 布局层次分析inspect_layout_bounds 布局范围  发送以上特定名称的广播可以触发 Auto.js 的布局分析，方便脚本调试。这些广播在 Auto.js 发送才有效，在打包的脚本上运行将没有任何效果。  app.sendBroadcast(&quot;inspect_layout_bounds&quot;);   ","version":"Next","tagName":"h2"},{"title":"app.intentToShell(options)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appintenttoshelloptions","content":" [v4.1.0 新增]  options {Object} 选项  根据选项构造一个 Intent，转换为对应的 shell 的 intent 命令的参数。  例如:  shell( &quot;am start &quot; + app.intentToShell({ packageName: &quot;org.autojs.autojs&quot;, className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;, }), true );   参见intent 参数的规范。  ","version":"Next","tagName":"h2"},{"title":"app.parseUri(uri)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appparseuriuri","content":" [v4.1.0 新增]  uri {string} 一个代表 Uri 的字符串，例如&quot;file:///sdcard/1.txt&quot;, &quot;https://www.autojs.org&quot;return {Uri} 一个代表 Uri 的对象，参见android.net.Uri。  解析 uri 字符串并返回相应的 Uri 对象。即使 Uri 格式错误，该函数也会返回一个 Uri 对象，但之后如果访问该对象的 scheme, path 等值可能因解析失败而返回null。  需要注意的是，在高版本 Android 上，由于系统限制直接在 Uri 暴露文件的绝对路径，因此如果 uri 字符串是文件file://...，返回的 Uri 会是诸如content://...的形式。  ","version":"Next","tagName":"h2"},{"title":"app.getUriForFile(path)​","type":1,"pageTitle":"APP 应用","url":"/docs/rhino/base/app#appgeturiforfilepath","content":" [v4.1.0 新增]  path {string} 文件路径，例如&quot;/sdcard/1.txt&quot;return {Uri} 一个指向该文件的 Uri 的对象，参见android.net.Uri。  从一个文件路径创建一个 uri 对象。需要注意的是，在高版本 Android 上，由于系统限制直接在 Uri 暴露文件的绝对路径，因此返回的 Uri 会是诸如content://...的形式。 ","version":"Next","tagName":"h2"},{"title":"Console 控制台","type":0,"sectionRef":"#","url":"/docs/rhino/base/console","content":"","keywords":"","version":"Next"},{"title":"console.show(autoHide)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleshowautohide","content":" autoHide {boolean} 是否自动隐藏，默认 false 当程序结束的时候是否自动隐藏控制 显示控制台。这会显示一个控制台的悬浮窗(需要悬浮窗权限)。  console.show(true); //程序结束自动 隐藏控制台 console.show(); //结束不会自动隐藏控制台   ","version":"Next","tagName":"h2"},{"title":"console.hide()​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolehide","content":" 隐藏控制台悬浮窗。  ","version":"Next","tagName":"h2"},{"title":"console.clear()​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleclear","content":" 清空控制台。  ","version":"Next","tagName":"h2"},{"title":"console.log([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolelogdata-args","content":" data {any}...args {any}  打印到控制台，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。  const count = 5; console.log(&quot;count: %d&quot;, count); // 打印: count: 5 到 stdout console.log(&quot;count:&quot;, count); // 打印: count: 5 到 stdout   详见 util.format()。  该函数也可以作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"console.verbose([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleverbosedata-args","content":" data {any}...args {any}  与 console.log 类似，但输出结果以灰色字体显示。输出优先级低于 log，用于输出观察性质的信息。  ","version":"Next","tagName":"h2"},{"title":"console.info([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleinfodata-args","content":" data {any}...args {any}  与 console.log 类似，但输出结果以绿色字体显示。输出优先级高于 log, 用于输出重要信息。  ","version":"Next","tagName":"h2"},{"title":"console.warn([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolewarndata-args","content":" data {any}...args {any}  与 console.log 类似，但输出结果以蓝色字体显示。输出优先级高于 info, 用于输出警告信息。  ","version":"Next","tagName":"h2"},{"title":"console.error([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleerrordata-args","content":" data {any}...args {any}  与 console.log 类似，但输出结果以红色字体显示。输出优先级高于 warn, 用于输出错误信息。  ","version":"Next","tagName":"h2"},{"title":"console.assert(value, message)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleassertvalue-message","content":" value {any} 要断言的布尔值message {string} value 为 false 时要输出的信息  断言。如果 value 为 false 则输出错误信息 message 并停止脚本运行。  var a = 1 + 1; console.assert(a == 3, &quot;加法出错啦&quot;);   ","version":"Next","tagName":"h2"},{"title":"console.time([label])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoletimelabel","content":" [v4.1.0 新增]  label {String} 计时器标签，可省略  启动一个计时器，用以计算一个操作的持续时间。 计时器由一个唯一的 label 标识。 若label重复，则会覆盖上一个同名label的计时器。 以同名 label调用 console.timeEnd() 来停止计时器，并以毫秒为单位将持续时间输出到控制台。  ","version":"Next","tagName":"h2"},{"title":"console.timeEnd(label)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoletimeendlabel","content":" [v4.1.0 新增]  label {String} 计时器标签  停止之前通过调用 console.time() 启动的定时器，并打印结果到控制台。 调用 console.timeEnd() 后定时器会被删除。如果不存在标签指定的定时器则会打印 NaNms。  console.time(&quot;求和&quot;); var sum = 0; for (let i = 0; i &lt; 100000; i++) { sum += i; } console.timeEnd(&quot;求和&quot;); // 打印 求和: xxx ms   ","version":"Next","tagName":"h2"},{"title":"console.trace([data][, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoletracedata-args","content":" [v4.1.0 新增]  data {any}...args {any}  与 console.log 类似，同时会打印出调用这个函数所在的调用栈信息（即当前运行的文件、行数等信息）。  console.trace(&quot;Show me&quot;); // 打印: (堆栈跟踪会根据被调用的跟踪的位置而变化) // Show me // at &lt;test&gt;:7   ","version":"Next","tagName":"h2"},{"title":"console.input(data[, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleinputdata-args","content":" data {any}...args {any}  与console.log一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串用eval计算后返回。  部分机型可能会有控制台不显示输入框的情况，属于 bug。  例如：  var n = console.input(&quot;请输入一个数字:&quot;); //输入123之后： toast(n + 1); //显示124   ","version":"Next","tagName":"h2"},{"title":"console.rawInput(data[, ...args])​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolerawinputdata-args","content":" data {any}...args {any}  与 console.log 一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串直接返回。  部分机型可能会有控制台不显示输入框的情况，属于 bug。  例如：  var n = console.rawInput(&quot;请输入一个数字:&quot;); //输入123之后： toast(n + 1); //显示1231   ","version":"Next","tagName":"h2"},{"title":"console.setSize(w, h)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetsizew-h","content":" w {number} 宽度h {number} 高度  设置控制台的大小，单位像素。  console.show(); //设置控制台大小为屏幕的四分之一 console.setSize(device.width / 2, device.height / 2);   ","version":"Next","tagName":"h2"},{"title":"console.setPosition(x, y)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetpositionx-y","content":" x {number} 横坐标y {number} 纵坐标  设置控制台的位置，单位像素。  console.show(); console.setPosition(100, 100);   ","version":"Next","tagName":"h2"},{"title":"console.setGlobalLogConfig(config)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetgloballogconfigconfig","content":" [v4.1.0 新增]  [v7.0.2 弃用]  在 v7.0.4 之后除file选项外其他选项将不起作用，作为代替使用console.emitter与console.globalEmitter  config {Object} 日志配置，可选的项有： file {string} 日志文件路径，将会把日志写入该文件中maxFileSize {number} 最大文件大小，单位字节，默认为 512 * 1024 (512KB)rootLevel {string} 写入的日志级别，默认为&quot;ALL&quot;（所有日志），可以为&quot;OFF&quot;(关闭), &quot;DEBUG&quot;, &quot;INFO&quot;, &quot;WARN&quot;, &quot;ERROR&quot;, &quot;FATAL&quot;等。maxBackupSize {number} 日志备份文件最大数量，默认为 5filePattern {string} 日志写入格式，参见PatternLayout  设置日志保存的路径和配置。例如把日志保存到&quot;/sdcard/1.txt&quot;:  console.setGlobalLogConfig({ file: &quot;/sdcard/1.txt&quot;, });   ","version":"Next","tagName":"h2"},{"title":"print(text)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#printtext","content":" text {string} | {Object} 要打印到控制台的信息  相当于log(text)。  ","version":"Next","tagName":"h2"},{"title":"console.setTitle(title,color,size)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesettitletitlecolorsize","content":" [v4.2.5 新增]  title {string} 标题color {string} 颜色值 #AARRGGBBsize {number} 标题高度，字号会随高度变化，单位是 dp  设置标题名称，字体颜色，标题栏高度  console.setTitle(&quot;中文&quot;, &quot;#ff11ee00&quot;, 30); console.setTitle(&quot;中文&quot;); console.setTitle(&quot;中文&quot;, &quot;#ff11ee00&quot;);   ","version":"Next","tagName":"h2"},{"title":"console.setLogSize(size)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetlogsizesize","content":" [v4.2.5 新增]  size {number} 字号大小，单位是 dp 或 sp 20 以内比较合适 设置 log 字号大小  需要在显示控制台之后才能设置，否则空指针  function myrandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } threads.start(function () { console.show(); console.setTitle(&quot;中文&quot;, &quot;#ff11ee00&quot;, 30); console.setCanInput(false); var i = 0; do { console.setLogSize(myrandom(4, 20)); console.setCanInput(i % 2 == 0); i++; console.log(&quot;i-----&gt;&quot; + i); sleep(3000); } while (true); });   ","version":"Next","tagName":"h2"},{"title":"console.setCanInput(can)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetcaninputcan","content":" [v4.2.5 新增]  can {boolean} true 或 false 可以输入或不可以输入  控制 console 是否可以输入文字  console.setCanInput(false);   ","version":"Next","tagName":"h2"},{"title":"console.setBackgroud(color)​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetbackgroudcolor","content":" [v4.2.5 新增]  color {string} 颜色值 #AARRGGBB  设置 console 背景色,需要在显示控制台之后才能设置，否则空指针  console.setBackgroud(&quot;#33ef0000&quot;);   ","version":"Next","tagName":"h2"},{"title":"console.setMaxLines(maxLines);​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetmaxlinesmaxlines","content":" [v5.0.2 新增]  maxLines {number} 最大行数 如 10 行 设置 console 显示最大行数，默认-1，不限 ，超出行数系统会清空，从 0 开始显示 不限制，显示列表过长，android 内存又不足，系统会回收 console 的引用，即 console 将不显示。  console.setMaxLines(500);   ","version":"Next","tagName":"h2"},{"title":"console.setBackground()​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consolesetbackground","content":" ","version":"Next","tagName":"h2"},{"title":"console.emitter​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleemitter","content":" [v7.0.4 新增]  { EventEmiiter } 此对象在控制台打印内容时触发一些事件  // 监听控制台的所有输出 console.emitter.on(&quot;println&quot;, (log, level, levelString) =&gt; { //请勿在此回调中向控制台打印内容，否则将会无限循环 toast(log); });   事件：'VERBOSE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'ASSERT' 这些事件对应各种日志级别的日志  //仅获得&quot;WARN&quot;的日志 console.emitter.on(&quot;WARN&quot;, (log, level, levelString) =&gt; { //请勿在此回调中向控制台打印内容，否则将会无限循环 toast(log); });   ","version":"Next","tagName":"h2"},{"title":"console.globalEmitter​","type":1,"pageTitle":"Console 控制台","url":"/docs/rhino/base/console#consoleglobalemitter","content":" [v7.0.4 新增]  { EventEmiiter } 全局控制台的 EventEmiiter 对象  使用方法同上，获得的日志内容会与在 app 控制台中看到的一样，包括其他脚本的打印内容 ","version":"Next","tagName":"h2"},{"title":"Files 文件系统","type":0,"sectionRef":"#","url":"/docs/rhino/base/files","content":"","keywords":"","version":"Next"},{"title":"files.isFile(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesisfilepath","content":" path {string} 路径返回 {boolean}  返回路径 path 是否是文件。  log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回false log(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回true   ","version":"Next","tagName":"h2"},{"title":"files.isDir(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesisdirpath","content":" path {string} 路径返回 {boolean}  返回路径 path 是否是文件夹。  log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回true log(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回false   ","version":"Next","tagName":"h2"},{"title":"files.isEmptyDir(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesisemptydirpath","content":" path {string} 路径返回 {boolean}  返回文件夹 path 是否为空文件夹。如果该路径并非文件夹，则直接返回false。  ","version":"Next","tagName":"h2"},{"title":"files.join(parent, child)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesjoinparent-child","content":" parent {string} 父目录路径child {string} 子路径返回 {string}  连接两个路径并返回，例如files.join(&quot;/sdcard/&quot;, &quot;1.txt&quot;)返回&quot;/sdcard/1.txt&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.create(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filescreatepath","content":" path {string} 路径返回 {boolean}  创建一个文件或文件夹并返回是否创建成功。如果文件已经存在，则直接返回false。  files.create(&quot;/sdcard/新文件夹/&quot;);   ","version":"Next","tagName":"h2"},{"title":"files.createWithDirs(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filescreatewithdirspath","content":" path {string} 路径返回 {boolean}  创建一个文件或文件夹并返回是否创建成功。如果文件所在文件夹不存在，则先创建他所在的一系列文件夹。如果文件已经存在，则直接返回false。  files.createWithDirs(&quot;/sdcard/新文件夹/新文件夹/新文件夹/1.txt&quot;);   ","version":"Next","tagName":"h2"},{"title":"files.exists(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesexistspath","content":" path {string} 路径返回 {boolean}  返回在路径 path 处的文件是否存在。  ","version":"Next","tagName":"h2"},{"title":"files.ensureDir(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesensuredirpath","content":" path {string} 路径  确保路径 path 所在的文件夹存在。如果该路径所在文件夹不存在，则创建该文件夹。  例如对于路径&quot;/sdcard/Download/ABC/1.txt&quot;，如果/Download/文件夹不存在，则会先创建 Download，再创建 ABC 文件夹。  ","version":"Next","tagName":"h2"},{"title":"files.read(path[, encoding = \"utf-8\"])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesreadpath-encoding--utf-8","content":" path {string} 路径encoding {string} 字符编码，可选，默认为 utf-8返回 {string}  读取文本文件 path 的所有内容并返回。如果文件不存在，则抛出FileNotFoundException。  log(files.read(&quot;/sdcard/1.txt&quot;));   ","version":"Next","tagName":"h2"},{"title":"files.readBytes(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesreadbytespath","content":" path {string} 路径返回 {byte[]}  读取文件 path 的所有内容并返回一个字节数组。如果文件不存在，则抛出FileNotFoundException。  注意，该数组是 Java 的数组，不具有 JavaScript 数组的 forEach, slice 等函数。  一个以 16 进制形式打印文件的例子如下:  var data = files.readBytes(&quot;/sdcard/1.png&quot;); var sb = new java.lang.StringBuilder(); for (var i = 0; i &lt; data.length; i++) { sb.append(data[i].toString(16)); } log(sb.toString());   ","version":"Next","tagName":"h2"},{"title":"files.write(path, text[, encoding = \"utf-8\"])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#fileswritepath-text-encoding--utf-8","content":" path {string} 路径text {string} 要写入的文本内容encoding {string} 字符编码  把 text 写入到文件 path 中。如果文件存在则覆盖，不存在则创建。  var text = &quot;文件内容&quot;; //写入文件 files.write(&quot;/sdcard/1.txt&quot;, text); //用其他应用查看文件 app.viewFile(&quot;/sdcard/1.txt&quot;);   ","version":"Next","tagName":"h2"},{"title":"files.writeBytes(path, bytes)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#fileswritebytespath-bytes","content":" path {string} 路径bytes {byte[]} 字节数组，要写入的二进制数据  把 bytes 写入到文件 path 中。如果文件存在则覆盖，不存在则创建。  ","version":"Next","tagName":"h2"},{"title":"files.append(path, text[, encoding = 'utf-8'])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesappendpath-text-encoding--utf-8","content":" path {string} 路径text {string} 要写入的文本内容encoding {string} 字符编码  把 text 追加到文件 path 的末尾。如果文件不存在则创建。  var text = &quot;追加的文件内容&quot;; files.append(&quot;/sdcard/1.txt&quot;, text); files.append(&quot;/sdcard/1.txt&quot;, text); //用其他应用查看文件 app.viewFile(&quot;/sdcard/1.txt&quot;);   ","version":"Next","tagName":"h2"},{"title":"files.appendBytes(path, text[, encoding = 'utf-8'])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesappendbytespath-text-encoding--utf-8","content":" path {string} 路径bytes {byte[]} 字节数组，要写入的二进制数据  把 bytes 追加到文件 path 的末尾。如果文件不存在则创建。  ","version":"Next","tagName":"h2"},{"title":"files.copy(fromPath, toPath)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filescopyfrompath-topath","content":" fromPath {string} 要复制的原文件路径toPath {string} 复制到的文件路径返回 {boolean}  复制文件，返回是否复制成功。例如files.copy(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)。  ","version":"Next","tagName":"h2"},{"title":"files.move(fromPath, toPath)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesmovefrompath-topath","content":" fromPath {string} 要移动的原文件路径toPath {string} 移动到的文件路径返回 {boolean}  移动文件，返回是否移动成功。例如files.move(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)会把 1.txt 文件从 sd 卡根目录移动到 Download 文件夹。  ","version":"Next","tagName":"h2"},{"title":"files.rename(path, newName)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesrenamepath-newname","content":" path {string} 要重命名的原文件路径newName {string} 要重命名的新文件名返回 {boolean}  重命名文件，并返回是否重命名成功。例如files.rename(&quot;/sdcard/1.txt&quot;, &quot;2.txt&quot;)。  ","version":"Next","tagName":"h2"},{"title":"files.renameWithoutExtension(path, newName)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesrenamewithoutextensionpath-newname","content":" path {string} 要重命名的原文件路径newName {string} 要重命名的新文件名返回 {boolean}  重命名文件，不包含拓展名，并返回是否重命名成功。例如files.rename(&quot;/sdcard/1.txt&quot;, &quot;2&quot;)会把&quot;1.txt&quot;重命名为&quot;2.txt&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.getName(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesgetnamepath","content":" path {string} 路径返回 {string}  返回文件的文件名。例如files.getName(&quot;/sdcard/1.txt&quot;)返回&quot;1.txt&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.getNameWithoutExtension(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesgetnamewithoutextensionpath","content":" path {string} 路径返回 {string}  返回不含拓展名的文件的文件名。例如files.getName(&quot;/sdcard/1.txt&quot;)返回&quot;1&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.getExtension(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesgetextensionpath","content":" path {string} 路径返回 {string}  返回文件的拓展名。例如files.getExtension(&quot;/sdcard/1.txt&quot;)返回&quot;txt&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.remove(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesremovepath","content":" path {string} 路径返回 {boolean}  删除文件或空文件夹，返回是否删除成功。  ","version":"Next","tagName":"h2"},{"title":"files.removeDir(path)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesremovedirpath","content":" path {string} 路径path {string} 路径返回 {boolean}  删除文件夹，如果文件夹不为空，则删除该文件夹的所有内容再删除该文件夹，返回是否全部删除成功。  ","version":"Next","tagName":"h2"},{"title":"files.getSdcardPath()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filesgetsdcardpath","content":" 返回 {string}  返回 SD 卡路径。所谓 SD 卡，即外部存储器。  ","version":"Next","tagName":"h2"},{"title":"files.cwd()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filescwd","content":" 返回 {string}  返回脚本的&quot;当前工作文件夹路径&quot;。该路径指的是，如果脚本本身为脚本文件，则返回这个脚本文件所在目录；否则返回null获取其他设定路径。  例如，对于脚本文件&quot;/sdcard/脚本/1.js&quot;运行files.cwd()返回&quot;/sdcard/脚本/&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.path(relativePath)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#filespathrelativepath","content":" relativePath {string} 相对路径返回 {string}  返回相对路径对应的绝对路径。例如files.path(&quot;./1.png&quot;)，如果运行这个语句的脚本位于文件夹&quot;/sdcard/脚本/&quot;中，则返回&quot;/sdcard/脚本/1.png&quot;。  ","version":"Next","tagName":"h2"},{"title":"files.listDir(path[, filter])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#fileslistdirpath-filter","content":" path {string} 路径filter {Function} 过滤函数，可选。接收一个string参数（文件名），返回一个boolean值。  列出文件夹 path 下的满足条件的文件和文件夹的名称的数组。如果不加 filter 参数，则返回所有文件和文件夹。  列出 sdcard 目录下所有文件和文件夹为:  var arr = files.listDir(&quot;/sdcard/&quot;); log(arr);   列出脚本目录下所有 js 脚本文件为:  var dir = &quot;/sdcard/脚本/&quot;; var jsFiles = files.listDir(dir, function (name) { return name.endsWith(&quot;.js&quot;) &amp;&amp; files.isFile(files.join(dir, name)); }); log(jsFiles);   ","version":"Next","tagName":"h2"},{"title":"open(path[, mode = \"r\", encoding = \"utf-8\", bufferSize = 8192])​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#openpath-mode--r-encoding--utf-8-buffersize--8192","content":" path {string} 文件路径，例如&quot;/sdcard/1.txt&quot;。mode {string} 文件打开模式，包括: r: 只读文本模式。该模式下只能对文件执行文本读取操作。w: 只写文本模式。该模式下只能对文件执行文本覆盖写入操作。a: 附加文本模式。该模式下将会把写入的文本附加到文件末尾。rw: 随机读写文本模式。该模式下将会把写入的文本附加到文件末尾。 目前暂不支持二进制模式，随机读写模式。 encoding {string} 字符编码。bufferSize {number} 文件读写的缓冲区大小。  打开一个文件。根据打开模式返回不同的文件对象。包括：  &quot;r&quot;: 返回一个 ReadableTextFile 对象。&quot;w&quot;, &quot;a&quot;: 返回一个 WritableTextFile 对象。  对于&quot;w&quot;模式，如果文件并不存在，则会创建一个，已存在则会清空该文件内容；其他模式文件不存在会抛出 FileNotFoundException。  ReadableTextFile  可读文件对象。  ","version":"Next","tagName":"h2"},{"title":"ReadableTextFile.read()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#readabletextfileread","content":" 返回该文件剩余的所有内容的字符串。  ","version":"Next","tagName":"h2"},{"title":"ReadableTextFile.read(maxCount)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#readabletextfilereadmaxcount","content":" maxCount {Number} 最大读取的字符数量  读取该文件接下来最长为 maxCount 的字符串并返回。即使文件剩余内容不足 maxCount 也不会出错。  ","version":"Next","tagName":"h2"},{"title":"ReadableTextFile.readline()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#readabletextfilereadline","content":" 读取一行并返回（不包含换行符）。  ","version":"Next","tagName":"h2"},{"title":"ReadableTextFile.readlines()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#readabletextfilereadlines","content":" 读取剩余的所有行，并返回它们按顺序组成的字符串数组。  ","version":"Next","tagName":"h2"},{"title":"close()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#close","content":" 关闭该文件。  打开一个文件不再使用时务必关闭  PWritableTextFile  可写文件对象。  ","version":"Next","tagName":"h2"},{"title":"PWritableTextFile.write(text)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#pwritabletextfilewritetext","content":" text {string} 文本  把文本内容 text 写入到文件中。  ","version":"Next","tagName":"h2"},{"title":"PWritableTextFile.writeline(line)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#pwritabletextfilewritelineline","content":" text {string} 文本  把文本 line 写入到文件中并写入一个换行符。  ","version":"Next","tagName":"h2"},{"title":"PWritableTextFile.writelines(lines)​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#pwritabletextfilewritelineslines","content":" lines {Array} 字符串数组  把很多行写入到文件中....  ","version":"Next","tagName":"h2"},{"title":"PWritableTextFile.flush()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#pwritabletextfileflush","content":" 把缓冲区内容输出到文件中。  ","version":"Next","tagName":"h2"},{"title":"PWritableTextFile.close()​","type":1,"pageTitle":"Files 文件系统","url":"/docs/rhino/base/files#pwritabletextfileclose","content":" 关闭文件。同时会被缓冲区内容输出到文件。  打开一个文件写入后，不再使用时务必关闭，否则文件可能会丢失 ","version":"Next","tagName":"h2"},{"title":"全局变量与函数","type":0,"sectionRef":"#","url":"/docs/rhino/base/globals","content":"","keywords":"","version":"Next"},{"title":"sleep(n)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#sleepn","content":" n {number} 毫秒数  暂停运行 n毫秒的时间。1 秒等于 1000 毫秒。  //暂停5秒 sleep(5000);   ","version":"Next","tagName":"h2"},{"title":"currentPackage()​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#currentpackage","content":" 返回 {string}  返回最近一次监测到的正在运行的应用的包名，一般可以认为就是当前正在运行的应用的包名。  此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。  ","version":"Next","tagName":"h2"},{"title":"currentActivity()​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#currentactivity","content":" 返回 {string}  返回最近一次监测到的正在运行的 Activity 的名称，一般可以认为就是当前正在运行的 Activity 的名称。  此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。  ","version":"Next","tagName":"h2"},{"title":"setClip(text)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#setcliptext","content":" text {string} 文本  设置剪贴板内容。此剪贴板即系统剪贴板，在一般应用的输入框中&quot;粘贴&quot;既可使用。  setClip(&quot;剪贴板文本&quot;);   ","version":"Next","tagName":"h2"},{"title":"getClip()​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#getclip","content":" 返回 {string}  返回系统剪贴板的内容。  toast(&quot;剪贴板内容为:&quot; + getClip());   ","version":"Next","tagName":"h2"},{"title":"toast(message)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#toastmessage","content":" message {string} 要显示的信息  以气泡显示信息 message 几秒。(具体时间取决于安卓系统，一般都是 2 秒)  注意，信息的显示是&quot;异步&quot;执行的，并且，不会等待信息消失程序才继续执行。如果在循环中执行该命令，可能出现脚本停止运行后仍然有不断的气泡信息出现的情况。 例如:  for (var i = 0; i &lt; 100; i++) { toast(i); }   运行这段程序以后，会很快执行完成，且不断弹出消息，在任务管理中关闭所有脚本也无法停止。 要保证气泡消息才继续执行可以用：  for (var i = 0; i &lt; 100; i++) { toast(i); sleep(2000); }   或者修改 toast 函数：  var _toast_ = toast; toast = function (message) { _toast_(message); sleep(2000); }; for (var i = 0; i &lt; 100; i++) { toast(i); }   ","version":"Next","tagName":"h2"},{"title":"toastLog(message)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#toastlogmessage","content":" message {string} 要显示的信息  相当于toast(message);log(message)。显示信息 message 并在控制台中输出。参见 console.log。  ","version":"Next","tagName":"h2"},{"title":"waitForActivity(activity[, period = 200])​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#waitforactivityactivity-period--200","content":" activity Activity 名称period 轮询等待间隔（毫秒）  等待指定的 Activity 出现，period 为检查 Activity 的间隔。  ","version":"Next","tagName":"h2"},{"title":"waitForPackage(package[, period = 200])​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#waitforpackagepackage-period--200","content":" package 包名period 轮询等待间隔（毫秒）  等待指定的应用出现。例如waitForPackage(&quot;com.tencent.mm&quot;)为等待当前界面为微信。  ","version":"Next","tagName":"h2"},{"title":"exit()​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#exit","content":" 立即停止脚本运行。  立即停止是通过抛出ScriptInterrupttedException来实现的，因此如果用try...catch把 exit()函数的异常捕捉，则脚本不会立即停止，仍会运行几行后再停止。  ","version":"Next","tagName":"h2"},{"title":"random(min, max)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#randommin-max","content":" min {number} 随机数产生的区间下界max {number} 随机数产生的区间上界返回 {number}  返回一个在[min...max]之间的随机数。例如 random(0, 2)可能产生 0, 1, 2。  ","version":"Next","tagName":"h2"},{"title":"random()​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#random","content":" 返回 {number}  返回在[0, 1)的随机浮点数。  ","version":"Next","tagName":"h2"},{"title":"requiresApi(api)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#requiresapiapi","content":" api Android 版本号  表示此脚本需要 Android API 版本达到指定版本才能运行。例如requiresApi(19)表示脚本需要在 Android 4.4 以及以上运行。  调用该函数时会判断运行脚本的设备系统的版本号，如果没有达到要求则抛出异常。  可以参考以下 Android API 和版本的对照表:  平台版本： API 级别  Android 7.0： 24  Android 6.0： 23  Android 5.1： 22  Android 5.0： 21  Android 4.4W： 20  Android 4.4： 19  Android 4.3： 18  ","version":"Next","tagName":"h2"},{"title":"requiresAutojsVersion(version)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#requiresautojsversionversion","content":" version {string} | {number} Auto.js 的版本或版本号  表示此脚本需要 Auto.js 版本达到指定版本才能运行。例如requiresAutojsVersion(&quot;3.0.0 Beta&quot;)表示脚本需要在 Auto.js 3.0.0 Beta 以及以上运行。  调用该函数时会判断运行脚本的 Auto.js 的版本号，如果没有达到要求则抛出异常。  version 参数可以是整数表示版本号，例如requiresAutojsVersion(250)；也可以是字符串格式表示的版本，例如&quot;3.0.0 Beta&quot;, &quot;3.1.0 Alpha4&quot;, &quot;3.2.0&quot;等。  可以通过app.autojs.versionCode和app.autojs.versionName获取当前的 Auto.js 版本号和版本。  ","version":"Next","tagName":"h2"},{"title":"runtime.requestPermissions(permissions)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#runtimerequestpermissionspermissions","content":" permissions {Array} 权限的字符串数组  动态申请安卓的权限。例如：  //请求GPS权限 runtime.requestPermissions([&quot;access_fine_location&quot;]);   尽管安卓有很多权限，但必须写入 Manifest 才能动态申请，为了防止权限的滥用，目前 Auto.js 只能额外申请两个权限：  access_fine_location GPS 权限record_audio 录音权限  您可以通过 APK 编辑器来增加 Auto.js 以及 Auto.js 打包的应用的权限。  安卓所有的权限列表参见Permissions Overview。（并没有用）  ","version":"Next","tagName":"h2"},{"title":"runtime.loadJar(path)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#runtimeloadjarpath","content":" path {string} jar 文件路径  加载目标 jar 文件，加载成功后将可以使用该 Jar 文件的类。  // 加载jsoup.jar runtime.loadJar(&quot;./jsoup.jar&quot;); // 使用jsoup解析html importClass(org.jsoup.Jsoup); log(Jsoup.parse(files.read(&quot;./test.html&quot;)));   (jsoup 是一个 Java 实现的解析 Html DOM 的库，可以在Jsoup下载)  ","version":"Next","tagName":"h2"},{"title":"runtime.loadDex(path)​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#runtimeloaddexpath","content":" path {string} dex 文件路径  加载目标 dex 文件，加载成功后将可以使用该 dex 文件的类。  因为加载 jar 实际上是把 jar 转换为 dex 再加载的，因此加载 dex 文件会比 jar 文件快得多。可以使用 Android SDK 的 build tools 的 dx 工具把 jar 转换为 dex。  ","version":"Next","tagName":"h2"},{"title":"context​","type":1,"pageTitle":"全局变量与函数","url":"/docs/rhino/base/globals#context","content":" 全局变量。一个 android.content.Context 对象。  注意该对象为 ApplicationContext，因此不能用于界面、对话框等的创建。 ","version":"Next","tagName":"h2"},{"title":"HTTP 网络请求","type":0,"sectionRef":"#","url":"/docs/rhino/base/http","content":"","keywords":"","version":"Next"},{"title":"http.get(url[, options, callback])​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#httpgeturl-options-callback","content":" url {string} 请求的 URL 地址，需要以&quot;http://&quot;或&quot;https://&quot;开头。如果 url 没有以&quot;http://&quot;开头，则默认为&quot;http://&quot;。options {Object} 请求选项。参见[http.request()][]。callback {Function} 回调函数，可选，其参数是一个[Response][]对象。如果不加回调函数，则该请求将阻塞、同步地执行。  对地址 url 进行一次 HTTP GET 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。  最简单 GET 请求如下:  console.show(); var r = http.get(&quot;www.baidu.com&quot;); log(&quot;code = &quot; + r.statusCode); log(&quot;html = &quot; + r.body.string());   采用回调形式的 GET 请求如下：  console.show(); http.get(&quot;www.baidu.com&quot;, {}, function (res, err) { if (err) { console.error(err); return; } log(&quot;code = &quot; + res.statusCode); log(&quot;html = &quot; + res.body.string()); });   如果要增加 HTTP 头部信息，则在 options 参数中添加，例如：  console.show(); var r = http.get(&quot;www.baidu.com&quot;, { headers: { &quot;Accept-Language&quot;: &quot;zh-cn,zh;q=0.5&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11&quot;, }, }); log(&quot;code = &quot; + r.statusCode); log(&quot;html = &quot; + r.body.string());   一个请求天气并解析返回的天气 JSON 结果的例子如下：  var city = &quot;广州&quot;; var res = http.get( &quot;http://www.sojson.com/open/api/weather/json.shtml?city=&quot; + city ); if (res.statusCode != 200) { toast(&quot;请求失败: &quot; + res.statusCode + &quot; &quot; + res.statusMessage); } else { var weather = res.body.json(); log(weather); toast( util.format( &quot;温度: %s 湿度: %s 空气质量: %s&quot;, weather.data.wendu, weather.data.shidu, weather.quality ) ); }   ","version":"Next","tagName":"h2"},{"title":"http.post(url, data[, options, callback])​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#httpposturl-data-options-callback","content":" url {string} 请求的 URL 地址，需要以&quot;http://&quot;或&quot;https://&quot;开头。如果 url 没有以&quot;http://&quot;开头，则默认为&quot;http://&quot;。data {string} | {Object} POST 数据。options {Object} 请求选项。callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。  对地址 url 进行一次 HTTP POST 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。  其中 POST 数据可以是字符串或键值对。具体含义取决于 options.contentType 的值。默认为&quot;application/x-www-form-urlencoded&quot;(表单提交), 这种方式是 JQuery 的 ajax 函数的默认方式。  一个模拟表单提交登录淘宝的例子如下:  var url = &quot;https://login.taobao.com/member/login.jhtml&quot;; var username = &quot;你的用户名&quot;; var password = &quot;你的密码&quot;; var res = http.post(url, { TPL_username: username, TPL_password: password, }); var html = res.body.string(); if (html.contains(&quot;页面跳转中&quot;)) { toast(&quot;登录成功&quot;); } else { toast(&quot;登录失败&quot;); }   ","version":"Next","tagName":"h2"},{"title":"http.postJson(url[, data, options, callback])​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#httppostjsonurl-data-options-callback","content":" url {string} 请求的 URL 地址，需要以&quot;http://&quot;或&quot;https://&quot;开头。如果 url 没有以&quot;http://&quot;开头，则默认为&quot;http://&quot;。data {Object} POST 数据。options {Object} 请求选项。callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。  以 JSON 格式向目标 Url 发起 POST 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。  JSON 格式指的是，将会调用JSON.stringify()把 data 对象转换为 JSON 字符串，并在 HTTP 头部信息中把&quot;Content-Type&quot;属性置为&quot;application/json&quot;。这种方式是 AngularJS 的 ajax 函数的默认方式。  一个调用图灵机器人接口的例子如下：  var url = &quot;http://www.tuling123.com/openapi/api&quot;; r = http.postJson(url, { key: &quot;65458a5df537443b89b31f1c03202a80&quot;, info: &quot;你好啊&quot;, userid: &quot;1&quot;, }); toastLog(r.body.string());   ","version":"Next","tagName":"h2"},{"title":"http.postMultipart(url, files[, options, callback])​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#httppostmultiparturl-files-options-callback","content":" url {string} 请求的 URL 地址，需要以&quot;http://&quot;或&quot;https://&quot;开头。如果 url 没有以&quot;http://&quot;开头，则默认为&quot;http://&quot;。files {Object} POST 数据。options {Object} 请求选项。callback {Function} 回调，其参数是一个Response对象。如果不加回调参数，则该请求将阻塞、同步地执行。  向目标地址发起类型为 multipart/form-data 的请求（通常用于文件上传等), 其中 files 参数是{name1: value1, name2: value2, ...}的键值对，value 的格式可以是以下几种情况：  string文件类型，即 open()返回的类型[fileName, filePath][fileName, mimeType, filePath]  其中 1 属于非文件参数，2、3、4 为文件参数。举个例子，最简单的文件上传的请求为：  var res = http.postMultipart(url, { file: open(&quot;/sdcard/1.txt&quot;), }); log(res.body.string());   如果使用格式 2，则代码为  var res = http.postMultipart(url, { file: [&quot;1.txt&quot;, &quot;/sdcard/1.txt&quot;], }); log(res.body.string());   如果使用格式 3，则代码为  var res = http.postMultipart(url, { file: [&quot;1.txt&quot;, &quot;text/plain&quot;, &quot;/sdcard/1.txt&quot;], }); log(res.body.string());   如果使用格式 2 的同时要附带非文件参数&quot;appId=abcdefghijk&quot;，则为:  var res = http.postMultipart(url, { appId: &quot;adcdefghijk&quot;, file: open(&quot;/sdcard/1.txt&quot;), }); log(res.body.string());   ","version":"Next","tagName":"h2"},{"title":"http.request(url[, options, callback])​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#httprequesturl-options-callback","content":" url {string} 请求的 URL 地址，需要以&quot;http://&quot;或&quot;https://&quot;开头。如果 url 没有以&quot;http://&quot;开头，则默认为&quot;http://&quot;。options {Object} 请求选项。参见[http.buildRequest()][]。callback {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。  对目标地址 url 发起一次 HTTP 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。  选项 options 可以包含以下属性：  headers {Object} 键值对形式的 HTTP 头部信息。有关 HTTP 头部信息，参见菜鸟教程：HTTP 响应头信息。method {string} HTTP 请求方法。包括&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELET&quot;, &quot;PATCH&quot;。contentType {string} HTTP 头部信息中的&quot;Content-Type&quot;, 表示 HTTP 请求的内容类型。例如&quot;text/plain&quot;, &quot;application/json&quot;。更多信息参见菜鸟教程：HTTP contentType。body {string} | {Array} | {Function} HTTP 请求的内容。可以是一个字符串，也可以是一个字节数组；或者是一个以BufferedSink为参数的函数。  该函数是 get, post, postJson 等函数的基础函数。因此除非是 PUT, DELET 等请求，或者需要更高定制的 HTTP 请求，否则直接使用 get, post, postJson 等函数会更加方便。  Response  HTTP 请求的响应。  ","version":"Next","tagName":"h2"},{"title":"Response.statusCode​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responsestatuscode","content":" {number}  当前响应的 HTTP 状态码。例如 200(OK), 404(Not Found)等。  有关 HTTP 状态码的信息，参见菜鸟教程：HTTP 状态码。  ","version":"Next","tagName":"h2"},{"title":"Response.statusMessage​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responsestatusmessage","content":" {string}  当前响应的 HTTP 状态信息。例如&quot;OK&quot;, &quot;Bad Request&quot;, &quot;Forbidden&quot;。  有关 HTTP 状态码的信息，参见[菜鸟教程：HTTP 状态码](http://www.runoob.com/http/http-status-codes.html)。  例子：  var res = http.get(&quot;www.baidu.com&quot;); if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) { toast(&quot;页面获取成功!&quot;); } else if (res.statusCode == 404) { toast(&quot;页面没找到哦...&quot;); } else { toast(&quot;错误: &quot; + res.statusCode + &quot; &quot; + res.statusMessage); }   ","version":"Next","tagName":"h2"},{"title":"Response.headers​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responseheaders","content":" {Object}  当前响应的 HTTP 头部信息。该对象的键是响应头名称，值是各自的响应头值。 所有响应头名称都是小写的(吗)。  有关 HTTP 头部信息，参见菜鸟教程：HTTP 响应头信息。  例子:  console.show(); var res = http.get(&quot;www.qq.com&quot;); console.log(&quot;HTTP Headers:&quot;); for (var headerName in res.headers) { console.log(&quot;%s: %s&quot;, headerName, res.headers[headerName]); }   ","version":"Next","tagName":"h2"},{"title":"Response.body​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responsebody","content":" {Object}  当前响应的内容。他有以下属性和函数：  bytes() {Array} 以字节数组形式返回响应内容string() {string} 以字符串形式返回响应内容json() {Object} 把响应内容作为 JSON 格式的数据并调用 JSON.parse，返回解析后的对象contentType {string} 当前响应的内容类型  ","version":"Next","tagName":"h2"},{"title":"Response.request​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responserequest","content":" {Request} 当前响应所对应的请求。参见[Request][]。  ","version":"Next","tagName":"h2"},{"title":"Response.url​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responseurl","content":" {number} 当前响应所对应的请求 URL。  ","version":"Next","tagName":"h2"},{"title":"Response.method​","type":1,"pageTitle":"HTTP 网络请求","url":"/docs/rhino/base/http#responsemethod","content":" {string} 当前响应所对应的 HTTP 请求的方法。例如&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;等。 ","version":"Next","tagName":"h2"},{"title":"Keys 按键模拟","type":0,"sectionRef":"#","url":"/docs/rhino/base/keys","content":"","keywords":"","version":"Next"},{"title":"back()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#back","content":" 返回 {boolean}  模拟按下返回键。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"home()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#home","content":" 返回 {boolean}  模拟按下 Home 键。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"powerDialog()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#powerdialog","content":" 返回 {boolean}  弹出电源键菜单。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"notifications()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#notifications","content":" 返回 {boolean}  拉出通知栏。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"quickSettings()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#quicksettings","content":" 返回 {boolean}  显示快速设置(下拉通知栏到底)。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"recents()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#recents","content":" 返回 {boolean}  显示最近任务。返回是否执行成功。 此函数依赖于无障碍服务。  ","version":"Next","tagName":"h2"},{"title":"splitScreen()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#splitscreen","content":" 返回 {boolean}  分屏。返回是否执行成功。 此函数依赖于无障碍服务, 并且需要系统自身功能的支持。  ","version":"Next","tagName":"h2"},{"title":"takeScreenshot()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#takescreenshot","content":" 返回 {boolean}需要 Android 9 以上  模拟按键 电源键+音量下键 截屏 不返回截屏得到的图片对象，只返回是否截图成功，图片保存到系统相册  ","version":"Next","tagName":"h2"},{"title":"lockScreen()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#lockscreen","content":" 返回 {boolean}需要 Android 9 以上  模拟按键 电源键 锁屏  ","version":"Next","tagName":"h2"},{"title":"dismissNotificationShade()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#dismissnotificationshade","content":" 返回 {boolean}需要 Android 12 以上  关闭通知栏的操作  ","version":"Next","tagName":"h2"},{"title":"keyCodeHeadsetHook()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#keycodeheadsethook","content":" 返回 {boolean}需要 Android 12 以上  发送 KEYCODE_HEADSETHOOK KeyEvent 的动作，用于接听/挂断通话和播放/停止媒体  ","version":"Next","tagName":"h2"},{"title":"accessibilityShortcut()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#accessibilityshortcut","content":" 返回 {boolean}需要 Android 12 以上  触发辅助功能快捷方式的操作。此快捷方式有一个硬件触发器并且可以通过按住两个音量键来激活。  ","version":"Next","tagName":"h2"},{"title":"accessibilityButtonChooser()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#accessibilitybuttonchooser","content":" 返回 {boolean}需要 Android 12 以上  调出辅助功能按钮的选择器菜单的操作  ","version":"Next","tagName":"h2"},{"title":"accessibilityButton()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#accessibilitybutton","content":" 返回 {boolean}需要 Android 12 以上  触发辅助功能按钮的操作  ","version":"Next","tagName":"h2"},{"title":"accessibilityAllApps()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#accessibilityallapps","content":" 返回 {boolean}需要 Android 12 以上  显示 Launcher（启动器） 的所有应用的操作。  ","version":"Next","tagName":"h2"},{"title":"Home()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#home-1","content":" 模拟按下 Home 键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Back()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#back-1","content":" 模拟按下返回键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Power()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#power","content":" 模拟按下电源键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Menu()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#menu","content":" 模拟按下菜单键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"VolumeUp()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#volumeup","content":" 按下音量上键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"VolumeDown()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#volumedown","content":" 按键音量上键。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Camera()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#camera","content":" 模拟按下照相键。  ","version":"Next","tagName":"h2"},{"title":"Up()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#up","content":" 模拟按下物理按键上。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Down()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#down","content":" 模拟按下物理按键下。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Left()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#left","content":" 模拟按下物理按键左。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Right()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#right","content":" 模拟按下物理按键右。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"OK()​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#ok","content":" 模拟按下物理按键确定。 此函数依赖于 root 权限。  ","version":"Next","tagName":"h2"},{"title":"Text(text)​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#texttext","content":" text {string} 要输入的文字，只能为英文或英文符号 输入文字 text。例如Text(&quot;aaa&quot;);  ","version":"Next","tagName":"h2"},{"title":"KeyCode(code)​","type":1,"pageTitle":"Keys 按键模拟","url":"/docs/rhino/base/keys#keycodecode","content":" code {number} | &lt;String&gt; 要按下的按键的数字代码或名称。参见下表。 模拟物理按键。例如KeyCode(29)和KeyCode(&quot;KEYCODE_A&quot;)是按下 A 键。  附录: KeyCode 对照表  KeyCode KeyEvent Value  KEYCODE_MENU 1KEYCODE_SOFT_RIGHT 2KEYCODE_HOME 3KEYCODE_BACK 4KEYCODE_CALL 5KEYCODE_ENDCALL 6KEYCODE_0 7KEYCODE_1 8KEYCODE_2 9KEYCODE_3 10KEYCODE_4 11KEYCODE_5 12KEYCODE_6 13KEYCODE_7 14KEYCODE_8 15KEYCODE_9 16KEYCODE_STAR 17KEYCODE_POUND 18KEYCODE_DPAD_UP 19KEYCODE_DPAD_DOWN 20KEYCODE_DPAD_LEFT 21KEYCODE_DPAD_RIGHT 22KEYCODE_DPAD_CENTER 23KEYCODE_VOLUME_UP 24KEYCODE_VOLUME_DOWN 25KEYCODE_POWER 26KEYCODE_CAMERA 27KEYCODE_CLEAR 28KEYCODE_A 29KEYCODE_B 30KEYCODE_C 31KEYCODE_D 32KEYCODE_E 33KEYCODE_F 34KEYCODE_G 35KEYCODE_H 36KEYCODE_I 37KEYCODE_J 38KEYCODE_K 39KEYCODE_L 40KEYCODE_M 41KEYCODE_N 42KEYCODE_O 43KEYCODE_P 44KEYCODE_Q 45KEYCODE_R 46KEYCODE_S 47KEYCODE_T 48KEYCODE_U 49KEYCODE_V 50KEYCODE_W 51KEYCODE_X 52KEYCODE_Y 53KEYCODE_Z 54KEYCODE_COMMA 55KEYCODE_PERIOD 56KEYCODE_ALT_LEFT 57KEYCODE_ALT_RIGHT 58KEYCODE_SHIFT_LEFT 59KEYCODE_SHIFT_RIGHT 60KEYCODE_TAB 61KEYCODE_SPACE 62KEYCODE_SYM 63KEYCODE_EXPLORER 64KEYCODE_ENVELOPE 65KEYCODE_ENTER 66KEYCODE_DEL 67KEYCODE_GRAVE 68KEYCODE_MINUS 69KEYCODE_EQUALS 70KEYCODE_LEFT_BRACKET 71KEYCODE_RIGHT_BRACKET 72KEYCODE_BACKSLASH 73KEYCODE_SEMICOLON 74KEYCODE_APOSTROPHE 75KEYCODE_SLASH 76KEYCODE_AT 77KEYCODE_NUM 78KEYCODE_HEADSETHOOK 79KEYCODE_FOCUS 80KEYCODE_PLUS 81KEYCODE_MENU 82KEYCODE_NOTIFICATION 83KEYCODE_SEARCH 84TAGLAST KEYCODE 85 ","version":"Next","tagName":"h2"},{"title":"Storages 本地储存","type":0,"sectionRef":"#","url":"/docs/rhino/base/storages","content":"","keywords":"","version":"Next"},{"title":"storages.create(name)​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storagescreatename","content":" name {string} 本地存储名称  创建一个本地存储并返回一个Storage对象。不同名称的本地存储的数据是隔开的，而相同名称的本地存储的数据是共享的。  例如在一个脚本中，创建名称为 ABC 的存储并存入 a=123:  var storage = storages.create(&quot;ABC&quot;); storage.put(&quot;a&quot;, 123);   而在另一个脚本中是可以获取到 ABC 以及 a 的值的：  var storage = storages.create(&quot;ABC&quot;); log(&quot;a = &quot; + storage.get(&quot;a&quot;));   因此，本地存储的名称比较重要，尽量使用含有域名、作者邮箱等唯一信息的名称来避免冲突，例如：  var storage = storages.create(&quot;2732014414@qq.com:ABC&quot;);   ","version":"Next","tagName":"h2"},{"title":"storages.remove(name)​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storagesremovename","content":" name {string} 本地存储名称  删除一个本地存储以及他的全部数据。如果该存储不存在，返回 false；否则返回 true。  Storage  ","version":"Next","tagName":"h2"},{"title":"Storage.get(key[, defaultValue])​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storagegetkey-defaultvalue","content":" key {string} 键值defaultValue {any} 可选，默认值  从本地存储中取出键值为 key 的数据并返回。  如果该存储中不包含该数据，这时若指定了默认值参数则返回默认值，否则返回 undefined。  返回的数据可能是任意数据类型，这取决于使用Storage.put保存该键值的数据时的数据类型。  ","version":"Next","tagName":"h2"},{"title":"Storage.put(key, value)​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storageputkey-value","content":" key {string} 键值value {any} 值  把值 value 保存到本地存储中。value 可以是 undefined 以外的任意数据类型。如果 value 为 undefined 则抛出 TypeError。  存储的过程实际上是使用 JSON.stringify 把 value 转换为字符串再保存，因此 value 必须是可 JSON 化的才能被接受。  ","version":"Next","tagName":"h2"},{"title":"Storage.remove(key)​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storageremovekey","content":" key {string} 键值  移除键值为 key 的数据。不返回任何值。  ","version":"Next","tagName":"h2"},{"title":"Storage.contains(key)​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storagecontainskey","content":" key {string} 键值  返回该本地存储是否包含键值为 key 的数据。是则返回 true，否则返回 false。  ","version":"Next","tagName":"h2"},{"title":"Storage.clear()​","type":1,"pageTitle":"Storages 本地储存","url":"/docs/rhino/base/storages#storageclear","content":" 移除该本地存储的所有数据。不返回任何值。 ","version":"Next","tagName":"h2"},{"title":"Dialogs 对话框","type":0,"sectionRef":"#","url":"/docs/rhino/base/dialogs","content":"","keywords":"","version":"Next"},{"title":"dialogs.alert(title[, content, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsalerttitle-content-callback","content":" title {string} 对话框的标题。content {string} 可选，对话框的内容。默认为空。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个只包含“确定”按钮的提示对话框。直至用户点击确定脚本才继续运行。  该函数也可以作为全局函数使用。  alert(&quot;出现错误~&quot;, &quot;出现未知错误，请联系脚本作者”);   在 ui 模式下该函数返回一个Promise。例如:  &quot;ui&quot;; alert(&quot;嘿嘿嘿&quot;).then(() =&gt; { //当点击确定后会执行这里 });   ","version":"Next","tagName":"h2"},{"title":"dialogs.confirm(title[, content, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsconfirmtitle-content-callback","content":" title {string} 对话框的标题。content {string} 可选，对话框的内容。默认为空。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个包含“确定”和“取消”按钮的提示对话框。如果用户点击“确定”则返回 true ，否则返回 false 。  该函数也可以作为全局函数使用。  在 ui 模式下该函数返回一个Promise。例如:  &quot;ui&quot;; confirm(&quot;确定吗&quot;).then((value) =&gt; { //当点击确定后会执行这里, value为true或false, 表示点击&quot;确定&quot;或&quot;取消&quot; });   ","version":"Next","tagName":"h2"},{"title":"dialogs.rawInput(title[, prefill, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsrawinputtitle-prefill-callback","content":" title {string} 对话框的标题。prefill {string} 输入框的初始内容，可选，默认为空。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个包含输入框的对话框，等待用户输入内容，并在用户点击确定时将输入的字符串返回。如果用户取消了输入，返回 null。  该函数也可以作为全局函数使用。  var name = rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;); alert(&quot;您的名字是&quot; + name);   在 ui 模式下该函数返回一个Promise。例如:  &quot;ui&quot;; rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;).then((name) =&gt; { alert(&quot;您的名字是&quot; + name); });   当然也可以使用回调函数，例如:  rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;, (name) =&gt; { alert(&quot;您的名字是&quot; + name); });   ","version":"Next","tagName":"h2"},{"title":"dialogs.input(title[, prefill, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsinputtitle-prefill-callback","content":" 等效于 eval(dialogs.rawInput(title, prefill, callback)), 该函数和 rawInput 的区别在于，会把输入的字符串用 eval 计算一遍再返回，返回的可能不是字符串。  可以用该函数输入数字、数组等。例如：  var age = dialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;); // new Date().getYear() + 1900 可获取当前年份 var year = new Date().getYear() + 1900 - age; alert(&quot;您的出生年份是&quot; + year);   在 ui 模式下该函数返回一个Promise。例如:  &quot;ui&quot;; dialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;).then((age) =&gt; { var year = new Date().getYear() + 1900 - age; alert(&quot;您的出生年份是&quot; + year); });   ","version":"Next","tagName":"h2"},{"title":"dialogs.prompt(title[, prefill, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsprompttitle-prefill-callback","content":" 相当于 dialogs.rawInput();  ","version":"Next","tagName":"h2"},{"title":"dialogs.select(title, items, callback)​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsselecttitle-items-callback","content":" title {string} 对话框的标题。items {Array} 对话框的选项列表，是一个字符串数组。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个带有选项列表的对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。  var options = [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;]; var i = dialogs.select(&quot;请选择一个选项&quot;, options); if (i &gt;= 0) { toast(&quot;您选择的是&quot; + options[i]); } else { toast(&quot;您取消了选择&quot;); }   在 ui 模式下该函数返回一个Promise。例如:  &quot;ui&quot;; dialogs .select(&quot;请选择一个选项&quot;, [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;]) .then((i) =&gt; { toast(i); });   ","version":"Next","tagName":"h2"},{"title":"dialogs.singleChoice(title, items[, index, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogssinglechoicetitle-items-index-callback","content":" title {string} 对话框的标题。items {Array} 对话框的选项列表，是一个字符串数组。index {number} 对话框的初始选项的位置，默认为 0。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个单选列表对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。  在 ui 模式下该函数返回一个Promise。  ","version":"Next","tagName":"h2"},{"title":"dialogs.multiChoice(title, items[, indices, callback])​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsmultichoicetitle-items-indices-callback","content":" title {string} 对话框的标题。items {Array} 对话框的选项列表，是一个字符串数组。indices {Array} 选项列表中初始选中的项目索引的数组，默认为空数组。callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于 ui 模式。  显示一个多选列表对话框，等待用户选择，返回用户选择的选项索引的数组。如果用户取消了选择，返回[]。  在 ui 模式下该函数返回一个Promise。  ","version":"Next","tagName":"h2"},{"title":"dialogs.build(properties)​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialogsbuildproperties","content":" properties {Object} 对话框属性，用于配置对话框。返回 {Dialog}  创建一个可自定义的对话框，例如：  dialogs .build({ //对话框标题 title: &quot;发现新版本&quot;, //对话框内容 content: &quot;更新日志: 新增了若干了BUG&quot;, //确定键内容 positive: &quot;下载&quot;, //取消键内容 negative: &quot;取消&quot;, //中性键内容 neutral: &quot;到浏览器下载&quot;, //勾选框内容 checkBoxPrompt: &quot;不再提示&quot;, }) .on(&quot;positive&quot;, () =&gt; { //监听确定键 toast(&quot;开始下载....&quot;); }) .on(&quot;neutral&quot;, () =&gt; { //监听中性键 app.openUrl(&quot;https://www.autojs.org&quot;); }) .on(&quot;check&quot;, (checked) =&gt; { //监听勾选框 log(checked); }) .show();   选项 properties 可供配置的项目为:  title {string} 对话框标题titleColor {string} | {number} 对话框标题的颜色buttonRippleColor {string} | {number} 对话框按钮的波纹效果颜色icon {string} | {Image} 对话框的图标，是一个 URL 或者图片对象content {string} 对话框文字内容contentColor{string} | {number} 对话框文字内容的颜色contentLineSpacing{number} 对话框文字内容的行高倍数，1.0 为一倍行高items {Array} 对话框列表的选项itemsColor {string} | {number} 对话框列表的选项的文字颜色itemsSelectMode {string} 对话框列表的选项选择模式，可以为: select 普通选择模式single 单选模式multi 多选模式 itemsSelectedIndex {number} | {Array} 对话框列表中预先选中的项目索引，如果是单选模式为一个索引；多选模式则为数组positive {string} 对话框确定按钮的文字内容(最右边按钮)positiveColor {string} | {number} 对话框确定按钮的文字颜色(最右边按钮)neutral {string} 对话框中立按钮的文字内容(最左边按钮)neutralColor {string} | {number} 对话框中立按钮的文字颜色(最左边按钮)negative {string} 对话框取消按钮的文字内容(确定按钮左边的按钮)negativeColor {string} | {number} 对话框取消按钮的文字颜色(确定按钮左边的按钮)checkBoxPrompt {string} 勾选框文字内容checkBoxChecked {boolean} 勾选框是否勾选progress {Object} 配置对话框进度条的对象： max {number} 进度条的最大值，如果为-1 则为无限循环的进度条horizontal {boolean} 如果为 true, 则对话框无限循环的进度条为水平进度条showMinMax {boolean} 是否显示进度条的最大值和最小值 cancelable {boolean} 对话框是否可取消，如果为 false，则对话框只能用代码手动取消canceledOnTouchOutside {boolean} 对话框是否在点击对话框以外区域时自动取消，默认为 trueinputHint {string} 对话框的输入框的输入提示inputPrefill {string} 对话框输入框的默认输入内容  通过这些选项可以自定义一个对话框，并通过监听返回的 Dialog 对象的按键、输入事件来实现交互。下面是一些例子。  模拟 alert 对话框：  dialogs .build({ title: &quot;你好&quot;, content: &quot;今天也要元气满满哦&quot;, positive: &quot;好的&quot;, }) .show();   模拟 confirm 对话框:  dialogs .build({ title: &quot;你好&quot;, content: &quot;请问你是笨蛋吗?&quot;, positive: &quot;是的&quot;, negative: &quot;我是大笨蛋&quot;, }) .on(&quot;positive&quot;, () =&gt; { alert(&quot;哈哈哈笨蛋&quot;); }) .on(&quot;negative&quot;, () =&gt; { alert(&quot;哈哈哈大笨蛋&quot;); }) .show();   模拟单选框:  dialogs .build({ title: &quot;单选&quot;, items: [&quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot;, &quot;选项4&quot;], itemsSelectMode: &quot;single&quot;, itemsSelectedIndex: 3, }) .on(&quot;single_choice&quot;, (index, item) =&gt; { toast(&quot;您选择的是&quot; + item); }) .show();   &quot;处理中&quot;对话框:  var d = dialogs .build({ title: &quot;下载中...&quot;, progress: { max: -1, }, cancelable: false, }) .show(); setTimeout(() =&gt; { d.dismiss(); }, 3000);   输入对话框:  dialogs .build({ title: &quot;请输入您的年龄&quot;, inputPrefill: &quot;18&quot;, }) .on(&quot;input&quot;, (input) =&gt; { var age = parseInt(input); toastLog(age); }) .show();   使用这个函数来构造对话框，一个明显的不同是需要使用回调函数而不能像 dialogs 其他函数一样同步地返回结果；但也可以通过 threads 模块的方法来实现。例如显示一个输入框并获取输入结果为：  var input = threads.disposable(); dialogas .build({ title: &quot;请输入您的年龄&quot;, inputPrefill: &quot;18&quot;, }) .on(&quot;input&quot;, (text) =&gt; { input.setAndNotify(text); }) .show(); var age = parseInt(input.blockedGet()); tosatLog(age);   Dialog  dialogs.build()返回的对话框对象，内置一些事件用于响应用户的交互，也可以获取对话框的状态和信息。  ","version":"Next","tagName":"h2"},{"title":"事件: show​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-show","content":" dialog {Dialog} 对话框  对话框显示时会触发的事件。例如：  dialogs .build({ title: &quot;标题&quot;, }) .on(&quot;show&quot;, (dialog) =&gt; { toast(&quot;对话框显示了&quot;); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: cancel​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-cancel","content":" dialog {Dialog} 对话框  对话框被取消时会触发的事件。一个对话框可能按取消按钮、返回键取消或者点击对话框以外区域取消。例如：  dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, }) .on(&quot;cancel&quot;, (dialog) =&gt; { toast(&quot;对话框取消了&quot;); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: dismiss​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-dismiss","content":" dialog {Dialog} 对话框  对话框消失时会触发的事件。对话框被取消或者手动调用dialog.dismiss()函数都会触发该事件。例如：  var d = dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, }) .on(&quot;dismiss&quot;, (dialog) =&gt; { toast(&quot;对话框消失了&quot;); }) .show(); setTimeout(() =&gt; { d.dismiss(); }, 5000);   ","version":"Next","tagName":"h2"},{"title":"事件: positive​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-positive","content":" dialog {Dialog} 对话框  确定按钮按下时触发的事件。例如：  var d = dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, }) .on(&quot;positive&quot;, (dialog) =&gt; { toast(&quot;你点击了确定&quot;); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: negative​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-negative","content":" dialog {Dialog} 对话框  取消按钮按下时触发的事件。例如：  var d = dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, }) .on(&quot;negative&quot;, (dialog) =&gt; { toast(&quot;你点击了取消&quot;); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: neutral​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-neutral","content":" dialog {Dialog} 对话框  中性按钮按下时触发的事件。例如：  var d = dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, neutral: &quot;稍后提示&quot;, }) .on(&quot;positive&quot;, (dialog) =&gt; { toast(&quot;你点击了稍后提示&quot;); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: any​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-any","content":" dialog {Dialog} 对话框action {string} 被点击的按钮，可能的值为: positive 确定按钮negative 取消按钮neutral 中性按钮  任意按钮按下时触发的事件。例如:  var d = dialogs .build({ title: &quot;标题&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, neutral: &quot;稍后提示&quot;, }) .on(&quot;any&quot;, (action, dialog) =&gt; { if (action == &quot;positive&quot;) { toast(&quot;你点击了确定&quot;); } else if (action == &quot;negative&quot;) { toast(&quot;你点击了取消&quot;); } }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: item_select​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-item_select","content":" index {number} 被选中的项目索引，从 0 开始item {Object} 被选中的项目dialog {Dialog} 对话框  对话框列表(itemsSelectMode 为&quot;select&quot;)的项目被点击选中时触发的事件。例如：  var d = dialogs .build({ title: &quot;请选择&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], itemsSelectMode: &quot;select&quot;, }) .on(&quot;item_select&quot;, (index, item, dialog) =&gt; { toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: single_choice​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-single_choice","content":" index {number} 被选中的项目索引，从 0 开始item {Object} 被选中的项目dialog {Dialog} 对话框  对话框单选列表(itemsSelectMode 为&quot;singleChoice&quot;)的项目被选中并点击确定时触发的事件。例如：  var d = dialogs .build({ title: &quot;请选择&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], itemsSelectMode: &quot;singleChoice&quot;, }) .on(&quot;item_select&quot;, (index, item, dialog) =&gt; { toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: multi_choice​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-multi_choice","content":" indices {Array} 被选中的项目的索引的数组items {Array} 被选中的项目的数组dialog {Dialog} 对话框  对话框多选列表(itemsSelectMode 为&quot;multiChoice&quot;)的项目被选中并点击确定时触发的事件。例如：  var d = dialogs.build({ title: &quot;请选择&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;], itemsSelectMode: &quot;multiChoice&quot; }).on(&quot;item_select&quot;, (indices, items, dialog)=&gt;{ toast(util.format(&quot;您选择的项目为%o, 选项为%o&quot;, indices, items); }).show();   ","version":"Next","tagName":"h2"},{"title":"事件: input​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-input","content":" text {string} 输入框的内容dialog {Dialog} 对话框  带有输入框的对话框当点击确定时会触发的事件。例如：  dialogs .build({ title: &quot;请输入&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, inputPrefill: &quot;&quot;, }) .on(&quot;input&quot;, (text, dialog) =&gt; { toast(&quot;你输入的是&quot; + text); }) .show();   ","version":"Next","tagName":"h2"},{"title":"事件: input_change​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#事件-input_change","content":" text {string} 输入框的内容dialog {Dialog} 对话框  对话框的输入框的文本发生变化时会触发的事件。例如：  dialogs .build({ title: &quot;请输入&quot;, positive: &quot;确定&quot;, negative: &quot;取消&quot;, inputPrefill: &quot;&quot;, }) .on(&quot;input_change&quot;, (text, dialog) =&gt; { toast(&quot;你输入的是&quot; + text); }) .show();   ","version":"Next","tagName":"h2"},{"title":"dialog.getProgress()​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialoggetprogress","content":" 返回 {number}  获取当前进度条的进度值，是一个整数  ","version":"Next","tagName":"h2"},{"title":"dialog.getMaxProgress()​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialoggetmaxprogress","content":" 返回 {number}  获取当前进度条的最大进度值，是一个整数  ","version":"Next","tagName":"h2"},{"title":"dialog.getActionButton(action)​","type":1,"pageTitle":"Dialogs 对话框","url":"/docs/rhino/base/dialogs#dialoggetactionbuttonaction","content":" action {string} 动作，包括: positivenegativeneutral ","version":"Next","tagName":"h2"},{"title":"Timers 定时器","type":0,"sectionRef":"#","url":"/docs/rhino/base/timers","content":"","keywords":"","version":"Next"},{"title":"setInterval(callback, delay[, ...args])​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#setintervalcallback-delay-args","content":" callback {Function} 当定时器到点时要调用的函数。delay {number} 调用 callback 之前要等待的毫秒数。...args {any} 当调用 callback 时要传入的可选参数。  预定每隔 delay 毫秒重复执行的 callback。 返回一个用于 clearInterval() 的 id。  当 delay 小于 0 时，delay 会被设为 0。  ","version":"Next","tagName":"h2"},{"title":"setTimeout(callback, delay[, ...args])​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#settimeoutcallback-delay-args","content":" callback {Function} 当定时器到点时要调用的函数。delay {number} 调用 callback 之前要等待的毫秒数。...args {any} 当调用 callback 时要传入的可选参数。  预定在 delay 毫秒之后执行的单次 callback。 返回一个用于 clearTimeout() 的 id。  callback 可能不会精确地在 delay 毫秒被调用。 Auto.js 不能保证回调被触发的确切时间，也不能保证它们的顺序。 回调会在尽可能接近所指定的时间上调用。  当 delay 小于 0 时，delay 会被设为 0。  ","version":"Next","tagName":"h2"},{"title":"setImmediate(callback[, ...args])​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#setimmediatecallback-args","content":" callback {Function} 在 Looper 循环的当前回合结束时要调用的函数。...args {any} 当调用 callback 时要传入的可选参数。  预定立即执行的 callback，它是在 I/O 事件的回调之后被触发。 返回一个用于 clearImmediate() 的 id。  当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。  setImmediate()、setInterval() 和 setTimeout() 方法每次都会返回表示预定的计时器的 id。 它们可用于取消定时器并防止触发。  ","version":"Next","tagName":"h2"},{"title":"clearInterval(id)​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#clearintervalid","content":" id {number} 一个 setInterval() 返回的 id。  取消一个由 setInterval() 创建的循环定时任务。  例如：  //每5秒就发出一次hello var id = setInterval(function () { toast(&quot;hello&quot;); }, 5000); //1分钟后取消循环 setTimeout(function () { clearInterval(id); }, 60 * 1000);   ","version":"Next","tagName":"h2"},{"title":"clearTimeout(id)​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#cleartimeoutid","content":" id {number} 一个 setTimeout() 返回的 id。  取消一个由 setTimeout() 创建的定时任务。  ","version":"Next","tagName":"h2"},{"title":"clearImmediate(id)​","type":1,"pageTitle":"Timers 定时器","url":"/docs/rhino/base/timers#clearimmediateid","content":" id {number} 一个 setImmediate() 返回的 id。  取消一个由 setImmediate() 创建的 Immediate 对象。 ","version":"Next","tagName":"h2"},{"title":"MQTT","type":0,"sectionRef":"#","url":"/docs/rhino/base/mqtt","content":"","keywords":"","version":"Next"},{"title":"代码示例​","type":1,"pageTitle":"MQTT","url":"/docs/rhino/base/mqtt#代码示例","content":" 主题订阅、发布、QOS、遗嘱消息  importPackage(Packages[&quot;org.eclipse.paho.client.mqttv3&quot;]); importClass(&quot;org.eclipse.paho.android.service.MqttAndroidClient&quot;); // 连接、订阅配置 const MQTT_URL = &quot;tcp://192.168.20.225:1883&quot;; const CLIENT_ID = &quot;MOCK&quot;; const TOPIC = &quot;ANDROID_MOCK&quot;; const QOS = 2; const USERNAME = &quot;device&quot;; const PASSWORD = &quot;public&quot;; const client = new MqttAndroidClient(context, MQTT_URL, CLIENT_ID); const subscribeToTopic = () =&gt; { try { client.subscribe( TOPIC, QOS, null, new IMqttActionListener({ onSuccess: (token) =&gt; { toast(&quot;MQTT 订阅成功&quot;); }, onFailure: (token, error) =&gt; { toast(&quot;MQTT 订阅失败 &quot; + error); }, }) ); } catch (error) { toast(error.message); alert('MQTT订阅错误\\n\\n&quot;' + error.message); } }; const initMQTT = () =&gt; { // 创建配置 const mqttConnectOptions = new MqttConnectOptions(); mqttConnectOptions.setAutomaticReconnect(true); mqttConnectOptions.setCleanSession(true); mqttConnectOptions.setUserName(USERNAME); mqttConnectOptions.setPassword(Array.from(PASSWORD)); // 遗嘱消息 QOS = 1, retained = true let willMsgJavaString = new java.lang.String(&quot;i am gone&quot;); let willMsgJavaBytes = willMsgJavaString.getBytes(&quot;UTF-8&quot;); mqttConnectOptions.setWill(&quot;device-gone&quot;, willMsgJavaBytes, 1, true); console.log(&quot;mqttConnectOptions&quot;, mqttConnectOptions); const callback = new MqttCallbackExtended({ connectComplete: (reconnect, serverUri) =&gt; { if (reconnect) { subscribeToTopic(); console.log(&quot;重新连接到MQTT&quot;); } else { console.log(&quot;连接到MQTT&quot;); } }, connectionLost: () =&gt; { console.log(&quot;MQTT 连接丢失&quot;); }, messageArrived: (topic, message) =&gt; { console.log(&quot;MQTT MESSAGE: &quot;, topic, message); }, }); client.setCallback(callback); client.connect( mqttConnectOptions, null, new IMqttActionListener({ onSuccess: () =&gt; { console.log(&quot;mqtt连接成功&quot;); subscribeToTopic(); }, onFailure: (token, error) =&gt; { console.error(&quot;mqtt连接失败&quot;, error); exit(); }, }) ); }; const publish = (topic, msg, qos = 1, retained = false) =&gt; { // publish message try { let javaString = new java.lang.String(msg); let byteArray = javaString.getBytes(&quot;UTF-8&quot;); client.publish(topic, byteArray, qos, retained); } catch (error) { console.error(&quot;MQTT 发布失败&quot;, error); } }; // 连接 initMQTT(); setTimeout(() =&gt; { toast(&quot;7秒后自动关闭&quot;); // send message publish(TOPIC, &quot;hello&quot;); }, 3000); // 断开并退出 setTimeout(() =&gt; { client.close(); client.disconnect(); toast(&quot;自动关闭并退出脚本&quot;); exit(); }, 10 * 1000); // 防止进程退出 setInterval(() =&gt; { // }, 1000);  ","version":"Next","tagName":"h2"},{"title":"关于本文档","type":0,"sectionRef":"#","url":"/docs/rhino/documentation","content":"","keywords":"","version":"Next"},{"title":"websocket","type":0,"sectionRef":"#","url":"/docs/rhino/base/websocket","content":"","keywords":"","version":"Next"},{"title":"创建websocket客户端​","type":1,"pageTitle":"websocket","url":"/docs/rhino/base/websocket#创建websocket客户端","content":" 创建一个http client，可以设定client是否重连，心跳等功能创建一个request 请求对象，采用什么协议ws 或wss 、服务器、端口都能内容设置监听，当websocket 生命周期内的一些事情。设置上面的操作以后，打开链接，创建webSocket 客户端。用webSocket 客户端 发送消息 webSocket.send(&quot;你好服务器&quot;);  importPackage(Packages[&quot;okhttp3&quot;]); //导入包 var client = new OkHttpClient.Builder().retryOnConnectionFailure(true).build(); var request = new Request.Builder().url(&quot;ws://192.168.31.164:9317&quot;).build(); //vscode 插件的ip地址， client.dispatcher().cancelAll();//清理一次 myListener = { onOpen: function (webSocket, response) { print(&quot;onOpen&quot;); //打开链接后，想服务器端发送一条消息 var json = {}; json.type=&quot;hello&quot;; json.data= {device_name:&quot;模拟设备&quot;,client_version:123,app_version:123,app_version_code:&quot;233&quot;}; var hello=JSON.stringify(json); webSocket.send(hello); }, onMessage: function (webSocket, msg) { //msg可能是字符串，也可能是byte数组，取决于服务器送的内容 print(&quot;msg&quot;); print(msg); }, onClosing: function (webSocket, code, response) { print(&quot;正在关闭&quot;); }, onClosed: function (webSocket, code, response) { print(&quot;已关闭&quot;); }, onFailure: function (webSocket, t, response) { print(&quot;错误&quot;); print( t); } } var webSocket= client.newWebSocket(request, new WebSocketListener(myListener)); //创建链接 setInterval(() =&gt; { // 防止主线程退出 }, 1000);   创建 websocket 服务器端，一样支持，可以参考 okhttp 官网。 ","version":"Next","tagName":"h2"},{"title":"API 稳定性​","type":1,"pageTitle":"关于本文档","url":"/docs/rhino/documentation#api-稳定性","content":" 由于 AutoX.js 处于活跃的更新和开发状态，API 可能随时有变动，我们用 稳定性 来标记模块、函数的稳定性。  这些标记包括：  稳定性: 弃用 弃用的函数、模块或特性， 在未来的更新中将很快会被移除或更改。应该在脚本中移除对这些函数的使用，以免后续出现意料之外的问题。   稳定性: 实验 实验性的函数、模块或特性， 在未来的更新中可能会更改或移除。应该谨慎使用这些函数或模块，或者仅用作临时或试验用途。   稳定性: 稳定 稳定的函数、模块或特性， 在未来的更新中这些模块已有的函数一般不会被更改，会保证后向兼容性。   ","version":"Next","tagName":"h2"},{"title":"如何阅读本文档​","type":1,"pageTitle":"关于本文档","url":"/docs/rhino/documentation#如何阅读本文档","content":" 先看一个例子，下面是 基于控件的操作 的章节中 input 函数的部分说明。  ","version":"Next","tagName":"h2"},{"title":"input([i, ]text)​","type":1,"pageTitle":"关于本文档","url":"/docs/rhino/documentation#inputi-text","content":" i {number} 表示要输入的为第 i + 1 个输入框text {string} 要输入的文本  input表示函数名，([i, ]text)表示要传入两个参数：i, text。[i, ]表示i是可选参数，即i可有可无.  下方是函数说明，i表示参数名称，{number}表示参数i的类型为数值，表示要输入...是对参数i的详细说明  //执行这个语句会在屏幕上的第2个输入框处输入&quot;啦啦啦&quot;。 input(1, &quot;啦啦啦&quot;);   //这个语句会在屏幕上所有输入框输入&quot;嘿嘿嘿&quot;。 input(&quot;嘿嘿嘿&quot;);   我们再看第二个例子。图片和图色处理中 detectsColor 函数的部分说明。  ","version":"Next","tagName":"h2"},{"title":"images.detectsColor(image, color, x, y[, threshold = 16, algorithm = \"diff\"])​","type":1,"pageTitle":"关于本文档","url":"/docs/rhino/documentation#imagesdetectscolorimage-color-x-y-threshold--16-algorithm--diff","content":" image {Image} 图片color {number} | {string} 要检测的颜色x {number} 要检测的位置横坐标y {number} 要检测的位置纵坐标threshold {number} 颜色相似度临界值，默认为 16。取值范围为 0~255。algorithm {string} 颜色匹配算法，包括: equal: 相等匹配，只有与给定颜色 color 完全相等时才匹配。diff: 差值匹配。与给定颜色的 R、G、B 差的绝对值之和小于 threshold 时匹配。rgb: rgb 欧拉距离相似度。与给定颜色 color 的 rgb 欧拉距离小于等于 threshold 时匹配。rgb: 加权 rgb 欧拉距离匹配(LAB Delta E)。hs: hs 欧拉距离匹配。hs 为 HSV 空间的色调值。  threshold = 16表示如果不指定该参数，则 threshold 的值为16  images.detectsColor(captureScreen(), &quot;#112233&quot;, 100, 200); //相当于 images.detectsColor(captureScreen(), &quot;#112233&quot;, 100, 200, 16, &quot;rgb&quot;);   images.detectsColor(captureScreen(), &quot;#112233&quot;, 100, 200, 64); //相当于 images.detectsColor(captureScreen(), &quot;#112233&quot;, 100, 200, 64, &quot;rgb&quot;);   调用有可选参数及默认值的函数时请不要写上方括号和等于号。 ","version":"Next","tagName":"h2"},{"title":"cheerio","type":0,"sectionRef":"#","url":"/docs/rhino/npm/cheerio","content":"cheerio v6.3.9新增 稳定性: 稳定 这是一个用于解析和生成html/xml的库，使用方法请参阅官方网站，该模块不会自动加载，如需使用 const cheerio = require('cheerio'); 这里简单介绍一下在autojs中的用途。 当你有一个变量，想让它的内容嵌入到ui界面中时你可能会这么做 let text = &quot;变量文本&quot; ui.layout( &lt;vertical&gt; &lt;text text=&quot;{{text}}&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;text text=&quot;{{text}}&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;/vertical&gt;) //或是 ui.layout(` &lt;vertical&gt; &lt;text text=&quot;${text}&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;text text=&quot;${text}&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;/vertical&gt;`) //或是 ui.layout( &lt;vertical&gt; &lt;text id=&quot;text1&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;text id=&quot;text2&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;/vertical&gt;) ui.text1.setText(text) ui.text2.setText(text) 这3种方法无论哪种都有些缺陷，第一种变量不是全局的则会报错，第二种字符串不能包含特殊字符，否则解析xml时报错，第三种调用安卓方法有一定的性能问题，且不够灵活。 使用cheerio则可以像这样处理: const cheerio = require('cheerio'); let text = &quot;变量文本&quot; let $ = cheerio.load( `&lt;vertical&gt; &lt;text class=&quot;text&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;text class=&quot;text&quot; textColor=&quot;#000000&quot; textSize=&quot;18sp&quot; maxLines=&quot;1&quot; /&gt; &lt;/vertical&gt;`,{ xmlMode:true }) $('.text').text(text); let xml = $.xml() log(xml) ui.layout(xml) 高级的用法还可以将xml组件化，列表生成等","keywords":"","version":"Next"},{"title":"Buffer","type":0,"sectionRef":"#","url":"/docs/rhino/npm/buffer","content":"","keywords":"","version":"Next"},{"title":"Buffer.prototype.getBytes()​","type":1,"pageTitle":"Buffer","url":"/docs/rhino/npm/buffer#bufferprototypegetbytes","content":" 返回 buffer 内部 ArrayBuffer 所对应的 java 字节数组  let buf = Buffer.alloc(10); let buf2 = Buffer.from(buf.buffer, 0, 5); buf[0] = 40; buf2[2] = 7; log(buf.getBytes() === buf2.getBytes()); //true   ","version":"Next","tagName":"h2"},{"title":"Buffer.fromBytes(byteArr)​","type":1,"pageTitle":"Buffer","url":"/docs/rhino/npm/buffer#bufferfrombytesbytearr","content":" byteArr {&lt;byte&gt;[]} java 字节数组  从字节数组创建一个 buffer，其内容是原数据的拷贝。 ","version":"Next","tagName":"h2"},{"title":"events","type":0,"sectionRef":"#","url":"/docs/rhino/npm/events","content":"events v6.4.0新增 稳定性: 稳定 node中events的实现，如需使用，请用 const events = require('events') ","keywords":"","version":"Next"},{"title":"event-stream","type":0,"sectionRef":"#","url":"/docs/rhino/npm/event-stream","content":"event-stream v6.4.0新增 稳定性: 稳定 来自npm模块event-stream，如需使用，请用 const es = require('event-stream') 该模块用于便捷的创建流，完整说明见项目主页可读流: es.readable(function (count, callback) { if(streamHasEnded) return this.emit('end') //... this.emit('data', data) //use this way to emit multiple chunks per call. callback() // you MUST always call the callback eventually. // the function will not be called again until you do this. }) 转换流: var es = require('event-stream') es.map(function (data, callback) { //transform data // ... callback(null, data) }) 可写流: var es = require('event-stream') es.map(function (data, callback) { // ... callback(null, null) }) 例子: const es = require(&quot;event-stream&quot;); //创建一个可读流 let e = 0 let r = es.readable(function(count, callback) { if (e &gt; (10)) return this.emit('end') this.emit('data', String(e)); e++; return callback() }); //转换流 let map = es.map(function (data, callback) { data = `--${data}--` callback(null, data) }) //可写流，这里是将数据打印出来 let w = es.map(function (data, callback) { log(data) callback(null, null) }) w.on('close',()=&gt;{ log('操作完成') }); r.pipe(map).pipe(w);//将3个流连起来 例子2（配合io流使用）: const es = require(&quot;event-stream&quot;); const stream = require(&quot;stream&quot;) let r = stream.createFileReadStream( '/sdcard/文本文件.txt' ) //可写流，这里是将数据打印出来 let w = es.map(function (data, callback) { log(data) callback(null, null) }) //连通流，其中es.split()是一个流，负责将数据按行输出 r.pipe(es.split()).pipe(w) ","keywords":"","version":"Next"},{"title":"Lodash","type":0,"sectionRef":"#","url":"/docs/rhino/npm/lodash","content":"Lodash v6.5.2新增 稳定性: 稳定 Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库，使用方法请参阅中文文档，该模块不会自动加载，请使用以下方法导入 // Load the full build. var _ = require('lodash'); // Load the core build. var _ = require('lodash/core'); // Load the FP build for immutable auto-curried iteratee-first data-last methods. var fp = require('lodash/fp'); // Load method categories. var array = require('lodash/array'); var object = require('lodash/fp/object'); // Cherry-pick methods for smaller browserify/rollup/webpack bundles. var at = require('lodash/at'); var curryN = require('lodash/fp/curryN'); ","keywords":"","version":"Next"},{"title":"stream","type":0,"sectionRef":"#","url":"/docs/rhino/npm/stream","content":"","keywords":"","version":"Next"},{"title":"stream.fromInputStream(inputStream[,options])​","type":1,"pageTitle":"stream","url":"/docs/rhino/npm/stream#streamfrominputstreaminputstreamoptions","content":" inputStream {InputStream} java 输入流options {object} 选项,详细见 node 文档  将 java 流转为 Readable 可读流，为提高处理速度，默认的缓冲区大小被设为 64kb，io 操作由内部 io 线程处理  ","version":"Next","tagName":"h2"},{"title":"stream.fromOutputStream(outputStream[,options])​","type":1,"pageTitle":"stream","url":"/docs/rhino/npm/stream#streamfromoutputstreamoutputstreamoptions","content":" outputStream {OutputStream} java 输出流options {object} 选项,详细见 node 文档  将 java 流转为 Writable 可写流，为提高处理速度，默认的缓冲区大小被设为 64kb，io 操作由内部 io 线程处理  ","version":"Next","tagName":"h2"},{"title":"stream.createFileReadStream(path[,bufferSize])​","type":1,"pageTitle":"stream","url":"/docs/rhino/npm/stream#streamcreatefilereadstreampathbuffersize","content":" path {String} 文件路径bufferSize {Number} 缓冲区大小，默认 256k  从文件创建一个可读流  ","version":"Next","tagName":"h2"},{"title":"stream.createFileWriteStream(path[,bufferSize])​","type":1,"pageTitle":"stream","url":"/docs/rhino/npm/stream#streamcreatefilewritestreampathbuffersize","content":" path {String} 文件路径bufferSize {Number} 缓冲区大小，默认 256k  从文件创建一个可写流 ","version":"Next","tagName":"h2"},{"title":"基于控件的操作","type":0,"sectionRef":"#","url":"/docs/rhino/base/widgetsBasedAutomation","content":"","keywords":"","version":"Next"},{"title":"auto([mode])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#automode","content":" mode {string} 模式  检查无障碍服务是否已经启用，如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为 mode。mode 的可选值为：  fast 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。normal 正常模式，默认。  如果不加 mode 参数，则为正常模式。  建议使用auto.waitFor()和auto.setMode()代替该函数，因为auto()函数如果无障碍服务未启动会停止脚本；而auto.waitFor()则会在在无障碍服务启动后继续运行。  示例：  auto(&quot;fast&quot;);   示例 2：  auto();   ","version":"Next","tagName":"h2"},{"title":"auto.waitFor()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#autowaitfor","content":" 检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。  ","version":"Next","tagName":"h2"},{"title":"auto.setMode(mode)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#autosetmodemode","content":" mode {string} 模式  设置无障碍模式为 mode。mode 的可选值为：  fast 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件查看和操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。normal 正常模式，默认。  SimpleActionAutomator  稳定性: 稳定  SimpleActionAutomator 提供了一些模拟简单操作的函数，例如点击文字、模拟按键等。这些函数可以直接作为全局函数使用。  ","version":"Next","tagName":"h2"},{"title":"click(text[, i])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#clicktext-i","content":" text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则 i 表示要点击第几个文本, i 从 0 开始计算  返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。  该函数可以点击大部分包含文字的按钮。例如微信主界面下方的&quot;微信&quot;, &quot;联系人&quot;, &quot;发现&quot;, &quot;我&quot;的按钮。 通常与 while 同时使用以便点击按钮直至成功。例如:  while (!click(&quot;扫一扫&quot;));   当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部点击成功。  i 是从 0 开始计算的, 也就是, click(&quot;啦啦啦&quot;, 0)表示点击屏幕上第一个&quot;啦啦啦&quot;, click(&quot;啦啦啦&quot;, 1)表示点击屏幕上第二个&quot;啦啦啦&quot;。  文本所在区域指的是，从文本处向其父视图寻找，直至发现一个可点击的部件为止。  ","version":"Next","tagName":"h2"},{"title":"click(left, top, bottom, right)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#clickleft-top-bottom-right","content":" left {number} 要点击的长方形区域左边与屏幕左边的像素距离top {number} 要点击的长方形区域上边与屏幕上边的像素距离bottom {number} 要点击的长方形区域下边与屏幕下边的像素距离right {number} 要点击的长方形区域右边与屏幕右边的像素距离  注意，该函数一般只用于录制的脚本中使用，在自己写的代码中使用该函数一般不要使用该函数。  点击在指定区域的控件。当屏幕中并未包含与该区域严格匹配的区域，或者该区域不能点击时返回 false，否则返回 true。  有些按钮或者部件是图标而不是文字（例如发送朋友圈的照相机图标以及 QQ 下方的消息、联系人、动态图标），这时不能通过click(text, i)来点击，可以通过描述图标所在的区域来点击。left, bottom, top, right 描述的就是点击的区域。  至于要定位点击的区域，可以在悬浮窗使用布局分析工具查看控件的 bounds 属性。  通过无障碍服务录制脚本会生成该语句。  ","version":"Next","tagName":"h2"},{"title":"longClick(text[, i]))​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#longclicktext-i","content":" text {string} 要长按的文本i {number} 如果相同的文本在屏幕中出现多次，则 i 表示要长按第几个文本, i 从 0 开始计算  返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。  当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部长按成功。  ","version":"Next","tagName":"h2"},{"title":"scrollUp([i])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#scrollupi","content":" i {number} 要滑动的控件序号  找到第 i+1 个可滑动控件上滑或左滑。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。  另外不加参数时scrollUp()会寻找面积最大的可滑动的控件上滑或左滑，例如微信消息列表等。  参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如scrollUp(0)为滑动第一个可滑动控件。  ","version":"Next","tagName":"h2"},{"title":"scrollDown([i])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#scrolldowni","content":" i {number} 要滑动的控件序号  找到第 i+1 个可滑动控件下滑或右滑。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。  另外不加参数时scrollUp()会寻找面积最大的可滑动的控件下滑或右滑。  参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如scrollUp(0)为滑动第一个可滑动控件。  ","version":"Next","tagName":"h2"},{"title":"setText([i, ]text)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#settexti-text","content":" i {number} 表示要输入的为第 i + 1 个输入框text {string} 要输入的文本  返回是否输入成功。当找不到对应的文本框时返回 false。  不加参数 i 则会把所有输入框的文本都置为 text。例如setText(&quot;测试&quot;)。  这里的输入文本的意思是，把输入框的文本置为 text，而不是在原来的文本上追加。  ","version":"Next","tagName":"h2"},{"title":"input([i, ]text)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#inputi-text","content":" i {number} 表示要输入的为第 i + 1 个输入框text {string} 要输入的文本  返回是否输入成功。当找不到对应的文本框时返回 false。  不加参数 i 则会把所有输入框的文本追加内容 text。例如input(&quot;测试&quot;)。  UiSelector  UiSelector 即选择器，用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作。这里需要先简单介绍一下控件和界面的相关知识。  一般软件的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控件的位置，例如，线性布局(LinearLayout)里面的控件都是按水平或垂直一次叠放的，列表布局(AbsListView)则是以列表的形式显示控件。  控件有各种属性，包括文本(text), 描述(desc), 类名(className), id 等等。我们通常用一个控件的属性来找到这个控件，例如，想要点击 QQ 聊天窗口的&quot;发送&quot;按钮，我们就可以通过他的文本属性为&quot;发送&quot;来找到这个控件并点击他，具体代码为:  var sendButton = text(&quot;发送&quot;).findOne(); sendButton.click();   在这个例子中, text(&quot;发送&quot;)表示一个条件(文本属性为&quot;发送&quot;)，findOne()表示基于这个条件找到一个符合条件的控件，从而我们可以得到发送按钮 sendButton，再执行sendButton.click()即可点击&quot;发送&quot;按钮。  用文本属性来定位按钮控件、文本控件通常十分有效。但是，如果一个控件是图片控件，比如 Auto.js 主界面右上角的搜索图标，他没有文本属性，这时需要其他属性来定位他。我们如何查看他有什么属性呢？首先打开悬浮窗和无障碍服务，点击蓝色的图标(布局分析), 可以看到以下界面：  之后我们点击搜索图标，可以看到他有以下属性：  我们注意到这个图标的 desc(描述)属性为&quot;搜索&quot;，那么我们就可以通过 desc 属性来定位这个控件，得到点击搜索图标的代码为:  desc(&quot;搜索&quot;).findOne().click();   可能心细的你可能注意到了，这个控件还有很多其他的属性，例如 checked, className, clickable 等等，为什么不用这些属性来定位搜索图标呢？答案是，其他控件也有这些值相同的属性、尝试一下你就可以发现很多其他控件的 checked 属性和搜索控件一样都是false，如果我们用checked(false)作为条件，将会找到很多控件，而无法确定哪一个是搜索图标。因此，要找到我们想要的那个控件，选择器的条件通常需要是可唯一确定控件的。我们通常用一个独一无二的属性来定位一个控件，例如这个例子中就没有其他控件的 desc(描述)属性为&quot;搜索&quot;。  另外，对于这个搜索图标而言，id 属性也是唯一的，我们也可以用id(&quot;action_search&quot;).findOne().click()来点击这个控件。如果一个控件有 id 属性，那么这个属性很可能是唯一的，除了以下几种情况：  QQ 的控件的 id 属性很多都是&quot;name&quot;，也就是在 QQ 界面难以通过 id 来定位一个控件列表中的控件，比如 QQ 联系人列表，微信联系人列表等  尽管 id 属性很方便，但也不总是最方便的，例如对于微信和网易云音乐，每次更新他的控件 id 都会变化，导致了相同代码对于不同版本的微信、网易云音乐并不兼容。  除了这些属性外，主要还有以下几种属性：  className 类名。类名表示一个控件的类型，例如文本控件为&quot;android.widget.TextView&quot;, 图片控件为&quot;android.widget.ImageView&quot;等。packageName 包名。包名表示控件所在的应用包名，例如 QQ 界面的控件的包名为&quot;com.tencent.mobileqq&quot;。bounds 控件在屏幕上的范围。drawingOrder 控件在父控件的绘制顺序。indexInParent 控件在父控件的位置。clickable 控件是否可点击。longClickable 控件是否可长按。checkable 控件是否可勾选。checked 控件是否可已勾选。scrollable 控件是否可滑动。selected 控件是否已选择。editable 控件是否可编辑。visibleToUser 控件是否可见。enabled 控件是否已启用。depth 控件的布局深度。  有时候只靠一个属性并不能唯一确定一个控件，这时需要通过属性的组合来完成定位，例如className(&quot;ImageView&quot;).depth(10).findOne().click()，通过链式调用来组合条件。  通常用这些技巧便可以解决大部分问题，即使解决不了问题，也可以通过布局分析的&quot;生成代码&quot;功能来尝试生成一些选择器代码。接下来的问题便是对选取的控件进行操作，包括：  click() 点击。点击一个控件，前提是这个控件的 clickable 属性为 truelongClick() 长按。长按一个控件，前提是这个控件的 longClickable 属性为 truesetText() 设置文本，用于编辑框控件设置文本。scrollForward(), scrollBackward() 滑动。滑动一个控件(列表等), 前提是这个控件的 scrollable 属性为 trueexits() 判断控件是否存在waitFor() 等待控件出现  这些操作包含了绝大部分控件操作。根据这些我们可以很容易写出一个&quot;刷屏&quot;脚本(代码仅为示例，请不要在别人的群里测试，否则容易被踢):  while (true) { className(&quot;EditText&quot;).findOne().setText(&quot;刷屏...&quot;); text(&quot;发送&quot;).findOne().clicK(); }   上面这段代码也可以写成：  while (true) { className(&quot;EditText&quot;).setText(&quot;刷屏...&quot;); text(&quot;发送&quot;).clicK(); }   如果不加findOne()而直接进行操作，则选择器会找出所有符合条件的控件并操作。  另外一个比较常用的操作的滑动。滑动操作的第一步是找到需要滑动的控件，例如要滑动 QQ 消息列表则在悬浮窗布局层次分析中找到AbsListView，这个控件就是消息列表控件，如下图：  长按可查看控件信息，注意到其 scrollable 属性为 true，并找出其 id 为&quot;recent_chat_list&quot;，从而下滑 QQ 消息列表的代码为：  id(&quot;recent_chat_list&quot;).className(&quot;AbsListView&quot;).findOne().scrollForward();   scrollForward()为向前滑，包括下滑和右滑。  选择器的入门教程暂且要这里，更多信息可以查看下面的文档和选择器进阶。  ","version":"Next","tagName":"h2"},{"title":"selector()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#selector","content":" 返回 {UiSelector}  创建一个新的选择器。但一般情况不需要使用该函数，因为可以直接用相应条件的语句创建选择器。  由于历史遗留原因，本不应该这样设计(不应该让id(), text()等作为全局函数，而是应该用By.id(), By.text())，但为了后向兼容性只能保留这个设计。  这样的 API 设计会污染全局变量，后续可能会支持&quot;去掉这些全局函数而使用 By.***&quot;的选项。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.text(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectortextstr","content":" str {string} 控件文本返回 {UiSelector} 返回选择器自身以便链式调用  为当前选择器附加控件&quot;text 等于字符串 str&quot;的筛选条件。  控件的 text(文本)属性是文本控件上的显示的文字，例如微信左上角的&quot;微信&quot;文本。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.textContains(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectortextcontainsstr","content":" str {string} 要包含的字符串  为当前选择器附加控件&quot;text 需要包含字符串 str&quot;的筛选条件。  这是一个比较有用的条件，例如 QQ 动态页和微博发现页上方的&quot;大家都在搜....&quot;的控件可以用textContains(&quot;大家都在搜&quot;).findOne()来获取。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.textStartsWith(prefix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectortextstartswithprefix","content":" prefix {string} 前缀  为当前选择器附加控件&quot;text 需要以 prefix 开头&quot;的筛选条件。  这也是一个比较有用的条件，例如要找出 Auto.js 脚本列表中名称以&quot;QQ&quot;开头的脚本的代码为textStartsWith(&quot;QQ&quot;).find()。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.textEndsWith(suffix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectortextendswithsuffix","content":" suffix {string} 后缀  为当前选择器附加控件&quot;text 需要以 suffix 结束&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.textMatches(reg)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectortextmatchesreg","content":" reg {string} | {Regex} 要满足的正则表达式。  为当前选择器附加控件&quot;text 需要满足正则表达式 reg&quot;的条件。  有关正则表达式，可以查看正则表达式 - 菜鸟教程。  需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java 正则表达式的形式)，例如textMatches(&quot;\\\\d+&quot;)匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以&quot;/&quot;同时以&quot;/&quot;结束，也即不能写诸如textMatches(&quot;/\\\\d+/&quot;)的表达式，否则会被开头的&quot;/&quot;和结尾的&quot;/&quot;会被忽略。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.desc(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordescstr","content":" str {string} 控件文本返回 {UiSelector} 返回选择器自身以便链式调用  为当前选择器附加控件&quot;desc 等于字符串 str&quot;的筛选条件。  控件的 desc(描述，全称为 Content-Description)属性是对一个控件的描述，例如网易云音乐右上角的放大镜图标的描述为搜索。要查看一个控件的描述，同样地可以借助悬浮窗查看。  desc 属性同样是定位控件的利器。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.descContains(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordesccontainsstr","content":" str {string} 要包含的字符串  为当前选择器附加控件&quot;desc 需要包含字符串 str&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.descStartsWith(prefix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordescstartswithprefix","content":" prefix {string} 前缀  为当前选择器附加控件&quot;desc 需要以 prefix 开头&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.descEndsWith(suffix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordescendswithsuffix","content":" suffix {string} 后缀  为当前选择器附加控件&quot;desc 需要以 suffix 结束&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.descMatches(reg)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordescmatchesreg","content":" reg {string} | {Regex} 要满足的正则表达式。  为当前选择器附加控件&quot;desc 需要满足正则表达式 reg&quot;的条件。  有关正则表达式，可以查看正则表达式 - 菜鸟教程。  需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java 正则表达式的形式)，例如textMatches(&quot;\\\\d+&quot;)匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以&quot;/&quot;同时以&quot;/&quot;结束，也即不能写诸如textMatches(&quot;/\\\\d+/&quot;)的表达式，否则会被开头的&quot;/&quot;和结尾的&quot;/&quot;会被忽略。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.id(resId)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoridresid","content":" resId {string} 控件的 id，以&quot;包名:id/&quot;开头，例如&quot;com.tencent.mm:id/send_btn&quot;。也可以不指定包名，这时会以当前正在运行的应用的包名来补全 id。例如 id(&quot;send_btn&quot;),在 QQ 界面想当于 id(&quot;com.tencent.mobileqq:id/send_btn&quot;)。  为当前选择器附加&quot;id 等于 resId&quot;的筛选条件。  控件的 id 属性通常是可以用来确定控件的唯一标识，如果一个控件有 id，那么使用 id 来找到他是最好的方法。要查看屏幕上的控件的 id，可以开启悬浮窗并使用界面工具，点击相应控件即可查看。若查看到的控件 id 为 null, 表示该控件没有 id。另外，在列表中会出现多个控件的 id 相同的情况。例如微信的联系人列表，每个头像的 id 都是一样的。此时不能用 id 来唯一确定控件。  在 QQ 界面经常会出现多个 id 为&quot;name&quot;的控件，在微信上则每个版本的 id 都会变化。对于这些软件而言比较难用 id 定位控件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.idContains(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoridcontainsstr","content":" str {string} id 要包含的字符串  为当前选择器附加控件&quot;id 包含字符串 str&quot;的筛选条件。比较少用。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.idStartsWith(prefix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoridstartswithprefix","content":" prefix {string} id 前缀  为当前选择器附加&quot;id 需要以 prefix 开头&quot;的筛选条件。比较少用。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.idEndsWith(suffix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoridendswithsuffix","content":" suffix {string} id 后缀  为当前选择器附加&quot;id 需要以 suffix 结束&quot;的筛选条件。比较少用。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.idMatches(reg)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoridmatchesreg","content":" reg {Regex} | {string} id 要满足的正则表达式  附加 id 需要满足正则表达式。  需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java 正则表达式的形式)，例如textMatches(&quot;\\\\d+&quot;)匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以&quot;/&quot;同时以&quot;/&quot;结束，也即不能写诸如textMatches(&quot;/\\\\d+/&quot;)的表达式，否则会被开头的&quot;/&quot;和结尾的&quot;/&quot;会被忽略。  idMatches(&quot;[a-zA-Z]+&quot;);   ","version":"Next","tagName":"h2"},{"title":"UiSelector.className(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclassnamestr","content":" str {string} 控件文本返回 {UiSelector} 返回选择器自身以便链式调用  为当前选择器附加控件&quot;className 等于字符串 str&quot;的筛选条件。  控件的 className(类名)表示一个控件的类别，例如文本控件的类名为 android.widget.TextView。  如果一个控件的类名以&quot;android.widget.&quot;开头，则可以省略这部分，例如文本控件可以直接用className(&quot;TextView&quot;)的选择器。  常见控件的类名如下：  android.widget.TextView 文本控件android.widget.ImageView 图片控件android.widget.Button 按钮控件android.widget.EditText 输入框控件android.widget.AbsListView 列表控件android.widget.LinearLayout 线性布局android.widget.FrameLayout 帧布局android.widget.RelativeLayout 相对布局android.widget.RelativeLayout 相对布局android.support.v7.widget.RecyclerView 通常也是列表控件  ","version":"Next","tagName":"h2"},{"title":"UiSelector.classNameContains(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclassnamecontainsstr","content":" str {string} 要包含的字符串  为当前选择器附加控件&quot;className 需要包含字符串 str&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.classNameStartsWith(prefix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclassnamestartswithprefix","content":" prefix {string} 前缀  为当前选择器附加控件&quot;className 需要以 prefix 开头&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.classNameEndsWith(suffix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclassnameendswithsuffix","content":" suffix {string} 后缀  为当前选择器附加控件&quot;className 需要以 suffix 结束&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.classNameMatches(reg)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclassnamematchesreg","content":" reg {string} | {Regex} 要满足的正则表达式。  为当前选择器附加控件&quot;className 需要满足正则表达式 reg&quot;的条件。  有关正则表达式，可以查看正则表达式 - 菜鸟教程。  需要注意的是，如果正则表达式是字符串，则需要使用\\\\来表达\\(也即 Java 正则表达式的形式)，例如textMatches(&quot;\\\\d+&quot;)匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如textMatches(/\\d+/)。但如果使用字符串的正则表达式则该字符串不能以&quot;/&quot;同时以&quot;/&quot;结束，也即不能写诸如textMatches(&quot;/\\\\d+/&quot;)的表达式，否则会被开头的&quot;/&quot;和结尾的&quot;/&quot;会被忽略。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.packageName(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorpackagenamestr","content":" str {string} 控件文本返回 {UiSelector} 返回选择器自身以便链式调用  为当前选择器附加控件&quot;packageName 等于字符串 str&quot;的筛选条件。  控件的 packageName 表示控件所属界面的应用包名。例如微信的包名为&quot;com.tencent.mm&quot;, 那么微信界面的控件的 packageName 为&quot;com.tencent.mm&quot;。  要查看一个应用的包名，可以用函数app.getPackageName()获取，例如toast(app.getPackageName(&quot;微信&quot;))。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.packageNameContains(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorpackagenamecontainsstr","content":" str {string} 要包含的字符串  为当前选择器附加控件&quot;packageName 需要包含字符串 str&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.packageNameStartsWith(prefix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorpackagenamestartswithprefix","content":" prefix {string} 前缀  为当前选择器附加控件&quot;packageName 需要以 prefix 开头&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.packageNameEndsWith(suffix)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorpackagenameendswithsuffix","content":" suffix {string} 后缀  为当前选择器附加控件&quot;packageName 需要以 suffix 结束&quot;的筛选条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.packageNameMatches(reg)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorpackagenamematchesreg","content":" reg {string} | {Regex} 要满足的正则表达式。  为当前选择器附加控件&quot;packageName 需要满足正则表达式 reg&quot;的条件。  有关正则表达式，可以查看正则表达式 - 菜鸟教程。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.bounds(left, top, right, buttom)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorboundsleft-top-right-buttom","content":" left {number} 控件左边缘与屏幕左边的距离top {number} 控件上边缘与屏幕上边的距离right {number} 控件右边缘与屏幕左边的距离bottom {number} 控件下边缘与屏幕上边的距离  一个控件的 bounds 属性为这个控件在屏幕上显示的范围。我们可以用这个范围来定位这个控件。尽管用这个方法定位控件对于静态页面十分准确，却无法兼容不同分辨率的设备；同时对于列表页面等动态页面无法达到效果，因此使用不推荐该选择器。  注意参数的这四个数字不能随意填写，必须精确的填写控件的四个边界才能找到该控件。例如，要点击 QQ 主界面的右上角加号，我们用布局分析查看该控件的属性，如下图：  可以看到 bounds 属性为(951, 67, 1080, 196)，此时使用代码bounds(951, 67, 1080, 196).clickable().click()即可点击该控件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.boundsInside(left, top, right, buttom)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorboundsinsideleft-top-right-buttom","content":" left {number} 范围左边缘与屏幕左边的距离top {number} 范围上边缘与屏幕上边的距离right {number} 范围右边缘与屏幕左边的距离bottom {number} 范围下边缘与屏幕上边的距离  为当前选择器附加控件&quot;bounds 需要在 left, top, right, buttom 构成的范围里面&quot;的条件。  这个条件用于限制选择器在某一个区域选择控件。例如要在屏幕上半部分寻找文本控件 TextView，代码为:  var w = className(&quot;TextView&quot;) .boundsInside(0, 0, device.width, device.height / 2) .findOne(); log(w.text());   其中我们使用了device.width来获取屏幕宽度，device.height来获取屏幕高度。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.boundsContains(left, top, right, buttom)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorboundscontainsleft-top-right-buttom","content":" left {number} 范围左边缘与屏幕左边的距离top {number} 范围上边缘与屏幕上边的距离right {number} 范围右边缘与屏幕左边的距离bottom {number} 范围下边缘与屏幕上边的距离  为当前选择器附加控件&quot;bounds 需要包含 left, top, right, buttom 构成的范围&quot;的条件。  这个条件用于限制控件的范围必须包含所给定的范围。例如给定一个点(500, 300), 寻找在这个点上的可点击控件的代码为:  var w = boundsContains(500, 300, device.width - 500, device.height - 300) .clickable() .findOne(); w.click();   ","version":"Next","tagName":"h2"},{"title":"UiSelector.drawingOrder(order)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectordrawingorderorder","content":" order {number} 控件在父视图中的绘制顺序  为当前选择器附加控件&quot;drawingOrder 等于 order&quot;的条件。  drawingOrder 为一个控件在父控件中的绘制顺序，通常可以用于区分同一层次的控件。  但该属性在 Android 7.0 以上才能使用。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.clickable([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorclickableb--true","content":" b {Boolean} 表示控件是否可点击  为当前选择器附加控件是否可点击的条件。但并非所有 clickable 为 false 的控件都真的不能点击，这取决于控件的实现。对于自定义控件(例如显示类名为 android.view.View 的控件)很多的 clickable 属性都为 false 都却能点击。  需要注意的是，可以省略参数b而表示选择那些可以点击的控件，例如className(&quot;ImageView&quot;).clickable()表示可以点击的图片控件的条件，className(&quot;ImageView&quot;).clickable(false)表示不可点击的图片控件的条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.longClickable([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorlongclickableb--true","content":" b {Boolean} 表示控件是否可长按  为当前选择器附加控件是否可长按的条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.checkable([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorcheckableb--true","content":" b {Boolean} 表示控件是否可勾选  为当前选择器附加控件是否可勾选的条件。勾选通常是对于勾选框而言的，例如图片多选时左上角通常有一个勾选框。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.selected([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorselectedb--true","content":" b {Boolean} 表示控件是否被选  为当前选择器附加控件是否已选中的条件。被选中指的是，例如 QQ 聊天界面点击下方的&quot;表情按钮&quot;时，会出现自己收藏的表情，这时&quot;表情按钮&quot;便处于选中状态，其 selected 属性为 true。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.enabled([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorenabledb--true","content":" b {Boolean} 表示控件是否已启用  为当前选择器附加控件是否已启用的条件。大多数控件都是启用的状态(enabled 为 true)，处于“禁用”状态通常是灰色并且不可点击。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.scrollable([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorscrollableb--true","content":" b {Boolean} 表示控件是否可滑动  为当前选择器附加控件是否可滑动的条件。滑动包括上下滑动和左右滑动。  可以用这个条件来寻找可滑动控件来滑动界面。例如滑动 Auto.js 的脚本列表的代码为:  className(&quot;android.support.v7.widget.RecyclerView&quot;) .scrollable() .findOne() .scrollForward(); //或者classNameEndsWith(&quot;RecyclerView&quot;).scrollable().findOne().scrollForward();   ","version":"Next","tagName":"h2"},{"title":"UiSelector.editable([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoreditableb--true","content":" b {Boolean} 表示控件是否可编辑  为当前选择器附加控件是否可编辑的条件。一般来说可编辑的控件为输入框(EditText)，但不是所有的输入框(EditText)都可编辑。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.multiLine([b = true])​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectormultilineb--true","content":" b {Boolean} 表示文本或输入框控件是否是多行显示的  为当前选择器附加控件是否文本或输入框控件是否是多行显示的条件。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.findOne()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfindone","content":" 返回 UiObject  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件。如果找不到控件，当屏幕内容发生变化时会重新寻找，直至找到。  需要注意的是，如果屏幕上一直没有出现所描述的控件，则该函数会阻塞，直至所描述的控件出现为止。因此此函数不会返回null。  该函数本来应该命名为untilFindOne()，但由于历史遗留原因已经无法修改。如果想要只在屏幕上搜索一次而不是一直搜索，请使用findOnce()。  另外，如果屏幕上有多个满足条件的控件，findOne()采用深度优先搜索(DFS)，会返回该搜索算法找到的第一个控件。注意控件找到的顺序有时会起到作用。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.findOne(timeout)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfindonetimeout","content":" timeout {number} 搜索的超时时间，单位毫秒返回 UiObject  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件；如果在 timeout 毫秒的时间内没有找到符合条件的控件，则终止搜索并返回null。  该函数类似于不加参数的findOne()，只不过加上了时间限制。  示例：  //启动Auto.js launchApp(&quot;Auto.js&quot;); //在6秒内找出日志图标的控件 var w = id(&quot;action_log&quot;).findOne(6000); //如果找到控件则点击 if (w != null) { w.click(); } else { //否则提示没有找到 toast(&quot;没有找到日志图标&quot;); }   ","version":"Next","tagName":"h2"},{"title":"UiSelector.findOnce()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfindonce","content":" 返回 UiObject  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，如果找到符合条件的控件则返回该控件；否则返回null。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.findOnce(i)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfindoncei","content":" i {number} 索引  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，并返回第 i + 1 个符合条件的控件；如果没有找到符合条件的控件，或者符合条件的控件个数 &lt; i, 则返回null。  注意这里的控件次序，是搜索算法深度优先搜索(DSF)决定的。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.find()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfind","content":" 返回 UiCollection  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，找到所有满足条件的控件集合并返回。这个搜索只进行一次，并不保证一定会找到，因而会出现返回的控件集合为空的情况。  不同于findOne()或者findOnce()只找到一个控件并返回一个控件，find()函数会找出所有满足条件的控件并返回一个控件集合。之后可以对控件集合进行操作。  可以通过 empty()函数判断找到的是否为空。例如：  var c = className(&quot;AbsListView&quot;).find(); if (c.empty()) { toast(&quot;没找到╭(╯^╰)╮&quot;); } else { toast(&quot;找到啦&quot;); }   ","version":"Next","tagName":"h2"},{"title":"UiSelector.untilFind()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectoruntilfind","content":" 返回 UiCollection  根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到找到至少一个满足条件的控件为止，并返回所有满足条件的控件集合。  该函数与find()函数的区别在于，该函数永远不会返回空集合；但是，如果屏幕上一直没有出现满足条件的控件，则该函数会保持阻塞。  ","version":"Next","tagName":"h2"},{"title":"UiSelector.exists()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorexists","content":" 返回 {Boolean}  判断屏幕上是否存在控件符合选择器所确定的条件。例如要判断某个文本出现就执行某个动作，可以用：  if (text(&quot;某个文本&quot;).exists()) { //要支持的动作 }   ","version":"Next","tagName":"h2"},{"title":"UiSelector.waitFor()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorwaitfor","content":" 等待屏幕上出现符合条件的控件；在满足该条件的控件出现之前，该函数会一直保持阻塞。  例如要等待包含&quot;哈哈哈&quot;的文本控件出现的代码为：  textContains(&quot;哈哈哈&quot;).waitFor();   ","version":"Next","tagName":"h2"},{"title":"UiSelector.filter(f)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiselectorfilterf","content":" f {Function} 过滤函数，参数为 UiObject，返回值为 boolean  为当前选择器附加自定义的过滤条件。  例如，要找出屏幕上所有文本长度为 10 的文本控件的代码为：  var uc = className(&quot;TextView&quot;).filter(function (w) { return w.text().length == 10; });   UiObject  UiObject 表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。  获取一个 UiObject 通常通过选择器的findOne(), findOnce()等函数，也可以通过 UiCollection 来获取，或者通过UiObject.child(), UiObject.parent()等函数来获取一个控件的子控件或父控件。  ","version":"Next","tagName":"h2"},{"title":"UiObject.click()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectclick","content":" 返回 {Boolean}  点击该控件，并返回是否点击成功。  如果该函数返回 false，可能是该控件不可点击(clickable 为 false)，当前界面无法响应该点击等。  ","version":"Next","tagName":"h2"},{"title":"UiObject.longClick()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectlongclick","content":" 返回 {Boolean}  长按该控件，并返回是否点击成功。  如果该函数返回 false，可能是该控件不可点击(longClickable 为 false)，当前界面无法响应该点击等。  ","version":"Next","tagName":"h2"},{"title":"UiObject.setText(text)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectsettexttext","content":" text {string} 文本返回 {Boolean}  设置输入框控件的文本内容，并返回是否设置成功。  该函数只对可编辑的输入框(editable 为 true)有效。  ","version":"Next","tagName":"h2"},{"title":"UiObject.copy()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectcopy","content":" 返回 {Boolean}  对输入框文本的选中内容进行复制，并返回是否操作成功。  该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过setSelection()函数来设置输入框选中的内容。  var et = className(&quot;EditText&quot;).findOne(); //选中前两个字 et.setSelection(0, 2); //对选中内容进行复制 if (et.copy()) { toast(&quot;复制成功&quot;); } else { toast(&quot;复制失败&quot;); }   ","version":"Next","tagName":"h2"},{"title":"UiObject.cut()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectcut","content":" 对输入框文本的选中内容进行剪切，并返回是否操作成功。  该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过setSelection()函数来设置输入框选中的内容。  ","version":"Next","tagName":"h2"},{"title":"UiObject.paste()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectpaste","content":" 返回 {Boolean}  对输入框控件进行粘贴操作，把剪贴板内容粘贴到输入框中，并返回是否操作成功。  //设置剪贴板内容为“你好” setClip(&quot;你好&quot;); var et = className(&quot;EditText&quot;).findOne(); et.paste();   ","version":"Next","tagName":"h2"},{"title":"UiObject.setSelection(start, end)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectsetselectionstart-end","content":" start {number} 选中内容起始位置end {number} 选中内容结束位置(不包括)返回 {Boolean}  对输入框控件设置选中的文字内容，并返回是否操作成功。  索引是从 0 开始计算的；并且，选中内容不包含 end 位置的字符。例如，如果一个输入框内容为&quot;123456789&quot;，要选中&quot;4567&quot;的文字的代码为et.setSelection(3, 7)。  该函数也可以用来设置光标位置，只要参数的 end 等于 start，即可把输入框光标设置在 start 的位置。例如et.setSelection(1, 1)会把光标设置在第一个字符的后面。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollForward()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrollforward","content":" 返回 {Boolean}  对控件执行向前滑动的操作，并返回是否操作成功。  向前滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行scrollForward()的行为是未知的(这是因为 Android 文档没有指出这一点，同时也没有充分的测试可供参考)。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollBackward()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrollbackward","content":" 返回 {Boolean}  对控件执行向后滑动的操作，并返回是否操作成功。  向后滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行scrollForward()的行为是未知的(这是因为 Android 文档没有指出这一点，同时也没有充分的测试可供参考)。  ","version":"Next","tagName":"h2"},{"title":"UiObject.select()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectselect","content":" 返回 {Boolean}  对控件执行&quot;选中&quot;操作，并返回是否操作成功。&quot;选中&quot;和isSelected()的属性相关，但该操作十分少用。  ","version":"Next","tagName":"h2"},{"title":"UiObject.collapse()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectcollapse","content":" 返回 {Boolean}  对控件执行折叠操作，并返回是否操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.expand()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectexpand","content":" 返回 {Boolean}  对控件执行操作，并返回是否操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.show()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectshow","content":" 对集合中所有控件执行显示操作，并返回是否全部操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollUp()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrollup","content":" 对集合中所有控件执行向上滑的操作，并返回是否全部操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollDown()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrolldown","content":" 对集合中所有控件执行向下滑的操作，并返回是否全部操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollLeft()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrollleft","content":" 对集合中所有控件执行向左滑的操作，并返回是否全部操作成功。  ","version":"Next","tagName":"h2"},{"title":"UiObject.scrollRight()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uiobjectscrollright","content":" ","version":"Next","tagName":"h2"},{"title":"children()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#children","content":" 返回 UiCollection  返回该控件的所有子控件组成的控件集合。可以用于遍历一个控件的子控件，例如：  className(&quot;AbsListView&quot;) .findOne() .children() .forEach(function (child) { log(child.className()); });   ","version":"Next","tagName":"h2"},{"title":"childCount()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#childcount","content":" 返回 {number}  返回子控件数目。  ","version":"Next","tagName":"h2"},{"title":"child(i)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#childi","content":" i {number} 子控件索引返回 {UiObject}  返回第 i+1 个子控件。如果 i&gt;=控件数目或者小于 0，则抛出异常。  需要注意的是，由于布局捕捉的问题，该函数可能返回null，也就是可能获取不到某个子控件。  遍历子控件的示例：  var list = className(&quot;AbsListView&quot;).findOne(); for (var i = 0; i &lt; list.childCount(); i++) { var child = list.child(i); log(child.className()); }   ","version":"Next","tagName":"h2"},{"title":"parent()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#parent","content":" 返回 {UiObject}  返回该控件的父控件。如果该控件没有父控件，返回null。  ","version":"Next","tagName":"h2"},{"title":"bounds()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#bounds","content":" 返回 Rect  返回控件在屏幕上的范围，其值是一个Rect对象。  示例：  var b = text(&quot;Auto.js&quot;).findOne().bounds(); toast(&quot;控件在屏幕上的范围为&quot; + b);   如果一个控件本身无法通过click()点击，那么我们可以利用bounds()函数获取其坐标，再利用坐标点击。例如：  var b = desc(&quot;打开侧拉菜单&quot;).findOne().bounds(); click(b.centerX(), b.centerY()); //如果使用root权限，则用 Tap(b.centerX(), b.centerY());   ","version":"Next","tagName":"h2"},{"title":"boundsInParent()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#boundsinparent","content":" 返回 Rect  返回控件在父控件中的范围，其值是一个Rect对象。  ","version":"Next","tagName":"h2"},{"title":"drawingOrder()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#drawingorder","content":" 返回 {number}  返回控件在父控件中的绘制次序。该函数在安卓 7.0 及以上才有效，7.0 以下版本调用会返回 0。  ","version":"Next","tagName":"h2"},{"title":"id()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#id","content":" 返回 {string}  获取控件的 id，如果一个控件没有 id，则返回null。  ","version":"Next","tagName":"h2"},{"title":"text()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#text","content":" 返回 {string}  获取控件的文本，如果控件没有文本，返回&quot;&quot;。  ","version":"Next","tagName":"h2"},{"title":"findByText(str)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#findbytextstr","content":" str {string} 文本返回 UiCollection  根据文本 text 在子控件中递归地寻找并返回文本或描述(desc)包含这段文本 str 的控件，返回它们组成的集合。  该函数会在当前控件的子控件，孙控件，曾孙控件...中搜索 text 或 desc 包含 str 的控件，并返回它们组合的集合。  ","version":"Next","tagName":"h2"},{"title":"findOne(selector)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#findoneselector","content":" selector UiSelector返回 UiOobject  根据选择器 selector 在该控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回null。  例如，对于酷安动态列表，我们可以遍历他的子控件(每个动态列表项)，并在每个子控件中依次寻找点赞数量和图标，对于点赞数量小于 10 的点赞：  //找出动态列表 var list = id(&quot;recycler_view&quot;).findOne(); //遍历动态 list.children().forEach(function (child) { //找出点赞图标 var like = child.findOne(id(&quot;feed_action_view_like&quot;)); //找出点赞数量 var likeCount = child.findOne(id(&quot;text_view&quot;)); //如果这两个控件没有找到就不继续了 if (like == null || likeCount == null) { return; } //判断点赞数量是否小于10 if (parseInt(likeCount.text()) &lt; 10) { //点赞 like.click(); } });   ","version":"Next","tagName":"h2"},{"title":"find(selector)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#findselector","content":" selector UiSelector返回 UiCollection  根据选择器 selector 在该控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回它们组合的集合。  UiCollection  UiCollection, 控件集合, 通过选择器的find(), untilFind()方法返回的对象。  UiCollection&quot;继承&quot;于数组，实际上是一个 UiObject 的数组，因此可以使用数组的函数和属性，例如使用 length 属性获取 UiCollection 的大小，使用 forEach 函数来遍历 UiCollection。  例如，采用 forEach 遍历屏幕上所有的文本控件并打印出文本内容的代码为：  console.show(); className(&quot;TextView&quot;) .find() .forEach(function (tv) { if (tv.text() != &quot;&quot;) { log(tv.text()); } });   也可以使用传统的数组遍历方式：  console.show(); var uc = className(&quot;TextView&quot;).find(); for (var i = 0; i &lt; uc.length; i++) { var tv = uc[i]; if (tv.text() != &quot;&quot;) { log(tv.text()); } }   UiCollection 的每一个元素都是 UiObject，我们可以取出他的元素进行操作，例如取出第一个 UiObject 并点击的代码为ui[0].click()。如果想要对该集合的所有元素进行操作，可以直接在集合上调用相应的函数，例如uc.click()，该代码会对集合上所有 UiObject 执行点击操作并返回是否全部点击成功。  因此，UiCollection 具有所有 UiObject 对控件操作的函数，包括click(), longClick(), scrollForward()等等，不再赘述。  ","version":"Next","tagName":"h2"},{"title":"UiCollection.size()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uicollectionsize","content":" 返回 {number}  返回集合中的控件数。  历史遗留函数，相当于属性 length。  ","version":"Next","tagName":"h2"},{"title":"UiCollection.get(i)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uicollectiongeti","content":" i {number} 索引返回 UiObject  返回集合中第 i+1 个控件(UiObject)。  历史遗留函数，建议直接使用数组下标的方式访问元素。  ","version":"Next","tagName":"h2"},{"title":"UiCollection.each(func)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uicollectioneachfunc","content":" func {Function} 遍历函数，参数为 UiObject。  遍历集合。  历史遗留函数，相当于forEach。参考forEach。  ","version":"Next","tagName":"h2"},{"title":"empty()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#empty","content":" 返回 {Boolean}  返回控件集合是否为空。  ","version":"Next","tagName":"h2"},{"title":"nonEmpty()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#nonempty","content":" 返回 {Boolean}  返回控件集合是否非空。  ","version":"Next","tagName":"h2"},{"title":"UiCollection.find(selector)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uicollectionfindselector","content":" selector UiSelector返回 UiCollection  根据 selector 所确定的条件在该控件集合的控件、子控件、孙控件...中找到所有符合条件的控件并返回找到的控件集合。  注意这会递归地遍历控件集合里所有的控件以及他们的子控件。和数组的filter函数不同。  例如：  var names = id(&quot;name&quot;).find(); //在集合 var clickableNames = names.find(clickable());   ","version":"Next","tagName":"h2"},{"title":"UiCollection.findOne(selector)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#uicollectionfindoneselector","content":" selector UiSelector返回 UiOobject  根据选择器 selector 在该控件集合的控件的子控件、孙控件...中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回null。  Rect  UiObject.bounds(), UiObject.boundsInParent()返回的对象。表示一个长方形(范围)。  ","version":"Next","tagName":"h2"},{"title":"Rect.left​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectleft","content":" {number}  长方形左边界的 x 坐标、  ","version":"Next","tagName":"h2"},{"title":"Rect.right​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectright","content":" {number}  长方形右边界的 x 坐标、  ","version":"Next","tagName":"h2"},{"title":"Rect.top​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#recttop","content":" {number}  长方形上边界的 y 坐标、  ","version":"Next","tagName":"h2"},{"title":"Rect.bottom​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectbottom","content":" {number}  长方形下边界的 y 坐标、  ","version":"Next","tagName":"h2"},{"title":"Rect.centerX()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectcenterx","content":" 返回 {number}  长方形中点 x 坐标。  ","version":"Next","tagName":"h2"},{"title":"Rect.centerY()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectcentery","content":" 返回 {number}  长方形中点 y 坐标。  ","version":"Next","tagName":"h2"},{"title":"Rect.width()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectwidth","content":" 返回 {number}  长方形宽度。通常可以作为控件宽度。  ","version":"Next","tagName":"h2"},{"title":"Rect.height()​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectheight","content":" 返回 {number}  长方形高度。通常可以作为控件高度。  ","version":"Next","tagName":"h2"},{"title":"Rect.contains(r)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectcontainsr","content":" r Rect  返回是否包含另一个长方形 r。包含指的是，长方形 r 在该长方形的里面(包含边界重叠的情况)。  ","version":"Next","tagName":"h2"},{"title":"Rect.intersect(r)​","type":1,"pageTitle":"基于控件的操作","url":"/docs/rhino/base/widgetsBasedAutomation#rectintersectr","content":" r Rect  返回是否和另一个长方形相交。  UiSelector 进阶  未完待续。 ","version":"Next","tagName":"h2"},{"title":"UI 用户界面","type":0,"sectionRef":"#","url":"/docs/rhino/base/ui","content":"","keywords":"","version":"Next"},{"title":"w​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#w","content":" View 的宽度，是属性width的缩写形式。可以设置的值为*, auto和具体数值。其中*表示宽度尽量填满父布局，而auto表示宽度将根据 View 的内容自动调整(自适应宽度)。例如：  &quot;ui&quot;; ui.layout( &lt;horizontal&gt; &lt;button w=&quot;auto&quot; text=&quot;自适应宽度&quot; /&gt; &lt;button w=&quot;*&quot; text=&quot;填满父布局&quot; /&gt; &lt;/horizontal&gt; );   在这个例子中，第一个按钮为自适应宽度，第二个按钮为填满父布局，显示效果为：    如果不设置该属性，则不同的控件和布局有不同的默认宽度，大多数为auto。  宽度属性也可以指定一个具体数值。例如w=&quot;20&quot;，w=&quot;20px&quot;等。不加单位的情况下默认单位为 dp，其他单位包括 px(像素), mm(毫米), in(英寸)。有关尺寸单位的更多内容，参见尺寸的单位: Dimension。  &quot;ui&quot;; ui.layout( &lt;horizontal&gt; &lt;button w=&quot;200&quot; text=&quot;宽度200dp&quot; /&gt; &lt;button w=&quot;100&quot; text=&quot;宽度100dp&quot; /&gt; &lt;/horizontal&gt; );   ","version":"Next","tagName":"h2"},{"title":"h​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#h","content":" View 的高度，是属性height的缩写形式。可以设置的值为*, auto和具体数值。其中*表示宽度尽量填满父布局，而auto表示宽度将根据 View 的内容自动调整(自适应宽度)。  如果不设置该属性，则不同的控件和布局有不同的默认高度，大多数为auto。  宽度属性也可以指定一个具体数值。例如h=&quot;20&quot;，h=&quot;20px&quot;等。不加单位的情况下默认单位为 dp，其他单位包括 px(像素), mm(毫米), in(英寸)。有关尺寸单位的更多内容，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"id​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#id","content":" View 的 id，用来区分一个界面下的不同控件和布局，一个界面的 id 在同一个界面下通常是唯一的，也就是一般不存在两个 View 有相同的 id。id 属性也是连接 xml 布局和 JavaScript 代码的桥梁，在代码中可以通过一个 View 的 id 来获取到这个 View，并对他进行操作(设置点击动作、设置属性、获取属性等)。例如：  &quot;ui&quot;; ui.layout( &lt;frame&gt; &lt;button id=&quot;ok&quot; text=&quot;确定&quot; /&gt; &lt;/frame&gt; ); //通过ui.ok获取到按钮控件 toast(ui.ok.getText());   这个例子中有一个按钮控件&quot;确定&quot;，id 属性为&quot;ok&quot;，那么我们可以在代码中使用ui.ok来获取他，再通过getText()函数获取到这个按钮控件的文本内容。 另外这个例子中使用帧布局(frame)是因为，我们只有一个控件，因此用于最简单的布局帧布局。  ","version":"Next","tagName":"h2"},{"title":"gravity​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#gravity","content":" View 的&quot;重力&quot;。用于决定 View 的内容相对于 View 的位置，可以设置的值为:  left 靠左right 靠右top 靠顶部bottom 靠底部center 居中center_vertical 垂直居中center_horizontal 水平居中  例如对于一个按钮控件，gravity=&quot;right&quot;会使其中的文本内容靠右显示。例如：  &quot;ui&quot;; ui.layout( &lt;frame&gt; &lt;button gravity=&quot;right&quot; w=&quot;*&quot; h=&quot;auto&quot; text=&quot;靠右的文字&quot; /&gt; &lt;/frame&gt; );   显示效果为:    这些属性是可以组合的，例如gravity=&quot;right|bottom&quot;的 View 他的内容会在右下角。  ","version":"Next","tagName":"h2"},{"title":"layout_gravity​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#layout_gravity","content":" View 在布局中的&quot;重力&quot;，用于决定 View 本身在他的父布局的位置，可以设置的值和 gravity 属性相同。注意把这个属性和 gravity 属性区分开来。  &quot;ui&quot;; ui.layout( &lt;frame w=&quot;*&quot; h=&quot;*&quot;&gt; &lt;button layout_gravity=&quot;center&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;居中的按钮&quot; /&gt; &lt;button layout_gravity=&quot;right|bottom&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;右下角的按钮&quot; /&gt; &lt;/frame&gt; );   在这个例子中，我们让帧布局(frame)的大小占满整个屏幕，通过给第一个按钮设置属性layout_gravity=&quot;center&quot;来使得按钮在帧布局中居中，通过给第二个按钮设置属性layout_gravity=&quot;right|bottom&quot;使得他在帧布局中位于右下角。效果如图：    要注意的是，layout_gravity 的属性不一定总是生效的，具体取决于布局的类别。例如不能让水平布局中的第一个子控件靠底部显示(否则和水平布局本身相违背)。  ","version":"Next","tagName":"h2"},{"title":"margin​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#margin","content":" margin 为 View 和其他 View 的间距，即外边距。margin 属性包括四个值:  marginLeft 左外边距marginRight 右外边距marginTop 上外边距marginBottom 下外边距  而 margin 属性本身的值可以有三种格式:  margin=&quot;marginAll&quot; 指定各个外边距都是该值。例如margin=&quot;10&quot;表示左右上下边距都是 10dp。margin=&quot;marginLeft marginTop marginRight marginBottom&quot; 分别指定各个外边距。例如margin=&quot;10 20 30 40&quot;表示左边距为 10dp, 上边距为 20dp, 右边距为 30dp, 下边距为 40dpmargin=&quot;marginHorizontal marginVertical&quot; 指定水平外边距和垂直外边距。例如margin=&quot;10 20&quot;表示左右边距为 10dp, 上下边距为 20dp。  用一个例子来具体理解外边距的含义：  &quot;ui&quot;; ui.layout( &lt;horizontal&gt; &lt;button margin=&quot;30&quot; text=&quot;距离四周30&quot; /&gt; &lt;button text=&quot;普通的按钮&quot; /&gt; &lt;/horizontal&gt; );   第一个按钮的 margin 属性指定了他的边距为 30dp, 也就是他与水平布局以及第二个按钮的间距都是 30dp, 其显示效果如图:    如果把margin=&quot;30&quot;改成margin=&quot;10 40&quot;那么第一个按钮的左右间距为 10dp, 上下间距为 40dp, 效果如图:    有关 margin 属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"marginLeft​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#marginleft","content":" View 的左外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效，例如margin=&quot;20&quot; marginLeft=&quot;10&quot;的左外边距为 10dp，其他外边距为 20dp。  &quot;ui&quot;; ui.layout( &lt;horizontal&gt; &lt;button marginLeft=&quot;50&quot; text=&quot;距离左边50&quot; /&gt; &lt;button text=&quot;普通的按钮&quot; /&gt; &lt;/horizontal&gt; );   第一个按钮指定了左外边距为 50dp，则他和他的父布局水平布局(horizontal)的左边的间距为 50dp, 效果如图：    ","version":"Next","tagName":"h2"},{"title":"marginRight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#marginright","content":" View 的右外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"marginTop​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#margintop","content":" View 的上外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"marginBottom​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#marginbottom","content":" View 的下外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"padding​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#padding","content":" View 和他的自身内容的间距，也就是内边距。注意和 margin 属性区分开来，margin 属性是 View 之间的间距，而 padding 是 View 和他自身内容的间距。举个例子，一个文本控件的 padding 也即文本控件的边缘和他的文本内容的间距，paddingLeft 即文本控件的左边和他的文本内容的间距。  paddding 属性的值同样有三种格式：  padding=&quot;paddingAll&quot; 指定各个内边距都是该值。例如padding=&quot;10&quot;表示左右上下内边距都是 10dp。padding=&quot;paddingLeft paddingTop paddingRight paddingBottom&quot; 分别指定各个内边距。例如padding=&quot;10 20 30 40&quot;表示左内边距为 10dp, 上内边距为 20dp, 右内边距为 30dp, 下内边距为 40dppadding=&quot;paddingHorizontal paddingVertical&quot; 指定水平内边距和垂直内边距。例如padding=&quot;10 20&quot;表示左右内边距为 10dp, 上下内边距为 20dp。  用一个例子来具体理解内边距的含义：  &quot;ui&quot;; ui.layout( &lt;frame w=&quot;*&quot; h=&quot;*&quot; gravity=&quot;center&quot;&gt; &lt;text padding=&quot;10 20 30 40&quot; bg=&quot;#ff0000&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;HelloWorld&quot; /&gt; &lt;/frame&gt; );   这个例子是一个居中的按钮(通过父布局的gravity=&quot;center&quot;属性设置)，背景色为红色(bg=&quot;#ff0000&quot;)，文本内容为&quot;HelloWorld&quot;，左边距为 10dp，上边距为 20dp，下边距为 30dp，右边距为 40dp，其显示效果如图：    ","version":"Next","tagName":"h2"},{"title":"paddingLeft​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#paddingleft","content":" View 的左内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"paddingRight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#paddingright","content":" View 的右内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"paddingTop​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#paddingtop","content":" View 的上内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"paddingBottom​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#paddingbottom","content":" View 的下内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。  ","version":"Next","tagName":"h2"},{"title":"bg​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#bg","content":" View 的背景。其值可以是一个链接或路径指向的图片，或者 RGB 格式的颜色，或者其他背景。具体参见Drawables。  例如，bg=&quot;#00ff00&quot;设置背景为绿色，bg=&quot;file:///sdcard/1.png&quot;设置背景为图片&quot;1.png&quot;，bg=&quot;?attr/selectableItemBackground&quot;设置背景为点击时出现的波纹效果(可能需要同时设置clickable=&quot;true&quot;才生效)。  ","version":"Next","tagName":"h2"},{"title":"alpha​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#alpha","content":" View 的透明度，其值是一个 0~1 之间的小数，0 表示完全透明，1 表示完全不透明。例如alpha=&quot;0.5&quot;表示半透明。  ","version":"Next","tagName":"h2"},{"title":"foreground​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#foreground","content":" View 的前景。前景即在一个 View 的内容上显示的内容，可能会覆盖掉 View 本身的内容。其值和属性 bg 的值类似。  ","version":"Next","tagName":"h2"},{"title":"minHeight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#minheight","content":" View 的最小高度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。  例：&lt;text height=&quot;auto&quot; minHeight=&quot;50&quot;/&gt;  有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"minWidth​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#minwidth","content":" View 的最小宽度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。  例：&lt;input width=&quot;auto&quot; minWidth=&quot;50&quot;/&gt;  有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"visibility​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#visibility","content":" View 的可见性，该属性可以决定 View 是否显示出来。其值可以为：  gone 不可见。visible 可见。默认情况下 View 都是可见的。invisible 不可见，但仍然占用位置。  ","version":"Next","tagName":"h2"},{"title":"rotation​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#rotation","content":" View 的旋转角度。通过该属性可以让这个 View 顺时针旋转一定的角度。例如rotation=&quot;90&quot;可以让他顺时针旋转 90 度。  如果要设置旋转中心，可以通过transformPivotX, transformPivotY属性设置。默认的旋转中心为 View 的中心。  ","version":"Next","tagName":"h2"},{"title":"transformPivotX​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#transformpivotx","content":" View 的变换中心坐标 x。用于 View 的旋转、放缩等变换的中心坐标。例如transformPivotX=&quot;10&quot;。  该坐标的坐标系以 View 的左上角为原点。也就是 x 值为变换中心到 View 的左边的距离。  有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"transformPivotY​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#transformpivoty","content":" View 的变换中心坐标 y。用于 View 的旋转、放缩等变换的中心坐标。例如transformPivotY=&quot;10&quot;。  该坐标的坐标系以 View 的左上角为原点。也就是 y 值为变换中心到 View 的上边的距离。  有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"style​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#style","content":" 设置 View 的样式。不同控件有不同的可选的内置样式。具体参见各个控件的说明。  需要注意的是，style 属性只支持安卓 5.1 及其以上。  文本控件: text  文本控件用于显示文本，可以控制文本的字体大小，字体颜色，字体等。  以下介绍该控件的主要属性和方法，如果要查看他的所有属性和方法，请阅读TextView。  ","version":"Next","tagName":"h2"},{"title":"text​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#text","content":" 设置文本的内容。例如text=&quot;一段文本&quot;。  ","version":"Next","tagName":"h2"},{"title":"textColor​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#textcolor","content":" 设置字体的颜色，可以是 RGB 格式的颜色(例如#ff00ff)，或者颜色名称(例如 red, green 等)，具体参见颜色。  示例, 红色字体：&lt;text text=&quot;红色字体&quot; textColor=&quot;red&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"textSize​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#textsize","content":" 设置字体的大小，单位一般是 sp。按照 Material Design 的规范，正文字体大小为 14sp，标题字体大小为 18sp，次标题为 16sp。  示例，超大字体: &lt;text text=&quot;超大字体&quot; textSize=&quot;40sp&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"textStyle​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#textstyle","content":" 设置字体的样式，比如斜体、粗体等。可选的值为：  bold 加粗字体italic 斜体normal 正常字体  可以用或(&quot;|&quot;)把他们组合起来，比如粗斜体为&quot;bold|italic&quot;。  例如，粗体：`  ","version":"Next","tagName":"h2"},{"title":"lines​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#lines","content":" 设置文本控件的行数。即使文本内容没有达到设置的行数，控件也会留出相应的宽度来显示空白行；如果文本内容超出了设置的行数，则超出的部分不会显示。  另外在 xml 中是不能设置多行文本的，要在代码中设置。例如:  &quot;ui&quot;; ui.layout( &lt;vertical&gt; &lt;text id=&quot;myText&quot; line=&quot;3&quot;&gt; &lt;/vertical&gt; ) //通过\\n换行 ui.myText.setText(&quot;第一行\\n第二行\\n第三行\\n第四行&quot;);   ","version":"Next","tagName":"h2"},{"title":"maxLines​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#maxlines","content":" 设置文本控件的最大行数。  ","version":"Next","tagName":"h2"},{"title":"typeface​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#typeface","content":" 设置字体。可选的值为：  normal 正常字体sans 衬线字体serif 非衬线字体monospace 等宽字体  示例，等宽字体: &lt;text text=&quot;等宽字体&quot; typeface=&quot;monospace&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"ellipsize​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#ellipsize","content":" 设置文本的省略号位置。文本的省略号会在文本内容超出文本控件时显示。可选的值为：  end 在文本末尾显示省略号marquee 跑马灯效果，文本将滚动显示middle 在文本中间显示省略号none 不显示省略号start 在文本开头显示省略号  ","version":"Next","tagName":"h2"},{"title":"ems​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#ems","content":" 当设置该属性后,TextView 显示的字符长度（单位是 em）,超出的部分将不显示，或者根据 ellipsize 属性的设置显示省略号。  例如，限制文本最长为 5em: `  ","version":"Next","tagName":"h2"},{"title":"autoLink​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#autolink","content":" 控制是否自动找到 url 和电子邮件地址等链接，并转换为可点击的链接。默认值为“none”。  设置该值可以让文本中的链接、电话等变成可点击状态。  可选的值为以下的值以其通过或(&quot;|&quot;)的组合：  all 匹配所有连接、邮件、地址、电话email 匹配电子邮件地址map 匹配地图地址none 不匹配 (默认)phone 匹配电话号码web 匹配 URL 地址  示例：&lt;text autoLink=&quot;web|phone&quot; text=&quot;百度: http://www.baidu.com 电信电话: 10000&quot;/&gt;  按钮控件: button  按钮控件是一个特殊的文本控件，因此所有文本控件的函数的属性都适用于按钮控件。  除此之外，按钮控件有一些内置的样式，通过style属性设置，包括：  Widget.AppCompat.Button.Colored 带颜色的按钮Widget.AppCompat.Button.Borderless 无边框按钮Widget.AppCompat.Button.Borderless.Colored 带颜色的无边框按钮  这些样式的具体效果参见&quot;示例/界面控件/按钮控件.js&quot;。  例如：&lt;button style=&quot;Widget.AppCompat.Button.Colored&quot; text=&quot;漂亮的按钮&quot;/&gt;  输入框控件: input  输入框控件也是一个特殊的文本控件，因此所有文本控件的函数的属性和函数都适用于按钮控件。输入框控件有自己的属性和函数，要查看所有这些内容，阅读EditText。  对于一个输入框控件，我们可以通过 text 属性设置他的内容，通过 lines 属性指定输入框的行数；在代码中通过getText()函数获取输入的内容。 注意：getText()函数获取输入框的内容时，返回类型是Editable，如果判断是否为空，不能==null，因为不为null，也不能equals（“”），因为类型不一样。如果要获取内容作为字符串，并且使用原生js对字符串的操作函数，需要使用ui.xx.text()的写法来获取内容，如：ui.name.text()  例如：  &quot;ui&quot;; ui.layout( &lt;vertical padding=&quot;16&quot;&gt; &lt;text textSize=&quot;16sp&quot; textColor=&quot;black&quot; text=&quot;请输入姓名&quot; /&gt; &lt;input id=&quot;name&quot; text=&quot;小明&quot; /&gt; &lt;button id=&quot;ok&quot; text=&quot;确定&quot; /&gt; &lt;/vertical&gt; ); //指定确定按钮点击时要执行的动作 ui.ok.click(function () { //通过getText()获取输入的内容 //var name = ui.name.getText(); var name = ui.name.text(); toast(name + &quot;您好!&quot;); });   效果如图：    除此之外，输入框控件有另外一些主要属性(虽然这些属性对于文本控件也是可用的但一般只用于输入框控件)：  ","version":"Next","tagName":"h2"},{"title":"hint​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#hint","content":" 输入提示。这个提示会在输入框为空的时候显示出来。如图所示:    上面图片效果的代码为：  &quot;ui&quot;; ui.layout( &lt;vertical&gt; &lt;input hint=&quot;请输入姓名&quot; /&gt; &lt;/vertical&gt; );   ","version":"Next","tagName":"h2"},{"title":"textColorHint​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#textcolorhint","content":" 指定输入提示的字体颜色。  ","version":"Next","tagName":"h2"},{"title":"textSizeHint​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#textsizehint","content":" 指定输入提示的字体大小。  ","version":"Next","tagName":"h2"},{"title":"inputType​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#inputtype","content":" 指定输入框可以输入的文本类型。可选的值为以下值及其用&quot;|&quot;的组合:  date 用于输入日期。datetime 用于输入日期和时间。none 没有内容类型。此输入框不可编辑。number 仅可输入数字。numberDecimal 可以与 number 和它的其他选项组合，以允许输入十进制数(包括小数)。numberPassword 仅可输入数字密码。numberSigned 可以与 number 和它的其他选项组合，以允许输入有符号的数。phone 用于输入一个电话号码。text 只是普通文本。textAutoComplete 可以与 text 和它的其他选项结合, 以指定此字段将做自己的自动完成, 并适当地与输入法交互。textAutoCorrect 可以与 text 和它的其他选项结合, 以请求自动文本输入纠错。textCapCharacters 可以与 text 和它的其他选项结合, 以请求大写所有字符。textCapSentences 可以与 text 和它的其他选项结合, 以请求大写每个句子里面的第一个字符。textCapWords 可以与 text 和它的其他选项结合, 以请求大写每个单词里面的第一个字符。textEmailAddress 用于输入一个电子邮件地址。textEmailSubject 用于输入电子邮件的主题。textImeMultiLine 可以与 text 和它的其他选项结合，以指示虽然常规文本视图不应为多行, 但如果可以, 则 IME 应提供多行支持。textLongMessage 用于输入长消息的内容。textMultiLine 可以与 text 和它的其他选项结合, 以便在该字段中允许多行文本。如果未设置此标志, 则文本字段将被限制为单行。textNoSuggestions 可以与 text 及它的其他选项结合, 以指示输入法不应显示任何基于字典的单词建议。textPassword 用于输入密码。textPersonName 用于输入人名。textPhonetic 用于输入拼音发音的文本, 如联系人条目中的拼音名称字段。textPostalAddress 用于输入邮寄地址。textShortMessage 用于输入短的消息内容。textUri 用于输入一个 URI。textVisiblePassword 用于输入可见的密码。textWebEditText 用于输入在 web 表单中的文本。textWebEmailAddress 用于在 web 表单里输入一个电子邮件地址。textWebPassword 用于在 web 表单里输入一个密码。time 用于输入时间。  例如，想指定一个输入框的输入类型为小数数字，为: &lt;input inputType=&quot;number|numberDecimal&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"password​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#password","content":" 指定输入框输入框是否为密码输入框。默认为false。  例如：&lt;input password=&quot;true&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"numeric​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#numeric","content":" 指定输入框输入框是否为数字输入框。默认为false。  例如：&lt;input numeric=&quot;true&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"phoneNumber​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#phonenumber","content":" 指定输入框输入框是否为电话号码输入框。默认为false。  例如：&lt;input phoneNumber=&quot;true&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"digits​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#digits","content":" 指定输入框可以输入的字符。例如，要指定输入框只能输入&quot;1234567890+-&quot;，为&lt;input digits=&quot;1234567890+-&quot;/&gt;。  ","version":"Next","tagName":"h2"},{"title":"singleLine​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#singleline","content":" 指定输入框是否为单行输入框。默认为false。您也可以通过lines=&quot;1&quot;来指定单行输入框。  例如：&lt;input singleLine=&quot;true&quot;/&gt;  图片控件: img  图片控件用于显示来自网络、本地或者内嵌数据的图片，并可以指定图片以圆角矩形、圆形等显示。但是不能用于显示 gif 动态图。  这里只介绍他的主要方法和属性，如果要查看他的所有方法和属性，阅读ImageView。  ","version":"Next","tagName":"h2"},{"title":"src​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#src","content":" 使用一个 Uri 指定图片的来源。可以是图片的地址(http://....)，本地路径(file://....)或者 base64 数据(&quot;data:image/png;base64,...&quot;)。  如果使用图片地址或本地路径，Auto.js 会自动使用适当的缓存来储存这些图片，减少下次加载的时间。  例如，显示百度的 logo:  &quot;ui&quot;; ui.layout( &lt;frame&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; /&gt; &lt;/frame&gt; );   再例如，显示文件/sdcard/1.png 的图片为 &lt;img src=&quot;file:///sdcard/1.png&quot;/&gt;。 再例如，使 base64 显示一张钱包小图片为：  &quot;ui&quot;; ui.layout( &lt;frame&gt; &lt;img w=&quot;40&quot; h=&quot;40&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEu0lEQVRoge3bW4iVVRQH8N+ZnDKxvJUGCSWUlXYle/ChiKAkIiu7UXQjonwNIopM8cHoAhkRGQXdfIiE0Ep8KalQoptRTiFFZiRlOo6TPuSk4zk97G9w5vidc77LPjNi84f1MN+391rrf9a+rL32N4xiFMcUjouo5zyciYPYH0FnBadiNiZiD2oR9JbGRdgiOFPDIXRhCWYU0Dcj6duV6BrQuyWxNaLowBcOO1Uv+7EKc4WINUIlabMq6dNI35eJzRHDWOzS2MEB6cd6XI/OQf07k2frkzat9HQnNkcUG7R2dECq2I53EtmePMvaf+MwcWqKu+RzuqhUcfcwcWqKTvmiXFQ2GDodRhQz0aN9ZHsSG0cVrkGf+GT7MG8YeeTCHeKS7sOdMR1stjcWxY2YH0nXh1gdSdf/E+2I8KVYigkl9ewVUsxNpT1qMzaKN4ejJxrtyEt7IuraE1EX2jOkp+JBnFxSzz68KuTqoyiK2BHuxDO4NpK+j/GoOAWF6BiH98Q/SHyCycPIIxMm4FPZCPTj30SynIFr+A7ThotMK4wXopA1Ym9gSiKv5Oj3bdKnFMpuS514E1fm6NMnbF098s3NS4QS0Ik5+hyBsoSXYkGO9jvxy6C/t+IPIYJZcBWW57AXFfMNrSo2kqqw2l4hvSzcIRTw1sm24FVxb5s4NcR0/JXBuUNYJttI6sDjsi1kvTgrGpsMjq3O4FQNa+SbNhWsyKj7I4wpzSYDbpFtKB/EOSn9ZwpRfx5Xp7yfhN0Z9FdxXxxKjTEe2zI4U8NnKf3PNrT2VcWTKe1eyGjjT+Eapm14IqMjNTyd0n9JSrsDwhmaEN2H8GMOO8viUjyMSfJVJh9O0bGoQdt1eFm2oVwve7UpC1ssX568KEXH6fghp54s8lRkrk7CjpxOrGqg6wQ8IKSKWXPpVtIt8ly+v4ATf2t+yqlgDl5SbCjXy8JIXFXweQEHqngxo43JeEw54l+JVLKaJeypRZzoFxavrIWG6cKPW2SO9+PCMkQHsLiA8fpIv5/DmUn4qaCtpWWIEiLzdUHj9XJA2H5uFRbBZriuoI1NSpatpio+nJtFvFvYd2c1sDsGvxfQ3a/knrwgMtm0qD8rPSprCuq8uRmhVqvanBbvm+EQfsNKIcnvTmnTiUdwQcq73oJ2L2v2stXx6vyCRr8RDuk/C8OMUK24J6VtBaekPG81zxuh0TTJhC7FhtUOHF+n61whGalvu8uRWVJFvgPEYOkqQzhLVSPPXLoYa4Xh3Stcls1NaTdb8Xx7ZxnCvSUIfy/kzWno0Pyzx3dL2C0695Hto7NGUhXy5Lzp3kLZKiqNpNTl2+YShgdIvyXbVck44TB/oKTNzWUIv13S+IDsFmpY84QvZAcwTbh4e04o18SwtbIM4dsiOTFYVgzSv7wN+m9vRqjV/PrA0JuCox1bhYNKQ7Qi3CcU1fpiedRG9AkLXhRfbxCnKlET0s21ifwaSWcPbopBdDDOwGtClTD2vCsq+/C68K8HmVDk7DhFyIsvFzKnGThN+689+oU9dptwQb5B+LB8dx4lMb7xqAhkJwo/xljhFFSfSdUc3mPrcbwj15P+pP0/QiR7hYSkGsHnUYziWMF/mXV4JVcZ8G0AAAAASUVORK5CYII=&quot; /&gt; &lt;/frame&gt; );   ","version":"Next","tagName":"h2"},{"title":"tint​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#tint","content":" 图片着色，其值是一个颜色名称或 RGB 颜色值。使用该属性会将图片中的非透明区域都涂上同一颜色。可以用于改变图片的颜色。  例如，对于上面的 base64 的图片: &lt;img w=&quot;40&quot; h=&quot;40&quot; tint=&quot;red&quot; src=&quot;data:image/png;base64,...&quot;/&gt;，则钱包图标颜色会变成红色。  ","version":"Next","tagName":"h2"},{"title":"scaleType​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#scaletype","content":" 控制图片根据图片控件的宽高放缩时的模式。可选的值为：  center 在控件中居中显示图像, 但不执行缩放。centerCrop 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 等于或大于控件的相应尺寸 (不包括内边距 padding)并且使图像在控件中居中显示。centerInside 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 小于视图的相应尺寸 (不包括内边距 padding)并且图像在控件中居中显示。fitCenter 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件中居中显示fitEnd 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件中靠右下角显示fitStart 保持图像的长宽比缩放图片, 使图片的宽或高和控件的宽高相同并使图片在控件靠左上角显示fitXY 使图片和宽高和控件的宽高完全匹配，但图片的长宽比可能不能保持一致matrix 绘制时使用图像矩阵进行缩放。需要在代码中使用setImageMatrix(Matrix)函数才能生效。  默认的 scaleType 为fitCenter；除此之外最常用的是fitXY， 他能使图片放缩到控件一样的大小，但图片可能会变形。  ","version":"Next","tagName":"h2"},{"title":"radius​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#radius","content":" 图片控件的半径。如果设置为控件宽高的一半并且控件的宽高相同则图片将剪切为圆形显示；否则图片为圆角矩形显示，半径即为四个圆角的半径，也可以通过radiusTopLeft, radiusTopRight, radiusBottomLeft, radiusBottomRight等属性分别设置四个圆角的半径。  例如，圆角矩形的 Auto.js 图标：&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;  有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"radiusTopLeft​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#radiustopleft","content":" 图片控件的左上角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"radiusTopRight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#radiustopright","content":" 图片控件的右上角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"radiusBottomLeft​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#radiusbottomleft","content":" 图片控件的左下角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"radiusBottomRight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#radiusbottomright","content":" 图片控件的右下角圆角的半径。有关该属性的单位，参见尺寸的单位: Dimension。  ","version":"Next","tagName":"h2"},{"title":"borderWidth​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#borderwidth","content":" 图片控件的边框宽度。用于在图片外面显示一个边框，边框会随着图片控件的外形(圆角等)改变而相应变化。 例如, 圆角矩形带灰色边框的 Auto.js 图标：&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; borderWidth=&quot;5&quot; borderColor=&quot;gray&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;  ","version":"Next","tagName":"h2"},{"title":"borderColor​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#bordercolor","content":" 图片控件的边框颜色。  ","version":"Next","tagName":"h2"},{"title":"circle​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#circle","content":" 指定该图片控件的图片是否剪切为圆形显示。如果为true，则图片控件会使其宽高保持一致(如果宽高不一致，则保持高度等于宽度)并使圆形的半径为宽度的一半。  例如，圆形的 Auto.js 图标：&lt;img w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;  垂直布局: vertical  垂直布局是一种比较简单的布局，会把在它里面的控件按照垂直方向依次摆放，如下图所示：  垂直布局:  —————  | 控件 1 |  | 控件 2 |  | 控件 3 |  | ............ |  ——————  ","version":"Next","tagName":"h2"},{"title":"layout_weight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#layout_weight","content":" 垂直布局中的控件可以通过layout_weight属性来控制控件高度占垂直布局高度的比例。如果为一个控件指定layout_weight, 则这个控件的高度=垂直布局剩余高度 * layout_weight / weightSum；如果不指定 weightSum, 则 weightSum 为所有子控件的 layout_weight 之和。所谓&quot;剩余高度&quot;，指的是垂直布局中减去没有指定 layout_weight 的控件的剩余高度。 例如:  &quot;ui&quot;; ui.layout( &lt;vertical h=&quot;100dp&quot;&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot; /&gt; &lt;/vertical&gt; );   在这个布局中，三个控件的 layout_weight 都是 1，也就是他们的高度都会占垂直布局高度的 1/3，都是 33.3dp. 再例如：  &quot;ui&quot;; ui.layout( &lt;vertical h=&quot;100dp&quot;&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot; /&gt; &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot; /&gt; &lt;/vertical&gt; );   在这个布局中，第一个控件高度为 1/4, 第二个控件为 2/4, 第三个控件为 1/4. 再例如：  &quot;ui&quot;; ui.layout( &lt;vertical h=&quot;100dp&quot; weightSum=&quot;5&quot;&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot; /&gt; &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot; /&gt; &lt;/vertical&gt; );   在这个布局中，因为指定了 weightSum 为 5, 因此第一个控件高度为 1/5, 第二个控件为 2/5, 第三个控件为 1/5. 再例如：  &quot;ui&quot;; ui.layout( &lt;vertical h=&quot;100dp&quot;&gt; &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot; /&gt; &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot; /&gt; &lt;/vertical&gt; );   在这个布局中，第一个控件并没有指定 layout_weight, 而是指定高度为 40dp, 因此不加入比例计算，此时布局剩余高度为 60dp。第二个控件高度为剩余高度的 2/3，也就是 40dp，第三个控件高度为剩余高度的 1/3，也就是 20dp。  垂直布局的 layout_weight 属性还可以用于控制他的子控件高度占满剩余空间，例如：  &quot;ui&quot;; ui.layout( &lt;vertical h=&quot;100dp&quot;&gt; &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot; /&gt; &lt;text h=&quot;40dp&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot; /&gt; &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot; /&gt; &lt;/vertical&gt; );   在这个布局中，第三个控件的高度会占满除去控件 1 和控件 2 的剩余空间。  水平布局: horizontal  水平布局是一种比较简单的布局，会把在它里面的控件按照水平方向依次摆放，如下图所示： 水平布局: ————————————————————————————  | 控件 1 | 控件 2 | 控件 3 | ... |  ————————————————————————————  ","version":"Next","tagName":"h2"},{"title":"layout_weight​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#layout_weight-1","content":" 水平布局中也可以使用 layout_weight 属性来控制子控件的宽度占父布局的比例。和垂直布局中类似，不再赘述。  线性布局: linear  实际上，垂直布局和水平布局都属于线性布局。线性布局有一个 orientation 的属性，用于指定布局的方向，可选的值为vertical和horizontal。  例如&lt;linear orientation=&quot;vertical&quot;&gt;&lt;/linear&gt;相当于&lt;vertical&gt;&lt;/vertical&gt;。  线性布局的默认方向是横向的，因此，一个没有指定 orientation 属性的线性布局就是横向布局。  帧布局: frame  帧布局  相对布局: relative  勾选框控件: checkbox  选择框控件: radio  选择框布局: radiogroup  开关控件: switch  进度条控件: progressbar  拖动条控件: seekbar  下来菜单控件: spinner  时间选择控件: timepicker  日期选择控件: datepicker  浮动按钮控件: fab  标题栏控件: toolbar  卡片: card  抽屉布局: drawer  列表: list  Tab: tab  ui  ","version":"Next","tagName":"h2"},{"title":"ui.layout(xml)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uilayoutxml","content":" xml {XML} | {string} 布局 XML 或者 XML 字符串  将布局 XML 渲染为视图（View）对象， 并设置为当前视图。  ","version":"Next","tagName":"h2"},{"title":"ui.inflate(xml[, parent = null, attachToParent = false])​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uiinflatexml-parent--null-attachtoparent--false","content":" xml {string} | {XML} 布局 XML 或者 XML 字符串parent {View} 父视图attachToParent {boolean} 是否渲染的 View 加到父视图中，默认为 false 返回 {View}  将布局 XML 渲染为视图（View）对象。如果该 View 将作为某个 View 的子 View，我们建议传入 parent 参数，这样在渲染时依赖于父视图的一些布局属性能够正确应用。  此函数用于动态创建、显示 View。  &quot;ui&quot;; $ui.layout(&lt;linear id=&quot;container&quot;&gt;&lt;/linear&gt;); // 动态创建3个文本控件，并加到container容器中 // 这里仅为实例，实际上并不推荐这种做法，如果要展示列表， // 使用list组件；动态创建十几个、几十个View会让界面卡顿 for (let i = 0; i &lt; 3; i++) { let textView = $ui.inflate( &lt;text textColor=&quot;#000000&quot; textSize=&quot;14sp&quot; /&gt;, $ui.container ); textView.attr(&quot;text&quot;, &quot;文本控件&quot; + i); $ui.container.addView(textView); }   ","version":"Next","tagName":"h2"},{"title":"ui.findView(id)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uifindviewid","content":" id {string} View 的 ID返回 {View}  在当前视图中根据 ID 查找相应的视图对象并返回。如果当前未设置视图或找不到此 ID 的视图时返回null。  一般我们都是通过ui.xxx来获取 id 为 xxx 的控件，如果 xxx 是一个 ui 已经有的属性，就可以通过ui.findView()来获取这个控件  ","version":"Next","tagName":"h2"},{"title":"ui.finish()​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uifinish","content":" 结束当前活动并销毁界面。  ","version":"Next","tagName":"h2"},{"title":"ui.setContentView(view)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uisetcontentviewview","content":" -view {View}  将视图对象设置为当前视图。  ","version":"Next","tagName":"h2"},{"title":"ui.run(callback)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uiruncallback","content":" -callback {Function} 回调函数 -返回 {any} callback 的执行结果  将callback在 UI 线程中执行。如果当前已经在 UI 线程中，则直接执行callback；否则将callback抛到 UI 线程中执行（加到 UI 线程的消息循环的末尾），并等待 callback 执行结束(阻塞当前线程)。  ","version":"Next","tagName":"h2"},{"title":"ui.post(callback[, daley])​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uipostcallback-daley","content":" callback {Function} 回调函数delay {number} 延迟，单位毫秒  将callback加到 UI 线程的消息循环中，并延迟delay毫秒后执行（不能准确保证一定在 delay 毫秒后执行）。  此函数可以用于 UI 线程中延时执行动作（sleep 不能在 UI 线程中使用），也可以用于子线程中更新 UI。  &quot;ui&quot;; ui.layout( &lt;frame&gt; &lt;text id=&quot;result&quot;/&gt; &lt;/frame&gt; ); ui.result.attr(&quot;text&quot;, &quot;计算中&quot;); // 在子线程中计算1+ ... + 10000000 threads.start({ let sum = 0; for (let i = 0; i &lt; 1000000; i++) { sum += i; } // 由于不能在子线程操作UI，所以要抛到UI线程执行 ui.post(() =&gt; { ui.result.attr(&quot;text&quot;, String(sum)); }); });   ","version":"Next","tagName":"h2"},{"title":"ui.statusBarColor(color)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uistatusbarcolorcolor","content":" color {string | number} 颜色  设置当前界面的状态栏颜色。  &quot;ui&quot;; ui.statusBarColor(&quot;#000000&quot;);   ","version":"Next","tagName":"h2"},{"title":"ui.showPopupMenu(view, menu)​","type":1,"pageTitle":"UI 用户界面","url":"/docs/rhino/base/ui#uishowpopupmenuview-menu","content":" 尺寸的单位: Dimension  Drawables  颜色  (完善中...) ","version":"Next","tagName":"h2"},{"title":"Q & A 常见问题","type":0,"sectionRef":"#","url":"/docs/rhino/qa","content":"","keywords":"","version":"Next"},{"title":"如何定时运行脚本​","type":1,"pageTitle":"Q & A 常见问题","url":"/docs/rhino/qa#如何定时运行脚本","content":" 点击脚本右边的菜单按钮-&gt;更多-&gt;定时任务即可定时运行脚本，但是必须保持 Auto.js 后台运行(自启动白名单、电源管理白名单等)。同时，可以在脚本的开头使用device.wakeUp()来唤醒屏幕；但是，Auto.js 没有解锁屏幕的功能，因此难以在有锁屏密码的设备上达到效果。  ","version":"Next","tagName":"h2"},{"title":"定时任务如何获取外部参数​","type":1,"pageTitle":"Q & A 常见问题","url":"/docs/rhino/qa#定时任务如何获取外部参数","content":" 如果一个脚本是用 intent&quot;启动&quot;的，比如定时任务中的特定事件（网络状态变化等）触发而启动的，则可以通过engines.myEngine().execArgv.intent获取启动的 intent，从而获取外部参数。  ","version":"Next","tagName":"h2"},{"title":"如何把图片和脚本一起打包，或者打包多个脚本​","type":1,"pageTitle":"Q & A 常见问题","url":"/docs/rhino/qa#如何把图片和脚本一起打包或者打包多个脚本","content":" 如果除了单脚本以外还有其他脚本、图片、音乐等资源一起打包，则需要使用项目功能。  点击 Auto.js 的&quot;+&quot;号，选择项目，填写项目名称、包名等信息以后，点击&quot;√&quot;即可新建一个项目。可以在项目中放多个脚本、模块、资源文件，点击项目工具栏的 apk 打包图标即可打包一个项目，点击工具栏可以重新配置项目。  例如，主脚本要读取同一文件夹下的图片 1.png，再执行找图，则可以通过images.read(&quot;./1.png&quot;)来读取，其中&quot;./1.png&quot;表示同一目录 1.png 图片；ui 中的图片控件要引用同一文件夹的 2.png 图片则为&lt;img src=&quot;file://2.png&quot;/&gt;。Auto.js 内置的函数和模块都支持相对路径，但是，其他情况则需要使用files.path()函数来把相对路径转换为绝对路径。  ","version":"Next","tagName":"h2"},{"title":"如何使打包的应用不显示主界面​","type":1,"pageTitle":"Q & A 常见问题","url":"/docs/rhino/qa#如何使打包的应用不显示主界面","content":" 需要使用项目功能。新建项目后，修改项目下的project.json文件，增加以下条目：  &quot;launchConfig&quot;: { &quot;hideLogs&quot;: true }   例如：  { &quot;name&quot;: &quot;项目名称&quot;, &quot;versionName&quot;: &quot;1.0.0&quot;, &quot;versionCode&quot;: 1, &quot;packageName&quot;: &quot;org.autojs.example&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;launchConfig&quot;: { &quot;hideLogs&quot;: true } }   &quot;launchConfig&quot;表示启动配置，&quot;hideLogs&quot;表示隐藏日志。  参见项目与项目配置。  ","version":"Next","tagName":"h2"},{"title":"Auto.js 自带的模块和函数中没有的功能如何实现​","type":1,"pageTitle":"Q & A 常见问题","url":"/docs/rhino/qa#autojs-自带的模块和函数中没有的功能如何实现","content":" 由于 Auto.js 支持直接调用 Android 的 API，对于 Auto.js 没有内置的函数，可以直接通过修改 Android 代码为 JavaScript 代码实现。例如旋转图片的 Android 代码为：  import android.graphics.Bitmap; import android.graphics.Matrix; public static Bitmap rotate(final Bitmap src, final int degrees, final float px, final float py) { if (degrees == 0) return src; Matrix matrix = new Matrix(); matrix.setRotate(degrees, px, py); Bitmap ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true); return ret; }   转换为 JavaScript 的代码后为：  importClass(android.graphics.Bitmap); importClass(android.graphics.Matrix); function rotate(src, degrees, px, py) { if (degrees == 0) return src; var matrix = new Matrix(); matrix.setRotate(degrees, px, py); var ret = Bitmap.createBitmap( src, 0, 0, src.getWidth(), src.getHeight(), matrix, true ); return ret; }   有关调用 Android 和 Java 的 API 的更多信息，参见 Work with Java。 ","version":"Next","tagName":"h2"},{"title":"与 Java 交互","type":0,"sectionRef":"#","url":"/docs/rhino/workWithJava","content":"与 Java 交互 关于调用 java 请查看这里 ，一个由 Rhino 维护者使用 GitHub Pages 部署的 Rhino 文档网站 官方 issues 关于原 Rhino 文档地址 404 的讨论","keywords":"","version":"Next"},{"title":"rxjs","type":0,"sectionRef":"#","url":"/docs/rhino/npm/rxjs","content":"","keywords":"","version":"Next"},{"title":"例子​","type":1,"pageTitle":"rxjs","url":"/docs/rhino/npm/rxjs#例子","content":" &quot;ui&quot;; let { fromEvent } = require(&quot;rxjs&quot;); ui.layout( &lt;vertical padding=&quot;16&quot;&gt; &lt;button id=&quot;y&quot; text=&quot;普通按钮&quot; w=&quot;auto&quot; /&gt; &lt;vertical id=&quot;box&quot;&gt;&lt;/vertical&gt; &lt;/vertical&gt;, ); //从按钮的点击事件创建一个可观察对象 let ob = fromEvent(ui.y, &quot;click&quot;); let box = ui.box; //订阅这个对象 ob.subscribe(() =&gt; { ui.inflate(&lt;text text=&quot;1234&quot;&gt;&lt;/text&gt;, box, true); });   很多时候我们不希望这个按钮触发的太快，使用纯js就需要添加额外的变量用于判断，使用rxjs只需要添加一个throttleTime操作符  &quot;ui&quot;; let { fromEvent,throttleTime } = require(&quot;rxjs&quot;); ui.layout( &lt;vertical padding=&quot;16&quot;&gt; &lt;button id=&quot;y&quot; text=&quot;普通按钮&quot; w=&quot;auto&quot; /&gt; &lt;vertical id=&quot;box&quot;&gt;&lt;/vertical&gt; &lt;/vertical&gt;, ); //从按钮的点击事件创建一个可观察对象 let ob = fromEvent(ui.y, &quot;click&quot;).pipe(throttleTime(1000)) let box = ui.box; //订阅这个对象 ob.subscribe(() =&gt; { ui.inflate(&lt;text text=&quot;1234&quot;&gt;&lt;/text&gt;, box, true); });   可以将大部分采用回调、事件、Promise的api转换成Observable  //回调 let { bindCallback } = require(&quot;rxjs&quot;); let httpGet = bindCallback(http.get); httpGet(&quot;https://m.baidu.com&quot;, {}).subscribe({ next: (res, err) =&gt; { console.log(&quot;body:&quot;, res.body.string().length); }, complete(){ console.log('done') } }); //事件 fromEvent(events, &quot;exit&quot;).subscribe({ next() { console.log(&quot;event on exit&quot;); } }); //Promise from(Promise.delay(1000)).subscribe({ next: () =&gt; { console.log(&quot;Promise res&quot;); }, complete() { console.log(&quot;done&quot;); }, });   ","version":"Next","tagName":"h2"},{"title":"创建操作符​","type":1,"pageTitle":"rxjs","url":"/docs/rhino/npm/rxjs#创建操作符","content":" of(...args) 将参数转换为可观察的序列。  let { of } = require(&quot;rxjs&quot;); of(10, 20, 30).subscribe({ next: value =&gt; console.log('next:', value), error: err =&gt; console.log('error:', err), complete: () =&gt; console.log('the end'), }); // Outputs // next: 10 // next: 20 // next: 30 // the end   from(input,scheduler?) 从数组、类数组对象、Promise、可迭代对象或类 Observable 对象创建 Observable。  let {from} = require(&quot;rxjs&quot;); const array = [10, 20, 30]; const result = from(array); result.subscribe(x =&gt; console.log(x)); // Logs: // 10 // 20 // 30   fromEvent(target,eventName,options?) 创建一个 Observable，它发出来自给定事件目标的特定类型的事件。intervallink(period=0,period=asyncScheduler) 创建一个 Observable，该 Observable 在指定的时间间隔内每隔指定的时间间隔发出序列号  ","version":"Next","tagName":"h2"},{"title":"调度器​","type":1,"pageTitle":"rxjs","url":"/docs/rhino/npm/rxjs#调度器","content":" rxjs中内置了几种调度器，其中最常用的是asyncScheduler，这是多数处理异步操作符使用的默认调度器，在autox环境中，只支持asyncScheduler调度器。  ","version":"Next","tagName":"h2"},{"title":"autox特有的调度器​","type":1,"pageTitle":"rxjs","url":"/docs/rhino/npm/rxjs#autox特有的调度器","content":" v6.5.6新增 由于autox中存在比较复杂的多线程环境，处理ui和阻塞操作时经常需要切换线程，因此为此库添加了几个特殊的调度器简化这些操作 需要使用以下方式导入  let { ioScheduler, uiScheduler, mainScheduler, workScheduler, newSingleScheduler, } = require(&quot;rxjs/ext&quot;);   uiScheduler 在ui线程中运行mainScheduler 在脚本主线程中运行，若是ui脚本则和uiScheduler一致newSingleScheduler() 这是一个函数，创建一个独立的线程作为调度器，使用完毕后需要调用recycle回收资源  let { from } = require(&quot;rxjs&quot;); let {newSingleScheduler} = require(&quot;rxjs/ext&quot;); let t = newSingleScheduler(); from([1,2,3],t).subscribe({ next: (v) =&gt; { console.log(v); console.log(threads.currentThread()); }, complete(){ t.recycle() } })   workScheduler 在一个默认的线程池中运行，用于处理密集计算操作。注意: 此调度器是不安全的，由于并发问题，只能配合fromEvent这样永远不会'结束'的Observable来使用，下面这个示例就不会按预期执行  let { from } = require(&quot;rxjs&quot;); let {workScheduler} = require(&quot;rxjs/ext&quot;); from([1,2,3],workScheduler).subscribe((v)=&gt;{ log(v);//可能看到0-3个输出，且是乱序的 })   原因在于Observable执行complete或error后再调用next产生的值将被忽略，就算next调用在complete前面，通过此调度器可能会导致next真正执行时在complete后面，此外某些操作符在这个调度器下也会工作异常。  ioScheduler 和workScheduler类似，区别在于每次触发会生成一个新线程来运行，比较耗费资源，适用于io操作等长时间阻塞任务  ","version":"Next","tagName":"h3"},{"title":"例子​","type":1,"pageTitle":"rxjs","url":"/docs/rhino/npm/rxjs#例子-1","content":" &quot;ui&quot;; let { fromEvent, scan, map, observeOn, throttleTime, } = require(&quot;rxjs&quot;); let { ioScheduler, uiScheduler, mainScheduler, workScheduler, newSingleScheduler, } = require(&quot;rxjs/ext&quot;); ui.layout( &lt;vertical padding=&quot;16&quot;&gt; &lt;button id=&quot;y&quot; text=&quot;普通按钮&quot; w=&quot;auto&quot; /&gt; &lt;vertical id=&quot;box&quot;&gt;&lt;/vertical&gt; &lt;/vertical&gt;, ); //从按钮的点击事件创建一个可观察对象 let ob = fromEvent(ui.y, &quot;click&quot;); let box = ui.box; //订阅这个对象 ob.pipe( scan((a) =&gt; a + 1, 0), //转到线程池调度器 observeOn(workScheduler), map((v) =&gt; { //模拟一些阻塞耗时任务 sleep(1000); return v; }), //回到ui调度器 observeOn(uiScheduler), ).subscribe((v) =&gt; { ui.inflate(&lt;text text={&quot;已计算: 第&quot; + v + &quot;次&quot;}&gt;&lt;/text&gt;, box, true); });  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}